[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar NpmModuleBcrypt = Package['npm-bcrypt'].NpmModuleBcrypt;\nvar Accounts = Package['accounts-base'].Accounts;\nvar SRP = Package.srp.SRP;\nvar SHA256 = Package.sha.SHA256;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Email = Package.email.Email;\nvar EmailInternals = Package.email.EmailInternals;\nvar Random = Package.random.Random;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"accounts-password\":{\"email_templates.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-password/email_templates.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nconst greet = welcomeMsg => (user, url) => {\n  const greeting = user.profile && user.profile.name ? \"Hello \".concat(user.profile.name, \",\") : \"Hello,\";\n  return \"\".concat(greeting, \"\\n\\n\").concat(welcomeMsg, \", simply click the link below.\\n\\n\").concat(url, \"\\n\\nThanks.\\n\");\n};\n/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n * @importFromPackage accounts-base\n */\n\n\nAccounts.emailTemplates = {\n  from: \"Accounts Example <no-reply@example.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n  resetPassword: {\n    subject: () => \"How to reset your password on \".concat(Accounts.emailTemplates.siteName),\n    text: greet(\"To reset your password\")\n  },\n  verifyEmail: {\n    subject: () => \"How to verify email address on \".concat(Accounts.emailTemplates.siteName),\n    text: greet(\"To verify your account email\")\n  },\n  enrollAccount: {\n    subject: () => \"An account has been created for you on \".concat(Accounts.emailTemplates.siteName),\n    text: greet(\"To start using the service\")\n  }\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"password_server.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-password/password_server.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\n/// BCRYPT\nconst bcrypt = NpmModuleBcrypt;\nconst bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nconst bcryptCompare = Meteor.wrapAsync(bcrypt.compare); // Utility for grabbing user\n\nconst getUserById = (id, options) => Meteor.users.findOne(id, Accounts._addDefaultFieldSelector(options)); // User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10; // Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\n\n\nconst getPasswordString = password => {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else {\n    // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");\n    }\n\n    password = password.digest;\n  }\n\n  return password;\n}; // Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\n\n\nconst hashPassword = password => {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds());\n}; // Extract the number of rounds used in the specified bcrypt hash.\n\n\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n\n  if (hash) {\n    const hashSegments = hash.split('$');\n\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n\n  return rounds;\n}; // Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\n// The user parameter needs at least user._id and user.services\n\n\nAccounts._checkPasswordUserFields = {\n  _id: 1,\n  services: 1\n}; //\n\nAccounts._checkPassword = (user, password) => {\n  const result = {\n    userId: user._id\n  };\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n\n  if (!bcryptCompare(formattedPassword, hash)) {\n    result.error = handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n    Meteor.defer(() => {\n      Meteor.users.update({\n        _id: user._id\n      }, {\n        $set: {\n          'services.password.bcrypt': bcryptHash(formattedPassword, Accounts._bcryptRounds())\n        }\n      });\n    });\n  }\n\n  return result;\n};\n\nconst checkPassword = Accounts._checkPassword; ///\n/// ERROR HANDLER\n///\n\nconst handleError = function (msg) {\n  let throwError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const error = new Meteor.Error(403, Accounts._options.ambiguousErrorMessages ? \"Something went wrong. Please check your credentials.\" : msg);\n\n  if (throwError) {\n    throw error;\n  }\n\n  return error;\n}; ///\n/// LOGIN\n///\n\n\nAccounts._findUserByQuery = (query, options) => {\n  let user = null;\n\n  if (query.id) {\n    // default field selector is added within getUserById()\n    user = getUserById(query.id, options);\n  } else {\n    options = Accounts._addDefaultFieldSelector(options);\n    let fieldName;\n    let fieldValue;\n\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n\n    let selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector, options); // If user is not found, try a case insensitive lookup\n\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      const candidateUsers = Meteor.users.find(selector, options).fetch(); // No match if multiple candidates are found\n\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\n\n\nAccounts.findUserByUsername = (username, options) => Accounts._findUserByQuery({\n  username\n}, options);\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\n\n\nAccounts.findUserByEmail = (email, options) => Accounts._findUserByQuery({\n  email\n}, options); // Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\n\n\nconst selectorForFastCaseInsensitiveLookup = (fieldName, string) => {\n  // Performance seems to improve up to 4 prefix characters\n  const prefix = string.substring(0, Math.min(string.length, 4));\n  const orClause = generateCasePermutationsForString(prefix).map(prefixPermutation => {\n    const selector = {};\n    selector[fieldName] = new RegExp(\"^\".concat(Meteor._escapeRegExp(prefixPermutation)));\n    return selector;\n  });\n  const caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] = new RegExp(\"^\".concat(Meteor._escapeRegExp(string), \"$\"), 'i');\n  return {\n    $and: [{\n      $or: orClause\n    }, caseInsensitiveClause]\n  };\n}; // Generates permutations of all case variations of a given string.\n\n\nconst generateCasePermutationsForString = string => {\n  let permutations = [''];\n\n  for (let i = 0; i < string.length; i++) {\n    const ch = string.charAt(i);\n    permutations = [].concat(...permutations.map(prefix => {\n      const lowerCaseChar = ch.toLowerCase();\n      const upperCaseChar = ch.toUpperCase(); // Don't add unneccesary permutations when ch is not a letter\n\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n\n  return permutations;\n};\n\nconst checkForCaseInsensitiveDuplicates = (fieldName, displayName, fieldValue, ownUserId) => {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  const skipCheck = Object.prototype.hasOwnProperty.call(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    const matchedUsers = Meteor.users.find(selectorForFastCaseInsensitiveLookup(fieldName, fieldValue), {\n      fields: {\n        _id: 1\n      },\n      // we only need a maximum of 2 users for the logic below to work\n      limit: 2\n    }).fetch();\n\n    if (matchedUsers.length > 0 && ( // If we don't have a userId yet, any match we find is a duplicate\n    !ownUserId || // Otherwise, check to see if there are multiple matches or a match\n    // that is not us\n    matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId)) {\n      handleError(\"\".concat(displayName, \" already exists.\"));\n    }\n  }\n}; // XXX maybe this belongs in the check package\n\n\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\nconst userQueryValidator = Match.Where(user => {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (Object.keys(user).length !== 1) throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\nconst passwordValidator = Match.OneOf(String, {\n  digest: String,\n  algorithm: String\n}); // Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\n\nAccounts.registerLoginHandler(\"password\", options => {\n  if (!options.password || options.srp) return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n  const user = Accounts._findUserByQuery(options.user, {\n    fields: _objectSpread({\n      services: 1\n    }, Accounts._checkPasswordUserFields)\n  });\n\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password || !(user.services.password.bcrypt || user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      const verifier = user.services.password.srp;\n      const newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity,\n        salt: verifier.salt\n      });\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n          error: handleError(\"Incorrect password\", false)\n        };\n      }\n\n      return {\n        userId: user._id\n      };\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(user, options.password);\n}); // Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\n\nAccounts.registerLoginHandler(\"password\", options => {\n  if (!options.srp || !options.password) {\n    return undefined; // don't handle\n  }\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  const user = Accounts._findUserByQuery(options.user, {\n    fields: _objectSpread({\n      services: 1\n    }, Accounts._checkPasswordUserFields)\n  });\n\n  if (!user) {\n    handleError(\"User not found\");\n  } // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n\n\n  if (user.services && user.services.password && user.services.password.bcrypt) {\n    return checkPassword(user, options.password);\n  }\n\n  if (!(user.services && user.services.password && user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  const v1 = user.services.password.srp.verifier;\n  const v2 = SRP.generateVerifier(null, {\n    hashedIdentityAndPassword: options.srp,\n    salt: user.services.password.srp.salt\n  }).verifier;\n\n  if (v1 !== v2) {\n    return {\n      userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n      error: handleError(\"Incorrect password\", false)\n    };\n  } // Upgrade to bcrypt on successful login.\n\n\n  const salted = hashPassword(options.password);\n  Meteor.users.update(user._id, {\n    $unset: {\n      'services.password.srp': 1\n    },\n    $set: {\n      'services.password.bcrypt': salted\n    }\n  });\n  return {\n    userId: user._id\n  };\n}); ///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\n\nAccounts.setUsername = (userId, newUsername) => {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n  const user = getUserById(userId, {\n    fields: {\n      username: 1\n    }\n  });\n\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  const oldUsername = user.username; // Perform a case insensitive check for duplicates before update\n\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $set: {\n      username: newUsername\n    }\n  }); // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $set: {\n        username: oldUsername\n      }\n    });\n    throw ex;\n  }\n}; // Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\n\n\nMeteor.methods({\n  changePassword: function (oldPassword, newPassword) {\n    check(oldPassword, passwordValidator);\n    check(newPassword, passwordValidator);\n\n    if (!this.userId) {\n      throw new Meteor.Error(401, \"Must be logged in\");\n    }\n\n    const user = getUserById(this.userId, {\n      fields: _objectSpread({\n        services: 1\n      }, Accounts._checkPasswordUserFields)\n    });\n\n    if (!user) {\n      handleError(\"User not found\");\n    }\n\n    if (!user.services || !user.services.password || !user.services.password.bcrypt && !user.services.password.srp) {\n      handleError(\"User has no password set\");\n    }\n\n    if (!user.services.password.bcrypt) {\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n\n    const result = checkPassword(user, oldPassword);\n\n    if (result.error) {\n      throw result.error;\n    }\n\n    const hashed = hashPassword(newPassword); // It would be better if this removed ALL existing tokens and replaced\n    // the token for the current connection with a new one, but that would\n    // be tricky, so we'll settle for just replacing all tokens other than\n    // the one for the current connection.\n\n    const currentToken = Accounts._getLoginToken(this.connection.id);\n\n    Meteor.users.update({\n      _id: this.userId\n    }, {\n      $set: {\n        'services.password.bcrypt': hashed\n      },\n      $pull: {\n        'services.resume.loginTokens': {\n          hashedToken: {\n            $ne: currentToken\n          }\n        }\n      },\n      $unset: {\n        'services.password.reset': 1\n      }\n    });\n    return {\n      passwordChanged: true\n    };\n  }\n}); // Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\n\nAccounts.setPassword = (userId, newPlaintextPassword, options) => {\n  options = _objectSpread({\n    logout: true\n  }, options);\n  const user = getUserById(userId, {\n    fields: {\n      _id: 1\n    }\n  });\n\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  const update = {\n    $unset: {\n      'services.password.srp': 1,\n      // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {\n      'services.password.bcrypt': hashPassword(newPlaintextPassword)\n    }\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({\n    _id: user._id\n  }, update);\n}; ///\n/// RESETTING VIA EMAIL\n///\n// Utility for plucking addresses from emails\n\n\nconst pluckAddresses = function () {\n  let emails = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return emails.map(email => email.address);\n}; // Method called by a user to request a password reset email. This is\n// the start of the reset process.\n\n\nMeteor.methods({\n  forgotPassword: options => {\n    check(options, {\n      email: String\n    });\n    const user = Accounts.findUserByEmail(options.email, {\n      fields: {\n        emails: 1\n      }\n    });\n\n    if (!user) {\n      handleError(\"User not found\");\n    }\n\n    const emails = pluckAddresses(user.emails);\n    const caseSensitiveEmail = emails.find(email => email.toLowerCase() === options.email.toLowerCase());\n    Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n  }\n});\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\n\nAccounts.generateResetToken = (userId, email, reason, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n\n  if (!user) {\n    handleError(\"Can't find user\");\n  } // pick the first email if we weren't passed an email.\n\n\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  } // make sure we have a valid email\n\n\n  if (!email || !pluckAddresses(user.emails).includes(email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $set: {\n      'services.password.reset': tokenRecord\n    }\n  }); // before passing to template, update user object with new token\n\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n  return {\n    email,\n    user,\n    token\n  };\n};\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.generateVerificationToken = (userId, email, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n\n  if (!user) {\n    handleError(\"Can't find user\");\n  } // pick the first unverified email if we weren't passed an email.\n\n\n  if (!email) {\n    const emailRecord = (user.emails || []).find(e => !e.verified);\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      handleError(\"That user has no unverified email addresses.\");\n    }\n  } // make sure we have a valid email\n\n\n  if (!email || !pluckAddresses(user.emails).includes(email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $push: {\n      'services.email.verificationTokens': tokenRecord\n    }\n  }); // before passing to template, update user object with new token\n\n  Meteor._ensure(user, 'services', 'email');\n\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n\n  user.services.email.verificationTokens.push(tokenRecord);\n  return {\n    email,\n    user,\n    token\n  };\n};\n/**\n * @summary Creates options for email sending for reset password and enroll account emails.\n * You can use this function when customizing a reset password or enroll account email sending.\n * @locus Server\n * @param {Object} email Which address of the user's to send the email to.\n * @param {Object} user The user object to generate options for.\n * @param {String} url URL to which user is directed to confirm the email.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @returns {Object} Options which can be passed to `Email.send`.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.generateOptionsForEmail = (email, user, url, reason) => {\n  const options = {\n    to: email,\n    from: Accounts.emailTemplates[reason].from ? Accounts.emailTemplates[reason].from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates[reason].subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates[reason].text === 'function') {\n    options.text = Accounts.emailTemplates[reason].text(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates[reason].html === 'function') {\n    options.html = Accounts.emailTemplates[reason].html(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  return options;\n}; // send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the reset url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.sendResetPasswordEmail = (userId, email, extraTokenData, extraParams) => {\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n\n  if (Meteor.isDevelopment) {\n    console.log(\"\\nReset password URL: \".concat(url));\n  }\n\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n}; // send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the enrollment url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.sendEnrollmentEmail = (userId, email, extraTokenData, extraParams) => {\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n\n  if (Meteor.isDevelopment) {\n    console.log(\"\\nEnrollment email URL: \".concat(url));\n  }\n\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n}; // Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\n\n\nMeteor.methods({\n  resetPassword: function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const token = args[0];\n    const newPassword = args[1];\n    return Accounts._loginMethod(this, \"resetPassword\", args, \"password\", () => {\n      check(token, String);\n      check(newPassword, passwordValidator);\n      const user = Meteor.users.findOne({\n        \"services.password.reset.token\": token\n      }, {\n        fields: {\n          services: 1,\n          emails: 1\n        }\n      });\n\n      if (!user) {\n        throw new Meteor.Error(403, \"Token expired\");\n      }\n\n      const {\n        when,\n        reason,\n        email\n      } = user.services.password.reset;\n\n      let tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n\n      if (reason === \"enroll\") {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n\n      const currentTimeMs = Date.now();\n      if (currentTimeMs - when > tokenLifetimeMs) throw new Meteor.Error(403, \"Token expired\");\n      if (!pluckAddresses(user.emails).includes(email)) return {\n        userId: user._id,\n        error: new Meteor.Error(403, \"Token has invalid email address\")\n      };\n      const hashed = hashPassword(newPassword); // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n\n      const oldToken = Accounts._getLoginToken(this.connection.id);\n\n      Accounts._setLoginToken(user._id, this.connection, null);\n\n      const resetToOldToken = () => Accounts._setLoginToken(user._id, this.connection, oldToken);\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        const affectedRecords = Meteor.users.update({\n          _id: user._id,\n          'emails.address': email,\n          'services.password.reset.token': token\n        }, {\n          $set: {\n            'services.password.bcrypt': hashed,\n            'emails.$.verified': true\n          },\n          $unset: {\n            'services.password.reset': 1,\n            'services.password.srp': 1\n          }\n        });\n        if (affectedRecords !== 1) return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Invalid email\")\n        };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      } // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n\n\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {\n        userId: user._id\n      };\n    });\n  }\n}); ///\n/// EMAIL VERIFICATION\n///\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the verification url.\n *\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\n\nAccounts.sendVerificationEmail = (userId, email, extraTokenData, extraParams) => {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n\n  if (Meteor.isDevelopment) {\n    console.log(\"\\nVerification email URL: \".concat(url));\n  }\n\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n}; // Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\n\n\nMeteor.methods({\n  verifyEmail: function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    const token = args[0];\n    return Accounts._loginMethod(this, \"verifyEmail\", args, \"password\", () => {\n      check(token, String);\n      const user = Meteor.users.findOne({\n        'services.email.verificationTokens.token': token\n      }, {\n        fields: {\n          services: 1,\n          emails: 1\n        }\n      });\n      if (!user) throw new Meteor.Error(403, \"Verify email link expired\");\n      const tokenRecord = user.services.email.verificationTokens.find(t => t.token == token);\n      if (!tokenRecord) return {\n        userId: user._id,\n        error: new Meteor.Error(403, \"Verify email link expired\")\n      };\n      const emailsRecord = user.emails.find(e => e.address == tokenRecord.address);\n      if (!emailsRecord) return {\n        userId: user._id,\n        error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n      }; // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': tokenRecord.address\n      }, {\n        $set: {\n          'emails.$.verified': true\n        },\n        $pull: {\n          'services.email.verificationTokens': {\n            address: tokenRecord.address\n          }\n        }\n      });\n      return {\n        userId: user._id\n      };\n    });\n  }\n});\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\n\nAccounts.addEmail = (userId, newEmail, verified) => {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (verified === void 0) {\n    verified = false;\n  }\n\n  const user = getUserById(userId, {\n    fields: {\n      emails: 1\n    }\n  });\n  if (!user) throw new Meteor.Error(403, \"User not found\"); // Allow users to change their own email to a version with a different case\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n\n  const caseInsensitiveRegExp = new RegExp(\"^\".concat(Meteor._escapeRegExp(newEmail), \"$\"), 'i');\n  const didUpdateOwnEmail = (user.emails || []).reduce((prev, email) => {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {\n        $set: {\n          'emails.$.address': newEmail,\n          'emails.$.verified': verified\n        }\n      });\n      return true;\n    } else {\n      return prev;\n    }\n  }, false); // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  } // Perform a case insensitive check for duplicates before update\n\n\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  }); // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $pull: {\n        emails: {\n          address: newEmail\n        }\n      }\n    });\n    throw ex;\n  }\n};\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.removeEmail = (userId, email) => {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n  const user = getUserById(userId, {\n    fields: {\n      _id: 1\n    }\n  });\n  if (!user) throw new Meteor.Error(403, \"User not found\");\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $pull: {\n      emails: {\n        address: email\n      }\n    }\n  });\n}; ///\n/// CREATING USERS\n///\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\n\n\nconst createUser = options => {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n  const {\n    username,\n    email,\n    password\n  } = options;\n  if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");\n  const user = {\n    services: {}\n  };\n\n  if (password) {\n    const hashed = hashPassword(password);\n    user.services.password = {\n      bcrypt: hashed\n    };\n  }\n\n  if (username) user.username = username;\n  if (email) user.emails = [{\n    address: email,\n    verified: false\n  }]; // Perform a case insensitive check before insert\n\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n  const userId = Accounts.insertUserDoc(options, user); // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n\n  return userId;\n}; // method for create user. Requests come from the client.\n\n\nMeteor.methods({\n  createUser: function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    const options = args[0];\n    return Accounts._loginMethod(this, \"createUser\", args, \"password\", () => {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation) return {\n        error: new Meteor.Error(403, \"Signups forbidden\")\n      };\n      const userId = Accounts.createUserVerifyingEmail(options); // client gets logged in as the new user afterwards.\n\n      return {\n        userId: userId\n      };\n    });\n  }\n}); // Create user directly on the server.\n//\n// Differently from Accounts.createUser(), this evaluates the Accounts package\n// configurations and send a verification email if the user has been registered\n// successfully.\n\nAccounts.createUserVerifyingEmail = options => {\n  options = _objectSpread({}, options); // Create user. result contains id and token.\n\n  const userId = createUser(options); // safety belt. createUser is supposed to throw on error. send 500 error\n  // instead of sending a verification email with empty userid.\n\n  if (!userId) throw new Error(\"createUser failed to insert new user\"); // If `Accounts._options.sendVerificationEmail` is set, register\n  // a token to verify the user's primary email, and send it to\n  // that address.\n\n  if (options.email && Accounts._options.sendVerificationEmail) {\n    if (options.password) {\n      Accounts.sendVerificationEmail(userId, options.email);\n    } else {\n      Accounts.sendEnrollmentEmail(userId, options.email);\n    }\n  }\n\n  return userId;\n}; // Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\n\nAccounts.createUser = (options, callback) => {\n  options = _objectSpread({}, options); // XXX allow an optional callback?\n\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n}; ///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\n\n\nMeteor.users._ensureIndex('services.email.verificationTokens.token', {\n  unique: true,\n  sparse: true\n});\n\nMeteor.users._ensureIndex('services.password.reset.token', {\n  unique: true,\n  sparse: true\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/accounts-password/email_templates.js\");\nrequire(\"/node_modules/meteor/accounts-password/password_server.js\");\n\n/* Exports */\nPackage._define(\"accounts-password\");\n\n})();\n","servePath":"/packages/accounts-password.js","sourceMap":{"version":3,"sources":["packages/accounts-password/email_templates.js","packages/accounts-password/password_server.js"],"names":["greet","welcomeMsg","user","url","greeting","profile","name","Accounts","emailTemplates","from","siteName","Meteor","absoluteUrl","replace","resetPassword","subject","text","verifyEmail","enrollAccount","_objectSpread","module","link","default","v","bcrypt","NpmModuleBcrypt","bcryptHash","wrapAsync","hash","bcryptCompare","compare","getUserById","id","options","users","findOne","_addDefaultFieldSelector","_bcryptRounds","_options","bcryptRounds","getPasswordString","password","SHA256","algorithm","Error","digest","hashPassword","getRoundsFromBcryptHash","rounds","hashSegments","split","length","parseInt","_checkPasswordUserFields","_id","services","_checkPassword","result","userId","formattedPassword","hashRounds","error","handleError","defer","update","$set","checkPassword","msg","throwError","ambiguousErrorMessages","_findUserByQuery","query","fieldName","fieldValue","username","email","selector","selectorForFastCaseInsensitiveLookup","candidateUsers","find","fetch","findUserByUsername","findUserByEmail","string","prefix","substring","Math","min","orClause","generateCasePermutationsForString","map","prefixPermutation","RegExp","_escapeRegExp","caseInsensitiveClause","$and","$or","permutations","i","ch","charAt","concat","lowerCaseChar","toLowerCase","upperCaseChar","toUpperCase","checkForCaseInsensitiveDuplicates","displayName","ownUserId","skipCheck","Object","prototype","hasOwnProperty","call","_skipCaseInsensitiveChecksForTest","matchedUsers","fields","limit","NonEmptyString","Match","Where","x","check","String","userQueryValidator","Optional","keys","passwordValidator","OneOf","registerLoginHandler","srp","undefined","verifier","newVerifier","SRP","generateVerifier","identity","salt","EJSON","stringify","format","v1","v2","hashedIdentityAndPassword","salted","$unset","setUsername","newUsername","oldUsername","ex","methods","changePassword","oldPassword","newPassword","hashed","currentToken","_getLoginToken","connection","$pull","hashedToken","$ne","passwordChanged","setPassword","newPlaintextPassword","logout","pluckAddresses","emails","address","forgotPassword","caseSensitiveEmail","sendResetPasswordEmail","generateResetToken","reason","extraTokenData","includes","token","Random","secret","tokenRecord","when","Date","assign","_ensure","reset","generateVerificationToken","emailRecord","e","verified","$push","verificationTokens","push","generateOptionsForEmail","to","html","headers","extraParams","realEmail","urls","Email","send","isDevelopment","console","log","sendEnrollmentEmail","args","_loginMethod","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","_getPasswordEnrollTokenLifetimeMs","currentTimeMs","now","oldToken","_setLoginToken","resetToOldToken","affectedRecords","err","_clearAllLoginTokens","sendVerificationEmail","t","emailsRecord","addEmail","newEmail","Boolean","caseInsensitiveRegExp","didUpdateOwnEmail","reduce","prev","test","$addToSet","removeEmail","createUser","ObjectIncluding","insertUserDoc","remove","forbidClientAccountCreation","createUserVerifyingEmail","callback","_ensureIndex","unique","sparse"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAMA,KAAK,GAAGC,UAAU,IAAI,CAACC,IAAD,EAAOC,GAAP,KAAe;AACrC,QAAMC,QAAQ,GAAIF,IAAI,CAACG,OAAL,IAAgBH,IAAI,CAACG,OAAL,CAAaC,IAA9B,mBACDJ,IAAI,CAACG,OAAL,CAAaC,IADZ,SACuB,QADxC;AAEA,mBAAUF,QAAV,iBAEJH,UAFI,+CAIJE,GAJI;AAQL,CAXD;AAaA;AACA;AACA;AACA;AACA;;;AACAI,QAAQ,CAACC,cAAT,GAA0B;AACxBC,MAAI,EAAE,yCADkB;AAExBC,UAAQ,EAAEC,MAAM,CAACC,WAAP,GAAqBC,OAArB,CAA6B,cAA7B,EAA6C,EAA7C,EAAiDA,OAAjD,CAAyD,KAAzD,EAAgE,EAAhE,CAFc;AAIxBC,eAAa,EAAE;AACbC,WAAO,EAAE,8CAAuCR,QAAQ,CAACC,cAAT,CAAwBE,QAA/D,CADI;AAEbM,QAAI,EAAEhB,KAAK,CAAC,wBAAD;AAFE,GAJS;AAQxBiB,aAAW,EAAE;AACXF,WAAO,EAAE,+CAAwCR,QAAQ,CAACC,cAAT,CAAwBE,QAAhE,CADE;AAEXM,QAAI,EAAEhB,KAAK,CAAC,8BAAD;AAFA,GARW;AAYxBkB,eAAa,EAAE;AACbH,WAAO,EAAE,uDAAgDR,QAAQ,CAACC,cAAT,CAAwBE,QAAxE,CADI;AAEbM,QAAI,EAAEhB,KAAK,CAAC,4BAAD;AAFE;AAZS,CAA1B,C;;;;;;;;;;;AClBA,IAAImB,aAAJ;;AAAkBC,MAAM,CAACC,IAAP,CAAY,sCAAZ,EAAmD;AAACC,SAAO,CAACC,CAAD,EAAG;AAACJ,iBAAa,GAACI,CAAd;AAAgB;;AAA5B,CAAnD,EAAiF,CAAjF;AAAlB;AAEA,MAAMC,MAAM,GAAGC,eAAf;AACA,MAAMC,UAAU,GAAGf,MAAM,CAACgB,SAAP,CAAiBH,MAAM,CAACI,IAAxB,CAAnB;AACA,MAAMC,aAAa,GAAGlB,MAAM,CAACgB,SAAP,CAAiBH,MAAM,CAACM,OAAxB,CAAtB,C,CAEA;;AACA,MAAMC,WAAW,GAAG,CAACC,EAAD,EAAKC,OAAL,KAAiBtB,MAAM,CAACuB,KAAP,CAAaC,OAAb,CAAqBH,EAArB,EAAyBzB,QAAQ,CAAC6B,wBAAT,CAAkCH,OAAlC,CAAzB,CAArC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA1B,QAAQ,CAAC8B,aAAT,GAAyB,MAAM9B,QAAQ,CAAC+B,QAAT,CAAkBC,YAAlB,IAAkC,EAAjE,C,CAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,iBAAiB,GAAGC,QAAQ,IAAI;AACpC,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChCA,YAAQ,GAAGC,MAAM,CAACD,QAAD,CAAjB;AACD,GAFD,MAEO;AAAE;AACP,QAAIA,QAAQ,CAACE,SAAT,KAAuB,SAA3B,EAAsC;AACpC,YAAM,IAAIC,KAAJ,CAAU,sCACA,4BADV,CAAN;AAED;;AACDH,YAAQ,GAAGA,QAAQ,CAACI,MAApB;AACD;;AACD,SAAOJ,QAAP;AACD,CAXD,C,CAaA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,YAAY,GAAGL,QAAQ,IAAI;AAC/BA,UAAQ,GAAGD,iBAAiB,CAACC,QAAD,CAA5B;AACA,SAAOf,UAAU,CAACe,QAAD,EAAWlC,QAAQ,CAAC8B,aAAT,EAAX,CAAjB;AACD,CAHD,C,CAKA;;;AACA,MAAMU,uBAAuB,GAAGnB,IAAI,IAAI;AACtC,MAAIoB,MAAJ;;AACA,MAAIpB,IAAJ,EAAU;AACR,UAAMqB,YAAY,GAAGrB,IAAI,CAACsB,KAAL,CAAW,GAAX,CAArB;;AACA,QAAID,YAAY,CAACE,MAAb,GAAsB,CAA1B,EAA6B;AAC3BH,YAAM,GAAGI,QAAQ,CAACH,YAAY,CAAC,CAAD,CAAb,EAAkB,EAAlB,CAAjB;AACD;AACF;;AACD,SAAOD,MAAP;AACD,CATD,C,CAWA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAzC,QAAQ,CAAC8C,wBAAT,GAAoC;AAACC,KAAG,EAAE,CAAN;AAASC,UAAQ,EAAE;AAAnB,CAApC,C,CACA;;AACAhD,QAAQ,CAACiD,cAAT,GAA0B,CAACtD,IAAD,EAAOuC,QAAP,KAAoB;AAC5C,QAAMgB,MAAM,GAAG;AACbC,UAAM,EAAExD,IAAI,CAACoD;AADA,GAAf;AAIA,QAAMK,iBAAiB,GAAGnB,iBAAiB,CAACC,QAAD,CAA3C;AACA,QAAMb,IAAI,GAAG1B,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuBjB,MAApC;AACA,QAAMoC,UAAU,GAAGb,uBAAuB,CAACnB,IAAD,CAA1C;;AAEA,MAAI,CAAEC,aAAa,CAAC8B,iBAAD,EAAoB/B,IAApB,CAAnB,EAA8C;AAC5C6B,UAAM,CAACI,KAAP,GAAeC,WAAW,CAAC,oBAAD,EAAuB,KAAvB,CAA1B;AACD,GAFD,MAEO,IAAIlC,IAAI,IAAIrB,QAAQ,CAAC8B,aAAT,MAA4BuB,UAAxC,EAAoD;AACzD;AACAjD,UAAM,CAACoD,KAAP,CAAa,MAAM;AACjBpD,YAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAAEV,WAAG,EAAEpD,IAAI,CAACoD;AAAZ,OAApB,EAAuC;AACrCW,YAAI,EAAE;AACJ,sCACEvC,UAAU,CAACiC,iBAAD,EAAoBpD,QAAQ,CAAC8B,aAAT,EAApB;AAFR;AAD+B,OAAvC;AAMD,KAPD;AAQD;;AAED,SAAOoB,MAAP;AACD,CAxBD;;AAyBA,MAAMS,aAAa,GAAG3D,QAAQ,CAACiD,cAA/B,C,CAEA;AACA;AACA;;AACA,MAAMM,WAAW,GAAG,UAACK,GAAD,EAA4B;AAAA,MAAtBC,UAAsB,uEAAT,IAAS;AAC9C,QAAMP,KAAK,GAAG,IAAIlD,MAAM,CAACiC,KAAX,CACZ,GADY,EAEZrC,QAAQ,CAAC+B,QAAT,CAAkB+B,sBAAlB,GACI,sDADJ,GAEIF,GAJQ,CAAd;;AAMA,MAAIC,UAAJ,EAAgB;AACd,UAAMP,KAAN;AACD;;AACD,SAAOA,KAAP;AACD,CAXD,C,CAaA;AACA;AACA;;;AAEAtD,QAAQ,CAAC+D,gBAAT,GAA4B,CAACC,KAAD,EAAQtC,OAAR,KAAoB;AAC9C,MAAI/B,IAAI,GAAG,IAAX;;AAEA,MAAIqE,KAAK,CAACvC,EAAV,EAAc;AACZ;AACA9B,QAAI,GAAG6B,WAAW,CAACwC,KAAK,CAACvC,EAAP,EAAWC,OAAX,CAAlB;AACD,GAHD,MAGO;AACLA,WAAO,GAAG1B,QAAQ,CAAC6B,wBAAT,CAAkCH,OAAlC,CAAV;AACA,QAAIuC,SAAJ;AACA,QAAIC,UAAJ;;AACA,QAAIF,KAAK,CAACG,QAAV,EAAoB;AAClBF,eAAS,GAAG,UAAZ;AACAC,gBAAU,GAAGF,KAAK,CAACG,QAAnB;AACD,KAHD,MAGO,IAAIH,KAAK,CAACI,KAAV,EAAiB;AACtBH,eAAS,GAAG,gBAAZ;AACAC,gBAAU,GAAGF,KAAK,CAACI,KAAnB;AACD,KAHM,MAGA;AACL,YAAM,IAAI/B,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,QAAIgC,QAAQ,GAAG,EAAf;AACAA,YAAQ,CAACJ,SAAD,CAAR,GAAsBC,UAAtB;AACAvE,QAAI,GAAGS,MAAM,CAACuB,KAAP,CAAaC,OAAb,CAAqByC,QAArB,EAA+B3C,OAA/B,CAAP,CAfK,CAgBL;;AACA,QAAI,CAAC/B,IAAL,EAAW;AACT0E,cAAQ,GAAGC,oCAAoC,CAACL,SAAD,EAAYC,UAAZ,CAA/C;AACA,YAAMK,cAAc,GAAGnE,MAAM,CAACuB,KAAP,CAAa6C,IAAb,CAAkBH,QAAlB,EAA4B3C,OAA5B,EAAqC+C,KAArC,EAAvB,CAFS,CAGT;;AACA,UAAIF,cAAc,CAAC3B,MAAf,KAA0B,CAA9B,EAAiC;AAC/BjD,YAAI,GAAG4E,cAAc,CAAC,CAAD,CAArB;AACD;AACF;AACF;;AAED,SAAO5E,IAAP;AACD,CAlCD;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAK,QAAQ,CAAC0E,kBAAT,GACE,CAACP,QAAD,EAAWzC,OAAX,KAAuB1B,QAAQ,CAAC+D,gBAAT,CAA0B;AAAEI;AAAF,CAA1B,EAAwCzC,OAAxC,CADzB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1B,QAAQ,CAAC2E,eAAT,GACE,CAACP,KAAD,EAAQ1C,OAAR,KAAoB1B,QAAQ,CAAC+D,gBAAT,CAA0B;AAAEK;AAAF,CAA1B,EAAqC1C,OAArC,CADtB,C,CAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM4C,oCAAoC,GAAG,CAACL,SAAD,EAAYW,MAAZ,KAAuB;AAClE;AACA,QAAMC,MAAM,GAAGD,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBC,IAAI,CAACC,GAAL,CAASJ,MAAM,CAAChC,MAAhB,EAAwB,CAAxB,CAApB,CAAf;AACA,QAAMqC,QAAQ,GAAGC,iCAAiC,CAACL,MAAD,CAAjC,CAA0CM,GAA1C,CACfC,iBAAiB,IAAI;AACnB,UAAMf,QAAQ,GAAG,EAAjB;AACAA,YAAQ,CAACJ,SAAD,CAAR,GACE,IAAIoB,MAAJ,YAAejF,MAAM,CAACkF,aAAP,CAAqBF,iBAArB,CAAf,EADF;AAEA,WAAOf,QAAP;AACD,GANc,CAAjB;AAOA,QAAMkB,qBAAqB,GAAG,EAA9B;AACAA,uBAAqB,CAACtB,SAAD,CAArB,GACE,IAAIoB,MAAJ,YAAejF,MAAM,CAACkF,aAAP,CAAqBV,MAArB,CAAf,QAAgD,GAAhD,CADF;AAEA,SAAO;AAACY,QAAI,EAAE,CAAC;AAACC,SAAG,EAAER;AAAN,KAAD,EAAkBM,qBAAlB;AAAP,GAAP;AACD,CAdD,C,CAgBA;;;AACA,MAAML,iCAAiC,GAAGN,MAAM,IAAI;AAClD,MAAIc,YAAY,GAAG,CAAC,EAAD,CAAnB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,MAAM,CAAChC,MAA3B,EAAmC+C,CAAC,EAApC,EAAwC;AACtC,UAAMC,EAAE,GAAGhB,MAAM,CAACiB,MAAP,CAAcF,CAAd,CAAX;AACAD,gBAAY,GAAG,GAAGI,MAAH,CAAU,GAAIJ,YAAY,CAACP,GAAb,CAAiBN,MAAM,IAAI;AACtD,YAAMkB,aAAa,GAAGH,EAAE,CAACI,WAAH,EAAtB;AACA,YAAMC,aAAa,GAAGL,EAAE,CAACM,WAAH,EAAtB,CAFsD,CAGtD;;AACA,UAAIH,aAAa,KAAKE,aAAtB,EAAqC;AACnC,eAAO,CAACpB,MAAM,GAAGe,EAAV,CAAP;AACD,OAFD,MAEO;AACL,eAAO,CAACf,MAAM,GAAGkB,aAAV,EAAyBlB,MAAM,GAAGoB,aAAlC,CAAP;AACD;AACF,KAT4B,CAAd,CAAf;AAUD;;AACD,SAAOP,YAAP;AACD,CAhBD;;AAkBA,MAAMS,iCAAiC,GAAG,CAAClC,SAAD,EAAYmC,WAAZ,EAAyBlC,UAAzB,EAAqCmC,SAArC,KAAmD;AAC3F;AACA;AACA,QAAMC,SAAS,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC1G,QAAQ,CAAC2G,iCAA9C,EAAiFzC,UAAjF,CAAlB;;AAEA,MAAIA,UAAU,IAAI,CAACoC,SAAnB,EAA8B;AAC5B,UAAMM,YAAY,GAAGxG,MAAM,CAACuB,KAAP,CAAa6C,IAAb,CACnBF,oCAAoC,CAACL,SAAD,EAAYC,UAAZ,CADjB,EAEnB;AACE2C,YAAM,EAAE;AAAC9D,WAAG,EAAE;AAAN,OADV;AAEE;AACA+D,WAAK,EAAE;AAHT,KAFmB,EAOnBrC,KAPmB,EAArB;;AASA,QAAImC,YAAY,CAAChE,MAAb,GAAsB,CAAtB,MACA;AACC,KAACyD,SAAD,IACD;AACA;AACCO,gBAAY,CAAChE,MAAb,GAAsB,CAAtB,IAA2BgE,YAAY,CAAC,CAAD,CAAZ,CAAgB7D,GAAhB,KAAwBsD,SALpD,CAAJ,EAKqE;AACnE9C,iBAAW,WAAI6C,WAAJ,sBAAX;AACD;AACF;AACF,CAxBD,C,CA0BA;;;AACA,MAAMW,cAAc,GAAGC,KAAK,CAACC,KAAN,CAAYC,CAAC,IAAI;AACtCC,OAAK,CAACD,CAAD,EAAIE,MAAJ,CAAL;AACA,SAAOF,CAAC,CAACtE,MAAF,GAAW,CAAlB;AACD,CAHsB,CAAvB;AAKA,MAAMyE,kBAAkB,GAAGL,KAAK,CAACC,KAAN,CAAYtH,IAAI,IAAI;AAC7CwH,OAAK,CAACxH,IAAD,EAAO;AACV8B,MAAE,EAAEuF,KAAK,CAACM,QAAN,CAAeP,cAAf,CADM;AAEV5C,YAAQ,EAAE6C,KAAK,CAACM,QAAN,CAAeP,cAAf,CAFA;AAGV3C,SAAK,EAAE4C,KAAK,CAACM,QAAN,CAAeP,cAAf;AAHG,GAAP,CAAL;AAKA,MAAIR,MAAM,CAACgB,IAAP,CAAY5H,IAAZ,EAAkBiD,MAAlB,KAA6B,CAAjC,EACE,MAAM,IAAIoE,KAAK,CAAC3E,KAAV,CAAgB,2CAAhB,CAAN;AACF,SAAO,IAAP;AACD,CAT0B,CAA3B;AAWA,MAAMmF,iBAAiB,GAAGR,KAAK,CAACS,KAAN,CACxBL,MADwB,EAExB;AAAE9E,QAAM,EAAE8E,MAAV;AAAkBhF,WAAS,EAAEgF;AAA7B,CAFwB,CAA1B,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACApH,QAAQ,CAAC0H,oBAAT,CAA8B,UAA9B,EAA0ChG,OAAO,IAAI;AACnD,MAAI,CAAEA,OAAO,CAACQ,QAAV,IAAsBR,OAAO,CAACiG,GAAlC,EACE,OAAOC,SAAP,CAFiD,CAE/B;;AAEpBT,OAAK,CAACzF,OAAD,EAAU;AACb/B,QAAI,EAAE0H,kBADO;AAEbnF,YAAQ,EAAEsF;AAFG,GAAV,CAAL;;AAMA,QAAM7H,IAAI,GAAGK,QAAQ,CAAC+D,gBAAT,CAA0BrC,OAAO,CAAC/B,IAAlC,EAAwC;AAACkH,UAAM;AAC1D7D,cAAQ,EAAE;AADgD,OAEvDhD,QAAQ,CAAC8C,wBAF8C;AAAP,GAAxC,CAAb;;AAIA,MAAI,CAACnD,IAAL,EAAW;AACT4D,eAAW,CAAC,gBAAD,CAAX;AACD;;AAED,MAAI,CAAC5D,IAAI,CAACqD,QAAN,IAAkB,CAACrD,IAAI,CAACqD,QAAL,CAAcd,QAAjC,IACA,EAAEvC,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuBjB,MAAvB,IAAiCtB,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAA1D,CADJ,EACoE;AAClEpE,eAAW,CAAC,0BAAD,CAAX;AACD;;AAED,MAAI,CAAC5D,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuBjB,MAA5B,EAAoC;AAClC,QAAI,OAAOS,OAAO,CAACQ,QAAf,KAA4B,QAAhC,EAA0C;AACxC;AACA;AACA;AACA;AACA,YAAM2F,QAAQ,GAAGlI,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAAxC;AACA,YAAMG,WAAW,GAAGC,GAAG,CAACC,gBAAJ,CAAqBtG,OAAO,CAACQ,QAA7B,EAAuC;AACzD+F,gBAAQ,EAAEJ,QAAQ,CAACI,QADsC;AAC5BC,YAAI,EAAEL,QAAQ,CAACK;AADa,OAAvC,CAApB;;AAGA,UAAIL,QAAQ,CAACA,QAAT,KAAsBC,WAAW,CAACD,QAAtC,EAAgD;AAC9C,eAAO;AACL1E,gBAAM,EAAEnD,QAAQ,CAAC+B,QAAT,CAAkB+B,sBAAlB,GAA2C,IAA3C,GAAkDnE,IAAI,CAACoD,GAD1D;AAELO,eAAK,EAAEC,WAAW,CAAC,oBAAD,EAAuB,KAAvB;AAFb,SAAP;AAID;;AAED,aAAO;AAACJ,cAAM,EAAExD,IAAI,CAACoD;AAAd,OAAP;AACD,KAjBD,MAiBO;AACL;AACA,YAAM,IAAI3C,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,qBAAtB,EAA6C8F,KAAK,CAACC,SAAN,CAAgB;AACjEC,cAAM,EAAE,KADyD;AAEjEJ,gBAAQ,EAAEtI,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAAvB,CAA2BM;AAF4B,OAAhB,CAA7C,CAAN;AAID;AACF;;AAED,SAAOtE,aAAa,CAClBhE,IADkB,EAElB+B,OAAO,CAACQ,QAFU,CAApB;AAID,CAtDD,E,CAwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAlC,QAAQ,CAAC0H,oBAAT,CAA8B,UAA9B,EAA0ChG,OAAO,IAAI;AACnD,MAAI,CAACA,OAAO,CAACiG,GAAT,IAAgB,CAACjG,OAAO,CAACQ,QAA7B,EAAuC;AACrC,WAAO0F,SAAP,CADqC,CACnB;AACnB;;AAEDT,OAAK,CAACzF,OAAD,EAAU;AACb/B,QAAI,EAAE0H,kBADO;AAEbM,OAAG,EAAEP,MAFQ;AAGblF,YAAQ,EAAEsF;AAHG,GAAV,CAAL;;AAMA,QAAM7H,IAAI,GAAGK,QAAQ,CAAC+D,gBAAT,CAA0BrC,OAAO,CAAC/B,IAAlC,EAAwC;AAACkH,UAAM;AAC1D7D,cAAQ,EAAE;AADgD,OAEvDhD,QAAQ,CAAC8C,wBAF8C;AAAP,GAAxC,CAAb;;AAIA,MAAI,CAACnD,IAAL,EAAW;AACT4D,eAAW,CAAC,gBAAD,CAAX;AACD,GAjBkD,CAmBnD;AACA;;;AACA,MAAI5D,IAAI,CAACqD,QAAL,IAAiBrD,IAAI,CAACqD,QAAL,CAAcd,QAA/B,IAA2CvC,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuBjB,MAAtE,EAA8E;AAC5E,WAAO0C,aAAa,CAAChE,IAAD,EAAO+B,OAAO,CAACQ,QAAf,CAApB;AACD;;AAED,MAAI,EAAEvC,IAAI,CAACqD,QAAL,IAAiBrD,IAAI,CAACqD,QAAL,CAAcd,QAA/B,IAA2CvC,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAApE,CAAJ,EAA8E;AAC5EpE,eAAW,CAAC,0BAAD,CAAX;AACD;;AAED,QAAM+E,EAAE,GAAG3I,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAAvB,CAA2BE,QAAtC;AACA,QAAMU,EAAE,GAAGR,GAAG,CAACC,gBAAJ,CACT,IADS,EAET;AACEQ,6BAAyB,EAAE9G,OAAO,CAACiG,GADrC;AAEEO,QAAI,EAAEvI,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAAvB,CAA2BO;AAFnC,GAFS,EAMTL,QANF;;AAOA,MAAIS,EAAE,KAAKC,EAAX,EAAe;AACb,WAAO;AACLpF,YAAM,EAAEnD,QAAQ,CAAC+B,QAAT,CAAkB+B,sBAAlB,GAA2C,IAA3C,GAAkDnE,IAAI,CAACoD,GAD1D;AAELO,WAAK,EAAEC,WAAW,CAAC,oBAAD,EAAuB,KAAvB;AAFb,KAAP;AAID,GA1CkD,CA4CnD;;;AACA,QAAMkF,MAAM,GAAGlG,YAAY,CAACb,OAAO,CAACQ,QAAT,CAA3B;AACA9B,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CACE9D,IAAI,CAACoD,GADP,EAEE;AACE2F,UAAM,EAAE;AAAE,+BAAyB;AAA3B,KADV;AAEEhF,QAAI,EAAE;AAAE,kCAA4B+E;AAA9B;AAFR,GAFF;AAQA,SAAO;AAACtF,UAAM,EAAExD,IAAI,CAACoD;AAAd,GAAP;AACD,CAvDD,E,CA0DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA/C,QAAQ,CAAC2I,WAAT,GAAuB,CAACxF,MAAD,EAASyF,WAAT,KAAyB;AAC9CzB,OAAK,CAAChE,MAAD,EAAS4D,cAAT,CAAL;AACAI,OAAK,CAACyB,WAAD,EAAc7B,cAAd,CAAL;AAEA,QAAMpH,IAAI,GAAG6B,WAAW,CAAC2B,MAAD,EAAS;AAAC0D,UAAM,EAAE;AACxC1C,cAAQ,EAAE;AAD8B;AAAT,GAAT,CAAxB;;AAGA,MAAI,CAACxE,IAAL,EAAW;AACT4D,eAAW,CAAC,gBAAD,CAAX;AACD;;AAED,QAAMsF,WAAW,GAAGlJ,IAAI,CAACwE,QAAzB,CAX8C,CAa9C;;AACAgC,mCAAiC,CAAC,UAAD,EAAa,UAAb,EAAyByC,WAAzB,EAAsCjJ,IAAI,CAACoD,GAA3C,CAAjC;AAEA3C,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,OAAG,EAAEpD,IAAI,CAACoD;AAAX,GAApB,EAAqC;AAACW,QAAI,EAAE;AAACS,cAAQ,EAAEyE;AAAX;AAAP,GAArC,EAhB8C,CAkB9C;AACA;;AACA,MAAI;AACFzC,qCAAiC,CAAC,UAAD,EAAa,UAAb,EAAyByC,WAAzB,EAAsCjJ,IAAI,CAACoD,GAA3C,CAAjC;AACD,GAFD,CAEE,OAAO+F,EAAP,EAAW;AACX;AACA1I,UAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,SAAG,EAAEpD,IAAI,CAACoD;AAAX,KAApB,EAAqC;AAACW,UAAI,EAAE;AAACS,gBAAQ,EAAE0E;AAAX;AAAP,KAArC;AACA,UAAMC,EAAN;AACD;AACF,CA3BD,C,CA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1I,MAAM,CAAC2I,OAAP,CAAe;AAACC,gBAAc,EAAE,UAAUC,WAAV,EAAuBC,WAAvB,EAAoC;AAClE/B,SAAK,CAAC8B,WAAD,EAAczB,iBAAd,CAAL;AACAL,SAAK,CAAC+B,WAAD,EAAc1B,iBAAd,CAAL;;AAEA,QAAI,CAAC,KAAKrE,MAAV,EAAkB;AAChB,YAAM,IAAI/C,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,mBAAtB,CAAN;AACD;;AAED,UAAM1C,IAAI,GAAG6B,WAAW,CAAC,KAAK2B,MAAN,EAAc;AAAC0D,YAAM;AAC3C7D,gBAAQ,EAAE;AADiC,SAExChD,QAAQ,CAAC8C,wBAF+B;AAAP,KAAd,CAAxB;;AAIA,QAAI,CAACnD,IAAL,EAAW;AACT4D,iBAAW,CAAC,gBAAD,CAAX;AACD;;AAED,QAAI,CAAC5D,IAAI,CAACqD,QAAN,IAAkB,CAACrD,IAAI,CAACqD,QAAL,CAAcd,QAAjC,IACC,CAACvC,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuBjB,MAAxB,IAAkC,CAACtB,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAD/D,EACqE;AACnEpE,iBAAW,CAAC,0BAAD,CAAX;AACD;;AAED,QAAI,CAAE5D,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuBjB,MAA7B,EAAqC;AACnC,YAAM,IAAIb,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,qBAAtB,EAA6C8F,KAAK,CAACC,SAAN,CAAgB;AACjEC,cAAM,EAAE,KADyD;AAEjEJ,gBAAQ,EAAEtI,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuByF,GAAvB,CAA2BM;AAF4B,OAAhB,CAA7C,CAAN;AAID;;AAED,UAAM/E,MAAM,GAAGS,aAAa,CAAChE,IAAD,EAAOsJ,WAAP,CAA5B;;AACA,QAAI/F,MAAM,CAACI,KAAX,EAAkB;AAChB,YAAMJ,MAAM,CAACI,KAAb;AACD;;AAED,UAAM6F,MAAM,GAAG5G,YAAY,CAAC2G,WAAD,CAA3B,CAjCkE,CAmClE;AACA;AACA;AACA;;AACA,UAAME,YAAY,GAAGpJ,QAAQ,CAACqJ,cAAT,CAAwB,KAAKC,UAAL,CAAgB7H,EAAxC,CAArB;;AACArB,UAAM,CAACuB,KAAP,CAAa8B,MAAb,CACE;AAAEV,SAAG,EAAE,KAAKI;AAAZ,KADF,EAEE;AACEO,UAAI,EAAE;AAAE,oCAA4ByF;AAA9B,OADR;AAEEI,WAAK,EAAE;AACL,uCAA+B;AAAEC,qBAAW,EAAE;AAAEC,eAAG,EAAEL;AAAP;AAAf;AAD1B,OAFT;AAKEV,YAAM,EAAE;AAAE,mCAA2B;AAA7B;AALV,KAFF;AAWA,WAAO;AAACgB,qBAAe,EAAE;AAAlB,KAAP;AACD;AApDc,CAAf,E,CAuDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA1J,QAAQ,CAAC2J,WAAT,GAAuB,CAACxG,MAAD,EAASyG,oBAAT,EAA+BlI,OAA/B,KAA2C;AAChEA,SAAO;AAAKmI,UAAM,EAAE;AAAb,KAAuBnI,OAAvB,CAAP;AAEA,QAAM/B,IAAI,GAAG6B,WAAW,CAAC2B,MAAD,EAAS;AAAC0D,UAAM,EAAE;AAAC9D,SAAG,EAAE;AAAN;AAAT,GAAT,CAAxB;;AACA,MAAI,CAACpD,IAAL,EAAW;AACT,UAAM,IAAIS,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,gBAAtB,CAAN;AACD;;AAED,QAAMoB,MAAM,GAAG;AACbiF,UAAM,EAAE;AACN,+BAAyB,CADnB;AACsB;AAC5B,iCAA2B;AAFrB,KADK;AAKbhF,QAAI,EAAE;AAAC,kCAA4BnB,YAAY,CAACqH,oBAAD;AAAzC;AALO,GAAf;;AAQA,MAAIlI,OAAO,CAACmI,MAAZ,EAAoB;AAClBpG,UAAM,CAACiF,MAAP,CAAc,6BAAd,IAA+C,CAA/C;AACD;;AAEDtI,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,OAAG,EAAEpD,IAAI,CAACoD;AAAX,GAApB,EAAqCU,MAArC;AACD,CArBD,C,CAwBA;AACA;AACA;AAEA;;;AACA,MAAMqG,cAAc,GAAG;AAAA,MAACC,MAAD,uEAAU,EAAV;AAAA,SAAiBA,MAAM,CAAC5E,GAAP,CAAWf,KAAK,IAAIA,KAAK,CAAC4F,OAA1B,CAAjB;AAAA,CAAvB,C,CAEA;AACA;;;AACA5J,MAAM,CAAC2I,OAAP,CAAe;AAACkB,gBAAc,EAAEvI,OAAO,IAAI;AACzCyF,SAAK,CAACzF,OAAD,EAAU;AAAC0C,WAAK,EAAEgD;AAAR,KAAV,CAAL;AAEA,UAAMzH,IAAI,GAAGK,QAAQ,CAAC2E,eAAT,CAAyBjD,OAAO,CAAC0C,KAAjC,EAAwC;AAACyC,YAAM,EAAE;AAACkD,cAAM,EAAE;AAAT;AAAT,KAAxC,CAAb;;AACA,QAAI,CAACpK,IAAL,EAAW;AACT4D,iBAAW,CAAC,gBAAD,CAAX;AACD;;AAED,UAAMwG,MAAM,GAAGD,cAAc,CAACnK,IAAI,CAACoK,MAAN,CAA7B;AACA,UAAMG,kBAAkB,GAAGH,MAAM,CAACvF,IAAP,CACzBJ,KAAK,IAAIA,KAAK,CAAC4B,WAAN,OAAwBtE,OAAO,CAAC0C,KAAR,CAAc4B,WAAd,EADR,CAA3B;AAIAhG,YAAQ,CAACmK,sBAAT,CAAgCxK,IAAI,CAACoD,GAArC,EAA0CmH,kBAA1C;AACD;AAdc,CAAf;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAlK,QAAQ,CAACoK,kBAAT,GAA8B,CAACjH,MAAD,EAASiB,KAAT,EAAgBiG,MAAhB,EAAwBC,cAAxB,KAA2C;AACvE;AACA;AACA;AACA,QAAM3K,IAAI,GAAG6B,WAAW,CAAC2B,MAAD,CAAxB;;AACA,MAAI,CAACxD,IAAL,EAAW;AACT4D,eAAW,CAAC,iBAAD,CAAX;AACD,GAPsE,CASvE;;;AACA,MAAI,CAACa,KAAD,IAAUzE,IAAI,CAACoK,MAAf,IAAyBpK,IAAI,CAACoK,MAAL,CAAY,CAAZ,CAA7B,EAA6C;AAC3C3F,SAAK,GAAGzE,IAAI,CAACoK,MAAL,CAAY,CAAZ,EAAeC,OAAvB;AACD,GAZsE,CAcvE;;;AACA,MAAI,CAAC5F,KAAD,IACF,CAAE0F,cAAc,CAACnK,IAAI,CAACoK,MAAN,CAAd,CAA4BQ,QAA5B,CAAqCnG,KAArC,CADJ,EACkD;AAChDb,eAAW,CAAC,yBAAD,CAAX;AACD;;AAED,QAAMiH,KAAK,GAAGC,MAAM,CAACC,MAAP,EAAd;AACA,QAAMC,WAAW,GAAG;AAClBH,SADkB;AAElBpG,SAFkB;AAGlBwG,QAAI,EAAE,IAAIC,IAAJ;AAHY,GAApB;;AAMA,MAAIR,MAAM,KAAK,eAAf,EAAgC;AAC9BM,eAAW,CAACN,MAAZ,GAAqB,OAArB;AACD,GAFD,MAEO,IAAIA,MAAM,KAAK,eAAf,EAAgC;AACrCM,eAAW,CAACN,MAAZ,GAAqB,QAArB;AACD,GAFM,MAEA,IAAIA,MAAJ,EAAY;AACjB;AACAM,eAAW,CAACN,MAAZ,GAAqBA,MAArB;AACD;;AAED,MAAIC,cAAJ,EAAoB;AAClB/D,UAAM,CAACuE,MAAP,CAAcH,WAAd,EAA2BL,cAA3B;AACD;;AAEDlK,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,OAAG,EAAEpD,IAAI,CAACoD;AAAX,GAApB,EAAqC;AAACW,QAAI,EAAE;AAC1C,iCAA2BiH;AADe;AAAP,GAArC,EAxCuE,CA4CvE;;AACAvK,QAAM,CAAC2K,OAAP,CAAepL,IAAf,EAAqB,UAArB,EAAiC,UAAjC,EAA6CqL,KAA7C,GAAqDL,WAArD;AAEA,SAAO;AAACvG,SAAD;AAAQzE,QAAR;AAAc6K;AAAd,GAAP;AACD,CAhDD;AAkDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxK,QAAQ,CAACiL,yBAAT,GAAqC,CAAC9H,MAAD,EAASiB,KAAT,EAAgBkG,cAAhB,KAAmC;AACtE;AACA;AACA;AACA,QAAM3K,IAAI,GAAG6B,WAAW,CAAC2B,MAAD,CAAxB;;AACA,MAAI,CAACxD,IAAL,EAAW;AACT4D,eAAW,CAAC,iBAAD,CAAX;AACD,GAPqE,CAStE;;;AACA,MAAI,CAACa,KAAL,EAAY;AACV,UAAM8G,WAAW,GAAG,CAACvL,IAAI,CAACoK,MAAL,IAAe,EAAhB,EAAoBvF,IAApB,CAAyB2G,CAAC,IAAI,CAACA,CAAC,CAACC,QAAjC,CAApB;AACAhH,SAAK,GAAG,CAAC8G,WAAW,IAAI,EAAhB,EAAoBlB,OAA5B;;AAEA,QAAI,CAAC5F,KAAL,EAAY;AACVb,iBAAW,CAAC,8CAAD,CAAX;AACD;AACF,GAjBqE,CAmBtE;;;AACA,MAAI,CAACa,KAAD,IACF,CAAE0F,cAAc,CAACnK,IAAI,CAACoK,MAAN,CAAd,CAA4BQ,QAA5B,CAAqCnG,KAArC,CADJ,EACkD;AAChDb,eAAW,CAAC,yBAAD,CAAX;AACD;;AAED,QAAMiH,KAAK,GAAGC,MAAM,CAACC,MAAP,EAAd;AACA,QAAMC,WAAW,GAAG;AAClBH,SADkB;AAElB;AACAR,WAAO,EAAE5F,KAHS;AAIlBwG,QAAI,EAAE,IAAIC,IAAJ;AAJY,GAApB;;AAOA,MAAIP,cAAJ,EAAoB;AAClB/D,UAAM,CAACuE,MAAP,CAAcH,WAAd,EAA2BL,cAA3B;AACD;;AAEDlK,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,OAAG,EAAEpD,IAAI,CAACoD;AAAX,GAApB,EAAqC;AAACsI,SAAK,EAAE;AAC3C,2CAAqCV;AADM;AAAR,GAArC,EArCsE,CAyCtE;;AACAvK,QAAM,CAAC2K,OAAP,CAAepL,IAAf,EAAqB,UAArB,EAAiC,OAAjC;;AACA,MAAI,CAACA,IAAI,CAACqD,QAAL,CAAcoB,KAAd,CAAoBkH,kBAAzB,EAA6C;AAC3C3L,QAAI,CAACqD,QAAL,CAAcoB,KAAd,CAAoBkH,kBAApB,GAAyC,EAAzC;AACD;;AACD3L,MAAI,CAACqD,QAAL,CAAcoB,KAAd,CAAoBkH,kBAApB,CAAuCC,IAAvC,CAA4CZ,WAA5C;AAEA,SAAO;AAACvG,SAAD;AAAQzE,QAAR;AAAc6K;AAAd,GAAP;AACD,CAjDD;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxK,QAAQ,CAACwL,uBAAT,GAAmC,CAACpH,KAAD,EAAQzE,IAAR,EAAcC,GAAd,EAAmByK,MAAnB,KAA8B;AAC/D,QAAM3I,OAAO,GAAG;AACd+J,MAAE,EAAErH,KADU;AAEdlE,QAAI,EAAEF,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgCnK,IAAhC,GACFF,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgCnK,IAAhC,CAAqCP,IAArC,CADE,GAEFK,QAAQ,CAACC,cAAT,CAAwBC,IAJd;AAKdM,WAAO,EAAER,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgC7J,OAAhC,CAAwCb,IAAxC;AALK,GAAhB;;AAQA,MAAI,OAAOK,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgC5J,IAAvC,KAAgD,UAApD,EAAgE;AAC9DiB,WAAO,CAACjB,IAAR,GAAeT,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgC5J,IAAhC,CAAqCd,IAArC,EAA2CC,GAA3C,CAAf;AACD;;AAED,MAAI,OAAOI,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgCqB,IAAvC,KAAgD,UAApD,EAAgE;AAC9DhK,WAAO,CAACgK,IAAR,GAAe1L,QAAQ,CAACC,cAAT,CAAwBoK,MAAxB,EAAgCqB,IAAhC,CAAqC/L,IAArC,EAA2CC,GAA3C,CAAf;AACD;;AAED,MAAI,OAAOI,QAAQ,CAACC,cAAT,CAAwB0L,OAA/B,KAA2C,QAA/C,EAAyD;AACvDjK,WAAO,CAACiK,OAAR,GAAkB3L,QAAQ,CAACC,cAAT,CAAwB0L,OAA1C;AACD;;AAED,SAAOjK,OAAP;AACD,CAtBD,C,CAwBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1B,QAAQ,CAACmK,sBAAT,GAAkC,CAAChH,MAAD,EAASiB,KAAT,EAAgBkG,cAAhB,EAAgCsB,WAAhC,KAAgD;AAChF,QAAM;AAACxH,SAAK,EAAEyH,SAAR;AAAmBlM,QAAnB;AAAyB6K;AAAzB,MACJxK,QAAQ,CAACoK,kBAAT,CAA4BjH,MAA5B,EAAoCiB,KAApC,EAA2C,eAA3C,EAA4DkG,cAA5D,CADF;AAEA,QAAM1K,GAAG,GAAGI,QAAQ,CAAC8L,IAAT,CAAcvL,aAAd,CAA4BiK,KAA5B,EAAmCoB,WAAnC,CAAZ;AACA,QAAMlK,OAAO,GAAG1B,QAAQ,CAACwL,uBAAT,CAAiCK,SAAjC,EAA4ClM,IAA5C,EAAkDC,GAAlD,EAAuD,eAAvD,CAAhB;AACAmM,OAAK,CAACC,IAAN,CAAWtK,OAAX;;AACA,MAAItB,MAAM,CAAC6L,aAAX,EAA0B;AACxBC,WAAO,CAACC,GAAR,iCAAqCvM,GAArC;AACD;;AACD,SAAO;AAACwE,SAAK,EAAEyH,SAAR;AAAmBlM,QAAnB;AAAyB6K,SAAzB;AAAgC5K,OAAhC;AAAqC8B;AAArC,GAAP;AACD,CAVD,C,CAYA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1B,QAAQ,CAACoM,mBAAT,GAA+B,CAACjJ,MAAD,EAASiB,KAAT,EAAgBkG,cAAhB,EAAgCsB,WAAhC,KAAgD;AAC7E,QAAM;AAACxH,SAAK,EAAEyH,SAAR;AAAmBlM,QAAnB;AAAyB6K;AAAzB,MACJxK,QAAQ,CAACoK,kBAAT,CAA4BjH,MAA5B,EAAoCiB,KAApC,EAA2C,eAA3C,EAA4DkG,cAA5D,CADF;AAEA,QAAM1K,GAAG,GAAGI,QAAQ,CAAC8L,IAAT,CAAcnL,aAAd,CAA4B6J,KAA5B,EAAmCoB,WAAnC,CAAZ;AACA,QAAMlK,OAAO,GAAG1B,QAAQ,CAACwL,uBAAT,CAAiCK,SAAjC,EAA4ClM,IAA5C,EAAkDC,GAAlD,EAAuD,eAAvD,CAAhB;AACAmM,OAAK,CAACC,IAAN,CAAWtK,OAAX;;AACA,MAAItB,MAAM,CAAC6L,aAAX,EAA0B;AACxBC,WAAO,CAACC,GAAR,mCAAuCvM,GAAvC;AACD;;AACD,SAAO;AAACwE,SAAK,EAAEyH,SAAR;AAAmBlM,QAAnB;AAAyB6K,SAAzB;AAAgC5K,OAAhC;AAAqC8B;AAArC,GAAP;AACD,CAVD,C,CAaA;AACA;;;AACAtB,MAAM,CAAC2I,OAAP,CAAe;AAACxI,eAAa,EAAE,YAAmB;AAAA,sCAAN8L,IAAM;AAANA,UAAM;AAAA;;AAChD,UAAM7B,KAAK,GAAG6B,IAAI,CAAC,CAAD,CAAlB;AACA,UAAMnD,WAAW,GAAGmD,IAAI,CAAC,CAAD,CAAxB;AACA,WAAOrM,QAAQ,CAACsM,YAAT,CACL,IADK,EAEL,eAFK,EAGLD,IAHK,EAIL,UAJK,EAKL,MAAM;AACJlF,WAAK,CAACqD,KAAD,EAAQpD,MAAR,CAAL;AACAD,WAAK,CAAC+B,WAAD,EAAc1B,iBAAd,CAAL;AAEA,YAAM7H,IAAI,GAAGS,MAAM,CAACuB,KAAP,CAAaC,OAAb,CACX;AAAC,yCAAiC4I;AAAlC,OADW,EAEX;AAAC3D,cAAM,EAAE;AACP7D,kBAAQ,EAAE,CADH;AAEP+G,gBAAM,EAAE;AAFD;AAAT,OAFW,CAAb;;AAOA,UAAI,CAACpK,IAAL,EAAW;AACT,cAAM,IAAIS,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,eAAtB,CAAN;AACD;;AACD,YAAM;AAAEuI,YAAF;AAAQP,cAAR;AAAgBjG;AAAhB,UAA0BzE,IAAI,CAACqD,QAAL,CAAcd,QAAd,CAAuB8I,KAAvD;;AACA,UAAIuB,eAAe,GAAGvM,QAAQ,CAACwM,gCAAT,EAAtB;;AACA,UAAInC,MAAM,KAAK,QAAf,EAAyB;AACvBkC,uBAAe,GAAGvM,QAAQ,CAACyM,iCAAT,EAAlB;AACD;;AACD,YAAMC,aAAa,GAAG7B,IAAI,CAAC8B,GAAL,EAAtB;AACA,UAAKD,aAAa,GAAG9B,IAAjB,GAAyB2B,eAA7B,EACE,MAAM,IAAInM,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,eAAtB,CAAN;AACF,UAAI,CAAEyH,cAAc,CAACnK,IAAI,CAACoK,MAAN,CAAd,CAA4BQ,QAA5B,CAAqCnG,KAArC,CAAN,EACE,OAAO;AACLjB,cAAM,EAAExD,IAAI,CAACoD,GADR;AAELO,aAAK,EAAE,IAAIlD,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,iCAAtB;AAFF,OAAP;AAKF,YAAM8G,MAAM,GAAG5G,YAAY,CAAC2G,WAAD,CAA3B,CA5BI,CA8BJ;AACA;AACA;AACA;;AACA,YAAM0D,QAAQ,GAAG5M,QAAQ,CAACqJ,cAAT,CAAwB,KAAKC,UAAL,CAAgB7H,EAAxC,CAAjB;;AACAzB,cAAQ,CAAC6M,cAAT,CAAwBlN,IAAI,CAACoD,GAA7B,EAAkC,KAAKuG,UAAvC,EAAmD,IAAnD;;AACA,YAAMwD,eAAe,GAAG,MACtB9M,QAAQ,CAAC6M,cAAT,CAAwBlN,IAAI,CAACoD,GAA7B,EAAkC,KAAKuG,UAAvC,EAAmDsD,QAAnD,CADF;;AAGA,UAAI;AACF;AACA;AACA;AACA;AACA,cAAMG,eAAe,GAAG3M,MAAM,CAACuB,KAAP,CAAa8B,MAAb,CACtB;AACEV,aAAG,EAAEpD,IAAI,CAACoD,GADZ;AAEE,4BAAkBqB,KAFpB;AAGE,2CAAiCoG;AAHnC,SADsB,EAMtB;AAAC9G,cAAI,EAAE;AAAC,wCAA4ByF,MAA7B;AACC,iCAAqB;AADtB,WAAP;AAECT,gBAAM,EAAE;AAAC,uCAA2B,CAA5B;AACC,qCAAyB;AAD1B;AAFT,SANsB,CAAxB;AAUA,YAAIqE,eAAe,KAAK,CAAxB,EACE,OAAO;AACL5J,gBAAM,EAAExD,IAAI,CAACoD,GADR;AAELO,eAAK,EAAE,IAAIlD,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,eAAtB;AAFF,SAAP;AAIH,OApBD,CAoBE,OAAO2K,GAAP,EAAY;AACZF,uBAAe;AACf,cAAME,GAAN;AACD,OA9DG,CAgEJ;AACA;;;AACAhN,cAAQ,CAACiN,oBAAT,CAA8BtN,IAAI,CAACoD,GAAnC;;AAEA,aAAO;AAACI,cAAM,EAAExD,IAAI,CAACoD;AAAd,OAAP;AACD,KA1EI,CAAP;AA4ED;AA/Ec,CAAf,E,CAiFA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA/C,QAAQ,CAACkN,qBAAT,GAAiC,CAAC/J,MAAD,EAASiB,KAAT,EAAgBkG,cAAhB,EAAgCsB,WAAhC,KAAgD;AAC/E;AACA;AACA;AAEA,QAAM;AAACxH,SAAK,EAAEyH,SAAR;AAAmBlM,QAAnB;AAAyB6K;AAAzB,MACJxK,QAAQ,CAACiL,yBAAT,CAAmC9H,MAAnC,EAA2CiB,KAA3C,EAAkDkG,cAAlD,CADF;AAEA,QAAM1K,GAAG,GAAGI,QAAQ,CAAC8L,IAAT,CAAcpL,WAAd,CAA0B8J,KAA1B,EAAiCoB,WAAjC,CAAZ;AACA,QAAMlK,OAAO,GAAG1B,QAAQ,CAACwL,uBAAT,CAAiCK,SAAjC,EAA4ClM,IAA5C,EAAkDC,GAAlD,EAAuD,aAAvD,CAAhB;AACAmM,OAAK,CAACC,IAAN,CAAWtK,OAAX;;AACA,MAAItB,MAAM,CAAC6L,aAAX,EAA0B;AACxBC,WAAO,CAACC,GAAR,qCAAyCvM,GAAzC;AACD;;AACD,SAAO;AAACwE,SAAK,EAAEyH,SAAR;AAAmBlM,QAAnB;AAAyB6K,SAAzB;AAAgC5K,OAAhC;AAAqC8B;AAArC,GAAP;AACD,CAdD,C,CAgBA;AACA;;;AACAtB,MAAM,CAAC2I,OAAP,CAAe;AAACrI,aAAW,EAAE,YAAmB;AAAA,uCAAN2L,IAAM;AAANA,UAAM;AAAA;;AAC9C,UAAM7B,KAAK,GAAG6B,IAAI,CAAC,CAAD,CAAlB;AACA,WAAOrM,QAAQ,CAACsM,YAAT,CACL,IADK,EAEL,aAFK,EAGLD,IAHK,EAIL,UAJK,EAKL,MAAM;AACJlF,WAAK,CAACqD,KAAD,EAAQpD,MAAR,CAAL;AAEA,YAAMzH,IAAI,GAAGS,MAAM,CAACuB,KAAP,CAAaC,OAAb,CACX;AAAC,mDAA2C4I;AAA5C,OADW,EAEX;AAAC3D,cAAM,EAAE;AACP7D,kBAAQ,EAAE,CADH;AAEP+G,gBAAM,EAAE;AAFD;AAAT,OAFW,CAAb;AAOA,UAAI,CAACpK,IAAL,EACE,MAAM,IAAIS,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,2BAAtB,CAAN;AAEA,YAAMsI,WAAW,GAAGhL,IAAI,CAACqD,QAAL,CAAcoB,KAAd,CAAoBkH,kBAApB,CAAuC9G,IAAvC,CAClB2I,CAAC,IAAIA,CAAC,CAAC3C,KAAF,IAAWA,KADE,CAApB;AAGF,UAAI,CAACG,WAAL,EACE,OAAO;AACLxH,cAAM,EAAExD,IAAI,CAACoD,GADR;AAELO,aAAK,EAAE,IAAIlD,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,2BAAtB;AAFF,OAAP;AAKF,YAAM+K,YAAY,GAAGzN,IAAI,CAACoK,MAAL,CAAYvF,IAAZ,CACnB2G,CAAC,IAAIA,CAAC,CAACnB,OAAF,IAAaW,WAAW,CAACX,OADX,CAArB;AAGA,UAAI,CAACoD,YAAL,EACE,OAAO;AACLjK,cAAM,EAAExD,IAAI,CAACoD,GADR;AAELO,aAAK,EAAE,IAAIlD,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,0CAAtB;AAFF,OAAP,CA1BE,CA+BJ;AACA;AACA;AACA;AACA;;AACAjC,YAAM,CAACuB,KAAP,CAAa8B,MAAb,CACE;AAACV,WAAG,EAAEpD,IAAI,CAACoD,GAAX;AACC,0BAAkB4H,WAAW,CAACX;AAD/B,OADF,EAGE;AAACtG,YAAI,EAAE;AAAC,+BAAqB;AAAtB,SAAP;AACC6F,aAAK,EAAE;AAAC,+CAAqC;AAACS,mBAAO,EAAEW,WAAW,CAACX;AAAtB;AAAtC;AADR,OAHF;AAMA,aAAO;AAAC7G,cAAM,EAAExD,IAAI,CAACoD;AAAd,OAAP;AACD,KAhDI,CAAP;AAkDD;AApDc,CAAf;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA/C,QAAQ,CAACqN,QAAT,GAAoB,CAAClK,MAAD,EAASmK,QAAT,EAAmBlC,QAAnB,KAAgC;AAClDjE,OAAK,CAAChE,MAAD,EAAS4D,cAAT,CAAL;AACAI,OAAK,CAACmG,QAAD,EAAWvG,cAAX,CAAL;AACAI,OAAK,CAACiE,QAAD,EAAWpE,KAAK,CAACM,QAAN,CAAeiG,OAAf,CAAX,CAAL;;AAEA,MAAInC,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvBA,YAAQ,GAAG,KAAX;AACD;;AAED,QAAMzL,IAAI,GAAG6B,WAAW,CAAC2B,MAAD,EAAS;AAAC0D,UAAM,EAAE;AAACkD,YAAM,EAAE;AAAT;AAAT,GAAT,CAAxB;AACA,MAAI,CAACpK,IAAL,EACE,MAAM,IAAIS,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,gBAAtB,CAAN,CAXgD,CAalD;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMmL,qBAAqB,GACzB,IAAInI,MAAJ,YAAejF,MAAM,CAACkF,aAAP,CAAqBgI,QAArB,CAAf,QAAkD,GAAlD,CADF;AAGA,QAAMG,iBAAiB,GAAG,CAAC9N,IAAI,CAACoK,MAAL,IAAe,EAAhB,EAAoB2D,MAApB,CACxB,CAACC,IAAD,EAAOvJ,KAAP,KAAiB;AACf,QAAIoJ,qBAAqB,CAACI,IAAtB,CAA2BxJ,KAAK,CAAC4F,OAAjC,CAAJ,EAA+C;AAC7C5J,YAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAClBV,WAAG,EAAEpD,IAAI,CAACoD,GADQ;AAElB,0BAAkBqB,KAAK,CAAC4F;AAFN,OAApB,EAGG;AAACtG,YAAI,EAAE;AACR,8BAAoB4J,QADZ;AAER,+BAAqBlC;AAFb;AAAP,OAHH;AAOA,aAAO,IAAP;AACD,KATD,MASO;AACL,aAAOuC,IAAP;AACD;AACF,GAduB,EAexB,KAfwB,CAA1B,CAxBkD,CA0ClD;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAIF,iBAAJ,EAAuB;AACrB;AACD,GAnDiD,CAqDlD;;;AACAtH,mCAAiC,CAAC,gBAAD,EAAmB,OAAnB,EAA4BmH,QAA5B,EAAsC3N,IAAI,CAACoD,GAA3C,CAAjC;AAEA3C,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAClBV,OAAG,EAAEpD,IAAI,CAACoD;AADQ,GAApB,EAEG;AACD8K,aAAS,EAAE;AACT9D,YAAM,EAAE;AACNC,eAAO,EAAEsD,QADH;AAENlC,gBAAQ,EAAEA;AAFJ;AADC;AADV,GAFH,EAxDkD,CAmElD;AACA;;AACA,MAAI;AACFjF,qCAAiC,CAAC,gBAAD,EAAmB,OAAnB,EAA4BmH,QAA5B,EAAsC3N,IAAI,CAACoD,GAA3C,CAAjC;AACD,GAFD,CAEE,OAAO+F,EAAP,EAAW;AACX;AACA1I,UAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,SAAG,EAAEpD,IAAI,CAACoD;AAAX,KAApB,EACE;AAACwG,WAAK,EAAE;AAACQ,cAAM,EAAE;AAACC,iBAAO,EAAEsD;AAAV;AAAT;AAAR,KADF;AAEA,UAAMxE,EAAN;AACD;AACF,CA7ED;AA+EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9I,QAAQ,CAAC8N,WAAT,GAAuB,CAAC3K,MAAD,EAASiB,KAAT,KAAmB;AACxC+C,OAAK,CAAChE,MAAD,EAAS4D,cAAT,CAAL;AACAI,OAAK,CAAC/C,KAAD,EAAQ2C,cAAR,CAAL;AAEA,QAAMpH,IAAI,GAAG6B,WAAW,CAAC2B,MAAD,EAAS;AAAC0D,UAAM,EAAE;AAAC9D,SAAG,EAAE;AAAN;AAAT,GAAT,CAAxB;AACA,MAAI,CAACpD,IAAL,EACE,MAAM,IAAIS,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,gBAAtB,CAAN;AAEFjC,QAAM,CAACuB,KAAP,CAAa8B,MAAb,CAAoB;AAACV,OAAG,EAAEpD,IAAI,CAACoD;AAAX,GAApB,EACE;AAACwG,SAAK,EAAE;AAACQ,YAAM,EAAE;AAACC,eAAO,EAAE5F;AAAV;AAAT;AAAR,GADF;AAED,CAVD,C,CAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAM2J,UAAU,GAAGrM,OAAO,IAAI;AAC5B;AACA;AACAyF,OAAK,CAACzF,OAAD,EAAUsF,KAAK,CAACgH,eAAN,CAAsB;AACnC7J,YAAQ,EAAE6C,KAAK,CAACM,QAAN,CAAeF,MAAf,CADyB;AAEnChD,SAAK,EAAE4C,KAAK,CAACM,QAAN,CAAeF,MAAf,CAF4B;AAGnClF,YAAQ,EAAE8E,KAAK,CAACM,QAAN,CAAeE,iBAAf;AAHyB,GAAtB,CAAV,CAAL;AAMA,QAAM;AAAErD,YAAF;AAAYC,SAAZ;AAAmBlC;AAAnB,MAAgCR,OAAtC;AACA,MAAI,CAACyC,QAAD,IAAa,CAACC,KAAlB,EACE,MAAM,IAAIhE,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,iCAAtB,CAAN;AAEF,QAAM1C,IAAI,GAAG;AAACqD,YAAQ,EAAE;AAAX,GAAb;;AACA,MAAId,QAAJ,EAAc;AACZ,UAAMiH,MAAM,GAAG5G,YAAY,CAACL,QAAD,CAA3B;AACAvC,QAAI,CAACqD,QAAL,CAAcd,QAAd,GAAyB;AAAEjB,YAAM,EAAEkI;AAAV,KAAzB;AACD;;AAED,MAAIhF,QAAJ,EACExE,IAAI,CAACwE,QAAL,GAAgBA,QAAhB;AACF,MAAIC,KAAJ,EACEzE,IAAI,CAACoK,MAAL,GAAc,CAAC;AAACC,WAAO,EAAE5F,KAAV;AAAiBgH,YAAQ,EAAE;AAA3B,GAAD,CAAd,CAtB0B,CAwB5B;;AACAjF,mCAAiC,CAAC,UAAD,EAAa,UAAb,EAAyBhC,QAAzB,CAAjC;AACAgC,mCAAiC,CAAC,gBAAD,EAAmB,OAAnB,EAA4B/B,KAA5B,CAAjC;AAEA,QAAMjB,MAAM,GAAGnD,QAAQ,CAACiO,aAAT,CAAuBvM,OAAvB,EAAgC/B,IAAhC,CAAf,CA5B4B,CA6B5B;AACA;;AACA,MAAI;AACFwG,qCAAiC,CAAC,UAAD,EAAa,UAAb,EAAyBhC,QAAzB,EAAmChB,MAAnC,CAAjC;AACAgD,qCAAiC,CAAC,gBAAD,EAAmB,OAAnB,EAA4B/B,KAA5B,EAAmCjB,MAAnC,CAAjC;AACD,GAHD,CAGE,OAAO2F,EAAP,EAAW;AACX;AACA1I,UAAM,CAACuB,KAAP,CAAauM,MAAb,CAAoB/K,MAApB;AACA,UAAM2F,EAAN;AACD;;AACD,SAAO3F,MAAP;AACD,CAxCD,C,CA0CA;;;AACA/C,MAAM,CAAC2I,OAAP,CAAe;AAACgF,YAAU,EAAE,YAAmB;AAAA,uCAAN1B,IAAM;AAANA,UAAM;AAAA;;AAC7C,UAAM3K,OAAO,GAAG2K,IAAI,CAAC,CAAD,CAApB;AACA,WAAOrM,QAAQ,CAACsM,YAAT,CACL,IADK,EAEL,YAFK,EAGLD,IAHK,EAIL,UAJK,EAKL,MAAM;AACJ;AACAlF,WAAK,CAACzF,OAAD,EAAU6E,MAAV,CAAL;AACA,UAAIvG,QAAQ,CAAC+B,QAAT,CAAkBoM,2BAAtB,EACE,OAAO;AACL7K,aAAK,EAAE,IAAIlD,MAAM,CAACiC,KAAX,CAAiB,GAAjB,EAAsB,mBAAtB;AADF,OAAP;AAIF,YAAMc,MAAM,GAAGnD,QAAQ,CAACoO,wBAAT,CAAkC1M,OAAlC,CAAf,CARI,CAUJ;;AACA,aAAO;AAACyB,cAAM,EAAEA;AAAT,OAAP;AACD,KAjBI,CAAP;AAmBD;AArBc,CAAf,E,CAuBA;AACA;AACA;AACA;AACA;;AACAnD,QAAQ,CAACoO,wBAAT,GAAqC1M,OAAD,IAAa;AAC/CA,SAAO,qBAAQA,OAAR,CAAP,CAD+C,CAE/C;;AACA,QAAMyB,MAAM,GAAG4K,UAAU,CAACrM,OAAD,CAAzB,CAH+C,CAI/C;AACA;;AACA,MAAI,CAAEyB,MAAN,EACE,MAAM,IAAId,KAAJ,CAAU,sCAAV,CAAN,CAP6C,CAS/C;AACA;AACA;;AACA,MAAIX,OAAO,CAAC0C,KAAR,IAAiBpE,QAAQ,CAAC+B,QAAT,CAAkBmL,qBAAvC,EAA8D;AAC5D,QAAIxL,OAAO,CAACQ,QAAZ,EAAsB;AACpBlC,cAAQ,CAACkN,qBAAT,CAA+B/J,MAA/B,EAAuCzB,OAAO,CAAC0C,KAA/C;AACD,KAFD,MAEO;AACLpE,cAAQ,CAACoM,mBAAT,CAA6BjJ,MAA7B,EAAqCzB,OAAO,CAAC0C,KAA7C;AACD;AACF;;AAED,SAAOjB,MAAP;AACD,CArBD,C,CAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnD,QAAQ,CAAC+N,UAAT,GAAsB,CAACrM,OAAD,EAAU2M,QAAV,KAAuB;AAC3C3M,SAAO,qBAAQA,OAAR,CAAP,CAD2C,CAG3C;;AACA,MAAI2M,QAAJ,EAAc;AACZ,UAAM,IAAIhM,KAAJ,CAAU,oEAAV,CAAN;AACD;;AAED,SAAO0L,UAAU,CAACrM,OAAD,CAAjB;AACD,CATD,C,CAWA;AACA;AACA;;;AACAtB,MAAM,CAACuB,KAAP,CAAa2M,YAAb,CAA0B,yCAA1B,EAC0B;AAAEC,QAAM,EAAE,IAAV;AAAgBC,QAAM,EAAE;AAAxB,CAD1B;;AAEApO,MAAM,CAACuB,KAAP,CAAa2M,YAAb,CAA0B,+BAA1B,EAC0B;AAAEC,QAAM,EAAE,IAAV;AAAgBC,QAAM,EAAE;AAAxB,CAD1B,E","file":"/packages/accounts-password.js","sourcesContent":["const greet = welcomeMsg => (user, url) => {\n      const greeting = (user.profile && user.profile.name) ?\n            (`Hello ${user.profile.name},`) : \"Hello,\";\n      return `${greeting}\n\n${welcomeMsg}, simply click the link below.\n\n${url}\n\nThanks.\n`;\n};\n\n/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n * @importFromPackage accounts-base\n */\nAccounts.emailTemplates = {\n  from: \"Accounts Example <no-reply@example.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n\n  resetPassword: {\n    subject: () => `How to reset your password on ${Accounts.emailTemplates.siteName}`,\n    text: greet(\"To reset your password\"),\n  },\n  verifyEmail: {\n    subject: () => `How to verify email address on ${Accounts.emailTemplates.siteName}`,\n    text: greet(\"To verify your account email\"),\n  },\n  enrollAccount: {\n    subject: () => `An account has been created for you on ${Accounts.emailTemplates.siteName}`,\n    text: greet(\"To start using the service\"),\n  },\n};\n","/// BCRYPT\n\nconst bcrypt = NpmModuleBcrypt;\nconst bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nconst bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// Utility for grabbing user\nconst getUserById = (id, options) => Meteor.users.findOne(id, Accounts._addDefaultFieldSelector(options));\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nconst getPasswordString = password => {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nconst hashPassword = password => {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds());\n};\n\n// Extract the number of rounds used in the specified bcrypt hash.\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n  if (hash) {\n    const hashSegments = hash.split('$');\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n  return rounds;\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\n// The user parameter needs at least user._id and user.services\nAccounts._checkPasswordUserFields = {_id: 1, services: 1};\n//\nAccounts._checkPassword = (user, password) => {\n  const result = {\n    userId: user._id\n  };\n\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n\n  if (! bcryptCompare(formattedPassword, hash)) {\n    result.error = handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n    Meteor.defer(() => {\n      Meteor.users.update({ _id: user._id }, {\n        $set: {\n          'services.password.bcrypt':\n            bcryptHash(formattedPassword, Accounts._bcryptRounds())\n        }\n      });\n    });\n  }\n\n  return result;\n};\nconst checkPassword = Accounts._checkPassword;\n\n///\n/// ERROR HANDLER\n///\nconst handleError = (msg, throwError = true) => {\n  const error = new Meteor.Error(\n    403,\n    Accounts._options.ambiguousErrorMessages\n      ? \"Something went wrong. Please check your credentials.\"\n      : msg\n  );\n  if (throwError) {\n    throw error;\n  }\n  return error;\n};\n\n///\n/// LOGIN\n///\n\nAccounts._findUserByQuery = (query, options) => {\n  let user = null;\n\n  if (query.id) {\n    // default field selector is added within getUserById()\n    user = getUserById(query.id, options);\n  } else {\n    options = Accounts._addDefaultFieldSelector(options);\n    let fieldName;\n    let fieldValue;\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n    let selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector, options);\n    // If user is not found, try a case insensitive lookup\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      const candidateUsers = Meteor.users.find(selector, options).fetch();\n      // No match if multiple candidates are found\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername =\n  (username, options) => Accounts._findUserByQuery({ username }, options);\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail =\n  (email, options) => Accounts._findUserByQuery({ email }, options);\n\n// Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\nconst selectorForFastCaseInsensitiveLookup = (fieldName, string) => {\n  // Performance seems to improve up to 4 prefix characters\n  const prefix = string.substring(0, Math.min(string.length, 4));\n  const orClause = generateCasePermutationsForString(prefix).map(\n    prefixPermutation => {\n      const selector = {};\n      selector[fieldName] =\n        new RegExp(`^${Meteor._escapeRegExp(prefixPermutation)}`);\n      return selector;\n    });\n  const caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] =\n    new RegExp(`^${Meteor._escapeRegExp(string)}$`, 'i')\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};\n}\n\n// Generates permutations of all case variations of a given string.\nconst generateCasePermutationsForString = string => {\n  let permutations = [''];\n  for (let i = 0; i < string.length; i++) {\n    const ch = string.charAt(i);\n    permutations = [].concat(...(permutations.map(prefix => {\n      const lowerCaseChar = ch.toLowerCase();\n      const upperCaseChar = ch.toUpperCase();\n      // Don't add unneccesary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    })));\n  }\n  return permutations;\n}\n\nconst checkForCaseInsensitiveDuplicates = (fieldName, displayName, fieldValue, ownUserId) => {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  const skipCheck = Object.prototype.hasOwnProperty.call(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    const matchedUsers = Meteor.users.find(\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue),\n      {\n        fields: {_id: 1},\n        // we only need a maximum of 2 users for the logic below to work\n        limit: 2,\n      }\n    ).fetch();\n\n    if (matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n        // Otherwise, check to see if there are multiple matches or a match\n        // that is not us\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {\n      handleError(`${displayName} already exists.`);\n    }\n  }\n};\n\n// XXX maybe this belongs in the check package\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\n\nconst userQueryValidator = Match.Where(user => {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (Object.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nconst passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", options => {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  const user = Accounts._findUserByQuery(options.user, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      const verifier = user.services.password.srp;\n      const newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n          error: handleError(\"Incorrect password\", false)\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", options => {\n  if (!options.srp || !options.password) {\n    return undefined; // don't handle\n  }\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  const user = Accounts._findUserByQuery(options.user, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt) {\n    return checkPassword(user, options.password);\n  }\n\n  if (!(user.services && user.services.password && user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  const v1 = user.services.password.srp.verifier;\n  const v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2) {\n    return {\n      userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n      error: handleError(\"Incorrect password\", false)\n    };\n  }\n\n  // Upgrade to bcrypt on successful login.\n  const salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername = (userId, newUsername) => {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  const user = getUserById(userId, {fields: {\n    username: 1,\n  }});\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  const oldUsername = user.username;\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId) {\n    throw new Meteor.Error(401, \"Must be logged in\");\n  }\n\n  const user = getUserById(this.userId, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  const result = checkPassword(user, oldPassword);\n  if (result.error) {\n    throw result.error;\n  }\n\n  const hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  const currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPassword = (userId, newPlaintextPassword, options) => {\n  options = { logout: true , ...options };\n\n  const user = getUserById(userId, {fields: {_id: 1}});\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  const update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Utility for plucking addresses from emails\nconst pluckAddresses = (emails = []) => emails.map(email => email.address);\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: options => {\n  check(options, {email: String});\n\n  const user = Accounts.findUserByEmail(options.email, {fields: {emails: 1}});\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  const emails = pluckAddresses(user.emails);\n  const caseSensitiveEmail = emails.find(\n    email => email.toLowerCase() === options.email.toLowerCase()\n  );\n\n  Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n}});\n\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateResetToken = (userId, email, reason, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n  if (!user) {\n    handleError(\"Can't find user\");\n  }\n\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email ||\n    !(pluckAddresses(user.emails).includes(email))) {\n    handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$set: {\n    'services.password.reset': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  return {email, user, token};\n};\n\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateVerificationToken = (userId, email, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n  if (!user) {\n    handleError(\"Can't find user\");\n  }\n\n  // pick the first unverified email if we weren't passed an email.\n  if (!email) {\n    const emailRecord = (user.emails || []).find(e => !e.verified);\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      handleError(\"That user has no unverified email addresses.\");\n    }\n  }\n\n  // make sure we have a valid email\n  if (!email ||\n    !(pluckAddresses(user.emails).includes(email))) {\n    handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$push: {\n    'services.email.verificationTokens': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  return {email, user, token};\n};\n\n/**\n * @summary Creates options for email sending for reset password and enroll account emails.\n * You can use this function when customizing a reset password or enroll account email sending.\n * @locus Server\n * @param {Object} email Which address of the user's to send the email to.\n * @param {Object} user The user object to generate options for.\n * @param {String} url URL to which user is directed to confirm the email.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @returns {Object} Options which can be passed to `Email.send`.\n * @importFromPackage accounts-base\n */\nAccounts.generateOptionsForEmail = (email, user, url, reason) => {\n  const options = {\n    to: email,\n    from: Accounts.emailTemplates[reason].from\n      ? Accounts.emailTemplates[reason].from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates[reason].subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates[reason].text === 'function') {\n    options.text = Accounts.emailTemplates[reason].text(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates[reason].html === 'function') {\n    options.html = Accounts.emailTemplates[reason].html(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  return options;\n};\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the reset url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail = (userId, email, extraTokenData, extraParams) => {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(`\\nReset password URL: ${url}`);\n  }\n  return {email: realEmail, user, token, url, options};\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the enrollment url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail = (userId, email, extraTokenData, extraParams) => {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(`\\nEnrollment email URL: ${url}`);\n  }\n  return {email: realEmail, user, token, url, options};\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (...args) {\n  const token = args[0];\n  const newPassword = args[1];\n  return Accounts._loginMethod(\n    this,\n    \"resetPassword\",\n    args,\n    \"password\",\n    () => {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      const user = Meteor.users.findOne(\n        {\"services.password.reset.token\": token},\n        {fields: {\n          services: 1,\n          emails: 1,\n        }}\n      );\n      if (!user) {\n        throw new Meteor.Error(403, \"Token expired\");\n      }\n      const { when, reason, email } = user.services.password.reset;\n      let tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n      if (reason === \"enroll\") {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n      const currentTimeMs = Date.now();\n      if ((currentTimeMs - when) > tokenLifetimeMs)\n        throw new Meteor.Error(403, \"Token expired\");\n      if (!(pluckAddresses(user.emails).includes(email)))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      const hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      const oldToken = Accounts._getLoginToken(this.connection.id);\n      Accounts._setLoginToken(user._id, this.connection, null);\n      const resetToOldToken = () =>\n        Accounts._setLoginToken(user._id, this.connection, oldToken);\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        const affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the verification url.\n *\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail = (userId, email, extraTokenData, extraParams) => {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  const {email: realEmail, user, token} =\n    Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(`\\nVerification email URL: ${url}`);\n  }\n  return {email: realEmail, user, token, url, options};\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (...args) {\n  const token = args[0];\n  return Accounts._loginMethod(\n    this,\n    \"verifyEmail\",\n    args,\n    \"password\",\n    () => {\n      check(token, String);\n\n      const user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token},\n        {fields: {\n          services: 1,\n          emails: 1,\n        }}\n      );\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n        const tokenRecord = user.services.email.verificationTokens.find(\n          t => t.token == token\n        );\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      const emailsRecord = user.emails.find(\n        e => e.address == tokenRecord.address\n      );\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmail = (userId, newEmail, verified) => {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (verified === void 0) {\n    verified = false;\n  }\n\n  const user = getUserById(userId, {fields: {emails: 1}});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  const caseInsensitiveRegExp =\n    new RegExp(`^${Meteor._escapeRegExp(newEmail)}$`, 'i');\n\n  const didUpdateOwnEmail = (user.emails || []).reduce(\n    (prev, email) => {\n      if (caseInsensitiveRegExp.test(email.address)) {\n        Meteor.users.update({\n          _id: user._id,\n          'emails.address': email.address\n        }, {$set: {\n          'emails.$.address': newEmail,\n          'emails.$.verified': verified\n        }});\n        return true;\n      } else {\n        return prev;\n      }\n    },\n    false\n  );\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail = (userId, email) => {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  const user = getUserById(userId, {fields: {_id: 1}});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nconst createUser = options => {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  const { username, email, password } = options;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  const user = {services: {}};\n  if (password) {\n    const hashed = hashPassword(password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  // Perform a case insensitive check before insert\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n  const userId = Accounts.insertUserDoc(options, user);\n  // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n  return userId;\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (...args) {\n  const options = args[0];\n  return Accounts._loginMethod(\n    this,\n    \"createUser\",\n    args,\n    \"password\",\n    () => {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      const userId = Accounts.createUserVerifyingEmail(options);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Differently from Accounts.createUser(), this evaluates the Accounts package\n// configurations and send a verification email if the user has been registered\n// successfully.\nAccounts.createUserVerifyingEmail = (options) => {\n  options = { ...options };\n  // Create user. result contains id and token.\n  const userId = createUser(options);\n  // safety belt. createUser is supposed to throw on error. send 500 error\n  // instead of sending a verification email with empty userid.\n  if (! userId)\n    throw new Error(\"createUser failed to insert new user\");\n\n  // If `Accounts._options.sendVerificationEmail` is set, register\n  // a token to verify the user's primary email, and send it to\n  // that address.\n  if (options.email && Accounts._options.sendVerificationEmail) {\n    if (options.password) {\n      Accounts.sendVerificationEmail(userId, options.email);\n    } else {\n      Accounts.sendEnrollmentEmail(userId, options.email);\n    }\n  }\n\n  return userId;\n};\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = (options, callback) => {\n  options = { ...options };\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('services.email.verificationTokens.token',\n                          { unique: true, sparse: true });\nMeteor.users._ensureIndex('services.password.reset.token',\n                          { unique: true, sparse: true });\n"]}}]