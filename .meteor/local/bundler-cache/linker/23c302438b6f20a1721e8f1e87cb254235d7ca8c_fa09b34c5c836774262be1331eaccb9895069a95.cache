[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\n\n/* Package-scope variables */\nvar CDN;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/nitrolabs_cdn/lib/server.js                                                                    //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar url = Npm.require(\"url\");\nvar path = Npm.require(\"path\");\n\nconst FONTS = ['.ttf','.eot','.otf','.svg','.woff','.woff2'];\nconst ALLOWED_PROTOCOLS = ['http:', 'https:'];\n\n/* stripSlashes\n *\n * Strip the trailing slash from a url\n */\nfunction stripSlashes(url){\n\tif (url){\n\t\t\treturn url.replace(/\\/$/, \"\");\n\t} else {\n\t\treturn url;\n\t}\n}\n\n/* CdnController\n *\n * Controls the way that the CDN package interacts\n * with the Meteor server\n *\n */\nfunction CdnController(){\n\tvar cdnUrl = stripSlashes(process.env.CDN_URL);\n\tvar rootUrl = stripSlashes(process.env.ROOT_URL);\n\n\n\tthis._setRootUrl = function(newRootUrl){\n\t\t// Change the ROOT_URL, for testing purposes\n\t\trootUrl = stripSlashes(newRootUrl);\n\t}\n\n\n\tthis._setCdnUrl = function(newCdnUrl){\n\t\t// Change the CDN Url, for testing purposes\n\t\tcdnUrl = stripSlashes(newCdnUrl);\n\t\tsetClientCdnUrl(cdnUrl);\n\t}\n\n\n\tfunction validateSettings(rootUrl,cdnUrl){\n\t\t// Return True if the ROOT_URL and CDN_URL settings are valid\n\t\t// Return False if the settings are invalid, but the server can continue\n\t\t// Throw an error if the settings are fatally incorrect\n\t\tif (!rootUrl){\n\t\t\tconsole.log('ROOT_URL is not set. Using default Meteor behaviour');\n\t\t\treturn false;\n\t\t} else if (!cdnUrl){\n\t\t\tconsole.warn('CDN_URL is not set. Using default Meteor behaviour');\n\t\t\treturn false;\n\t\t}\n\t\tvar cdn = url.parse(cdnUrl);\n\t\tvar root = url.parse(rootUrl);\n\n\t\t// Make sure that the CDN_URL is different from the ROOT_URL\n\t\t// If these are the same, we can't detect requests from the CDN\n\t\tif (cdn.host === root.host){\n\t\t\tconsole.warn('CDN: CDN HOST === ROOT HOST. Using default Meteor behaviour');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ensure that the CDN_URL and ROOT_URL are correctly formed\n\t\tif (ALLOWED_PROTOCOLS.indexOf(root.protocol)<0){\n\t\t\tthrow new Meteor.Error(\"ROOT_URL must use http or https protocol, not \"+root.protocol);\n\t\t} else if (ALLOWED_PROTOCOLS.indexOf(cdn.protocol)<0){\n\t\t\tthrow new Meteor.Error(\"CDN_URL must use http or https protocol, not \"+cdn.protocol);\n\t\t}\n\n\t\t// Return true if the settings are valid\n\t\treturn true;\n\t}\n\n\n\tfunction setClientCdnUrl(cdnUrl){\n\t\t// Make the CDN_URL available on the client\n\t\t// console.log(\"Setting BundledJsCssPrefix to \"+cdnUrl);\n\t\tvar hasQuestionMark = new RegExp('[\\?]');\n\t\tWebAppInternals.setBundledJsCssUrlRewriteHook(function(url) {\n\t\t\t// This code fixes an issue in Galaxy where you can end up getting served\n\t\t\t// stale code after deployments\n\t\t\tvar galaxyVersionId = process.env.GALAXY_APP_VERSION_ID;\n\t\t\tvar rewrittenUrl = cdnUrl + url;\n\t\t\tif (galaxyVersionId) {\n\t\t\t\tvar separator = hasQuestionMark.test(url) ? '&' : '?';\n\t\t\t\trewrittenUrl += separator + '_g_app_v_=' + galaxyVersionId;\n\t\t\t}\n\t\t\treturn rewrittenUrl;\n\t\t});\n\t\t// WebAppInternals.setBundledJsCssPrefix(cdnUrl);\n\t\t__meteor_runtime_config__.CDN_URL = cdnUrl;\n\t}\n\n\tfunction configureBrowserPolicy(cdnUrl){\n\t\tconsole.log('Attemping to configure BrowserPolicy');\n\t\tif (Package['browser-policy']) {\n\t\t\tBrowserPolicy.content.allowOriginForAll(cdnUrl);\n\t\t\tconsole.log('Configure BrowserPolicy allowOriginForAll(' + cdnUrl + ')');\n\t\t}\n\t}\n\n\n\tfunction CORSconnectHandler(req, res, next){\n\t\t// Set CORS headers on webfonts to avoid issue with chrome and firefox\n\t\tvar ext = path.extname(url.parse(req.url).pathname);\n\n\t\tif (FONTS.indexOf(ext) > -1){\n\t\t\tres.setHeader('Strict-Transport-Security', 'max-age=2592000; includeSubDomains'); // 2592000s / 30 days\n\t\t\tres.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\t\t}\n\t\tnext();\n\t}\n\n\n\tfunction static404connectHandler(req, res, next){\n\t\t// Return 404 if a non-existent static file is requested\n\t\t// If REQUEST_HOST === CDN_URL then a 404 is returned for all non-static files\n\t\tvar pathname = url.parse(req.url).pathname;\n\t\tvar ext = path.extname(pathname);\n\t\tvar cdn = url.parse(cdnUrl);\n\t\tvar root = url.parse(rootUrl)\n\n\t\tvar isFromCDN = (req.headers.host===cdn.host && req.headers.host!==root.host);\n\n\t\t// Cloudfront removes all headers by default\n\t\t// We need the HOST header to determine where this request came from\n\t\tif (!req.headers.host) {\n\t\t\tconsole.warn('HOST header is not set');\n\t\t\tconsole.warn('Unable to determine if this request came via the CDN');\n\t\t} else if (isFromCDN && !(pathname in WebAppInternals.staticFiles)){\n\t\t\tconsole.warn(\"Static resource not found: \"+pathname);\n\t\t\tres.writeHead(404);\n\t\t\tres.write('Static File Not Found');\n\t\t\tres.end();\n\t\t\treturn res;\n\t\t} else if (isFromCDN) {\n\t\t\tconsole.log(\"Serving to CDN: \"+pathname);\n\t\t}\n\t\tnext();\n\t}\n\n\n\t// Initialize the CDN\n\tif (validateSettings(rootUrl, cdnUrl)){\n\t\tsetClientCdnUrl(cdnUrl);\n\t\tconfigureBrowserPolicy(cdnUrl);\n\t\tWebApp.rawConnectHandlers.use(static404connectHandler);\n\t\tWebApp.rawConnectHandlers.use(CORSconnectHandler);\n\t\tconsole.info('Using CDN: '+cdnUrl);\n\t}\n\n\t// TODO: Find a way to avoid this\n\t// Export for testing\n\tthis._validateSettings = validateSettings;\n\tthis._CORSconnectHandler = CORSconnectHandler;\n\tthis._static404connectHandler = static404connectHandler;\n}\n\n\n// Export the CDN object\nCDN = {};\n\n// Add CDN_URL available through the CDN object\nCDN.get_cdn_url = function(){\n  return __meteor_runtime_config__.CDN_URL || \"\";\n}\n\n// Create CDN config object.\n// Config object can include the headers object inside which can be used to\n// override headers for certain folders or files.\nCDN.config = function(config) {\n\tif (config.headers) {\n\t\tWebApp.rawConnectHandlers.use(\"/\", function(req, res, next) {\n\t\t\tfor (var path in config.headers) {\n\t\t\t\tif (config.headers.hasOwnProperty(path)) {\n\t\t\t\t\t// If path matches, setup headers for the response\n\t\t\t\t\tif (req._parsedUrl.path.startsWith(path)) {\n\t\t\t\t\t\tfor (var pathHeaders in config.headers[path]) {\n\t\t\t\t\t\t\tif (config.headers[path].hasOwnProperty(pathHeaders)) {\n\t\t\t\t\t\t\t\t//console.log(\"Setting header: \" + pathHeaders + \": \" + config.headers[path][pathHeaders] + \" for path: \" + req._parsedUrl.path);\n\t\t\t\t\t\t\t\tres.setHeader(pathHeaders, config.headers[path][pathHeaders]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext();\n\t\t});\n\t}\n}\n\n// Add this for testing purposes\nCDN._controllerClass = CdnController;\n\nMeteor.startup(function() {\n\tCDN = new CdnController();\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"nitrolabs:cdn\", {\n  CDN: CDN\n});\n\n})();\n","servePath":"/packages/nitrolabs_cdn.js"}]