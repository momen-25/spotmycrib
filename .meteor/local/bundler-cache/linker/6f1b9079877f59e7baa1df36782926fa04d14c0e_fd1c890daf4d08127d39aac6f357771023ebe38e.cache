[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar Random = Package.random.Random;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar Utilities;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"msavin:mongol\":{\"server\":{\"main.js\":function module(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/msavin_mongol/server/main.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.link(\"./methods.js\");\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"methods.js\":function module(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/msavin_mongol/server/methods.js                                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nlet utilities;\nmodule.link(\"./utilities.js\", {\n  utilities(v) {\n    utilities = v;\n  }\n\n}, 0);\nlet ToyKit;\nmodule.link(\"meteor/meteortoys:toykit\", {\n  ToyKit(v) {\n    ToyKit = v;\n  }\n\n}, 1);\nlet Random;\nmodule.link(\"meteor/random\", {\n  Random(v) {\n    Random = v;\n  }\n\n}, 2);\n\nvar _insertDoc = function (collectionName, documentData) {\n  var newId,\n      Collection = ToyKit.collection.get(collectionName);\n\n  if (documentData._id && Collection.findOne(documentData._id)) {\n    // console.log('Mongol: Duplicate _id found');\n    return null;\n  }\n\n  if (!documentData._id) {\n    documentData._id = Random.id();\n  }\n\n  if (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && typeof Collection.simpleSchema === \"function\" && Collection._c2) {\n    return Collection.insert(documentData, {\n      filter: false,\n      autoConvert: false,\n      removeEmptyStrings: false,\n      validate: false\n    });\n  } else {\n    return Collection.insert(documentData);\n  }\n};\n\nMeteor.methods({\n  Mongol_update: function (collectionName, documentData, originalDocumentData) {\n    // console.log(arguments)\n    check(collectionName, String);\n    check(documentData, Object);\n    check(originalDocumentData, Object);\n    var Collection = ToyKit.collection.get(collectionName),\n        documentID = documentData._id,\n        originalID = originalDocumentData._id;\n    var currentDbDoc = Collection.findOne({\n      _id: documentID\n    }, {\n      transform: null\n    }); // console.log(currentDbDoc)\n\n    if (!currentDbDoc) {\n      return _insertdoc(collectionName, documentData);\n    }\n\n    delete documentData._id;\n    delete originalDocumentData._id;\n    delete currentDbDoc._id;\n    var updatedDocumentData = Utilities.diffDocumentData(currentDbDoc, documentData, originalDocumentData);\n    delete updatedDocumentData._id; // console.log(updatedDocumentData)\n    // Check for packages\n\n    if (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && typeof Collection.simpleSchema === \"function\" && Collection._c2) {\n      if (typeof Collection.rawCollection) {\n        Collection.rawCollection().update({\n          _id: documentID\n        }, {\n          $set: updatedDocumentData\n        }, {\n          filter: false,\n          autoConvert: false,\n          removeEmptyStrings: false,\n          validate: false\n        });\n      } else {\n        Collection.update({\n          _id: documentID\n        }, {\n          $set: updatedDocumentData\n        }, {\n          filter: false,\n          autoConvert: false,\n          removeEmptyStrings: false,\n          validate: false\n        });\n      }\n\n      return;\n    } // Run the magic\n\n\n    Collection.update({\n      _id: documentID\n    }, {\n      $set: updatedDocumentData\n    });\n  },\n  Mongol_remove: function (collectionName, docId, skipTrashing) {\n    // console.log(arguments)\n    check(collectionName, String);\n    check(docId, String);\n    check(skipTrashing, Match.Any); // Get Original Document\n\n    var Collection = ToyKit.collection.get(collectionName); // // Move document to Trash Can\n\n    if (!skipTrashing) {\n      var trash = Collection.findOne(docId, {\n        transform: null\n      });\n      trash[\"Mongol_origin\"] = String(collectionName);\n      trash[\"Mongol_date\"] = new Date();\n\n      _insertDoc(\"MeteorToys.Mongol\", trash);\n    } // remove the document\n\n\n    return Collection.remove({\n      _id: docId\n    });\n  },\n  Mongol_duplicate: function (collectionName, docId) {\n    check(collectionName, String);\n    check(docId, String); // console.log(docId)\n\n    var Collection = ToyKit.collection.get(collectionName);\n    var Document = Collection.findOne(docId, {\n      transform: null\n    });\n\n    if (Document) {\n      delete Document._id;\n      return _insertDoc(collectionName, Document);\n    }\n  },\n  Mongol_insert: function (collectionName, documentData) {\n    check(collectionName, String);\n    check(documentData, Object);\n    return _insertDoc(collectionName, documentData);\n  },\n  Mongol_getCollections: function () {\n    return ToyKit.collection.getList();\n  },\n  Mongol_resetCollection: function (name) {\n    check(name, Match.Any);\n    return Mongo.Collection.get(name).remove({});\n  },\n  Mongol_resetAll: function () {\n    var collectionsList = ToyKit.collection.getList() || [];\n    return collectionsList.map(function (name) {\n      return {\n        name: name,\n        result: ToyKit.collection.get(name).remove({})\n      };\n    });\n  }\n});\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utilities.js\":function module(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/msavin_mongol/server/utilities.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.export({\n  Utilities: () => Utilities\n});\nmodule.runSetters(Utilities = {});\n\nUtilities.diffDocumentData = function (dbDoc, newData, oldData) {\n  var finalData = {};\n\n  var dbDocFields = _.keys(dbDoc);\n\n  var newDataFields = _.keys(newData);\n\n  var oldDataFields = _.keys(oldData); // console.log(\"dbDocFields\",dbDocFields); console.log(\"newDataFields\",newDataFields); console.log(\"oldDataFields\",oldDataFields);\n  // First get the set of fields that we won't be saving because they were dynamically added on the client\n\n\n  var dynamicallyAddedFields = _.difference(oldDataFields, dbDocFields); // Then get the fields that must retain their dbDoc field value, because they we'ren't published\n\n\n  var unpublishedFields = _.difference(dbDocFields, oldDataFields); // console.log(\"unpublishedFields\",unpublishedFields);\n  // iterate over all fields, old and new, and ascertain the field value that must be added to the final data object\n\n\n  var oldAndNewFields = _.union(dbDocFields, newDataFields);\n\n  _.each(oldAndNewFields, function (field) {\n    if (_.contains(dynamicallyAddedFields, field)) {\n      // We don't want to add this field to the actual mongodb document\n      // console.log(\"'\" + field + \"' appears to be a dynamically added field. This field was not updated.\");\n      return;\n    }\n\n    if (_.contains(unpublishedFields, field)) {\n      // We don't want to overwrite the existing mondodb document value\n      if (newData[field]) {// Give a message to user as to why that field wasn't updated\n        // console.log(\"'\" + field + \"' is an unpublished field. This field's value was not overwritten.\");\n      } // Make sure the old value is retained\n\n\n      finalData[field] = dbDoc[field];\n      return;\n    }\n\n    if (!_.isUndefined(newData[field])) {\n      finalData[field] = _.isObject(newData[field]) && !_.isArray(newData[field]) && !_.isDate(newData[field]) ? Mongol.diffDocumentData(dbDoc[field] || {}, newData[field], oldData[field] || {}) : newData[field];\n    } // This will let unpublished fields into the database,\n    // so the user may be confused by the lack of an update in the client\n    // simply because the added field isn't published\n    // The following solves that problem, but doesn't allow new fields to be added at all:\n    // finalData[field] = oldData[field] && newData[field];\n    // We actually need to know the set of fields published by the publication that the client side doc came from\n    // but how do we get that?\n\n  });\n\n  return finalData;\n}; // Test code for Mongol.diffDocumentData\n\n/*Meteor.startup(function() {\n\n  // Take a user document\n  var sampleDbDoc = { \"_id\" : \"exampleuser1\", \"createdAt\" : 1375253926213, \"defaultPrograms\" : { \"514d75dc97095578800\" : \"MYP\", \"515be068c708000000\" : \"PYP\" }, \"department_id\" : [  \"GMsv9YzaCuL6dFBYL\" ], \"emails\" : [  {  \"address\" : \"aaa@aaa.com\",  \"verified\" : true } ], \"myCourses\" : [  \"QqofEtQPgFb72\",  \"fvTxhAyfMxFbhzwK7\",  \"jcPtgwN6pTMQDEp\" ], \"organization_id\" : [  \"51f76bcbfb1e0d3100\" ], \"permContexts\" : [     {     \"department_id\" : \"GMsv9YzCuL6dFBYL\", \"perms\" : [     \"editRoles\",     \"editCourses\",     \"editUnits\",     \"editAssessments\",     \"editDepartments\" ] } ], \"roleContexts\" : [     {     \"organization_id\" : \"51f76bc23dfb1e0d3100\",     \"school_id\" : \"514d75d9562095578800\",     \"department_id\" : \"GMsv9YzaCuL6dFBYL\",     \"roles\" : [     \"iQD4BhnB8PFWwHCcg\" ] },     {     \"organization_id\" : \"2BjJbMyRLWa4iofQm\" } ], \"school_id\" : [  \"514d75dc97d95095578800\" ], \"services\" : { \"password\" : { \"bcrypt\" : \"$M4235dfre5.5ijyU3.ilpYZQFmtO\" }, \"resume\" : { \"loginTokens\" : [     {     \"when\" : \"2014-12-24T12:00:06.725Z\",     \"hashedToken\" : \"not/telling=\" },     {     \"when\" : \"2015-01-16T04:45:10.574Z\",     \"hashedToken\" : \"bigbadhashedtoken=\" },     {     \"when\" : \"2015-01-22T02:01:57.671Z\",     \"hashedToken\" : \"9HSC98hWA9OByHPA6LbBB8=\" } ] } }, \"superuser\" : [  \"51f76bb1e0d3100\",  \"2BjJbMyRiofQm\",  \"ZkeEcp72bAFQY\" ], \"transaction_id\" : \"shQ9fzcZYSgLLnptC\" };\n\n  // Simulate the oldData getting sent back from the client (the fields should be a subset of the db fields)\n  var sampleOldData = _.extend(_.clone(sampleDbDoc),{dynamicallyAddedField:true, secondDynamicallyAddedField: \"Dynamically added value\"}); // Simulate two dynamically added fields\n  delete sampleOldData.services; // Simulate an unpublished field\n\n  // Simulate the newData getting sent back from the client\n  // e.g. user adds a new field\n  var sampleNewData = _.extend(_.clone(sampleOldData),{brandNewField: true});\n  // brandNewField should be added\n  delete sampleNewData.createdAt; // This should be gone\n  sampleNewData.secondDynamicallyAddedField = \"Dynamically added value overwritten by user\"; // seconddynamicallyAddedField should be gone\n  sampleNewData.transaction_id = \"overwritten transaction id\"; // This field should be changed\n\n  // Run the test\n\n  console.log(Mongol.diffDocumentData(sampleDbDoc, sampleNewData, sampleOldData));\n\n});*/\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/msavin:mongol/server/main.js\");\n\n/* Exports */\nPackage._define(\"msavin:mongol\", exports);\n\n})();\n","servePath":"/packages/msavin_mongol.js","sourceMap":{"version":3,"sources":["packages/msavin:mongol/server/main.js","packages/msavin:mongol/server/methods.js","packages/msavin:mongol/server/utilities.js"],"names":["module","link","utilities","v","ToyKit","Random","_insertDoc","collectionName","documentData","newId","Collection","collection","get","_id","findOne","id","Package","simpleSchema","_c2","insert","filter","autoConvert","removeEmptyStrings","validate","Meteor","methods","Mongol_update","originalDocumentData","check","String","Object","documentID","originalID","currentDbDoc","transform","_insertdoc","updatedDocumentData","Utilities","diffDocumentData","rawCollection","update","$set","Mongol_remove","docId","skipTrashing","Match","Any","trash","Date","remove","Mongol_duplicate","Document","Mongol_insert","Mongol_getCollections","getList","Mongol_resetCollection","name","Mongo","Mongol_resetAll","collectionsList","map","result","export","dbDoc","newData","oldData","finalData","dbDocFields","_","keys","newDataFields","oldDataFields","dynamicallyAddedFields","difference","unpublishedFields","oldAndNewFields","union","each","field","contains","isUndefined","isObject","isArray","isDate","Mongol"],"mappings":"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","file":"/packages/msavin_mongol.js","sourcesContent":["import \"./methods.js\"","import { utilities } from \"./utilities.js\"\nimport { ToyKit } from \"meteor/meteortoys:toykit\";\nimport { Random } from \"meteor/random\"\nvar _insertDoc = function (collectionName, documentData) {\n\tvar newId, Collection = ToyKit.collection.get(collectionName);\n\n\tif (documentData._id && Collection.findOne(documentData._id)) {\n\t\t// console.log('Mongol: Duplicate _id found');\n\t\treturn null;\n\t}\n\n\tif (!documentData._id) {\n\t\tdocumentData._id = Random.id()\n\t}\n\n\tif (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && typeof Collection.simpleSchema === \"function\" && Collection._c2) {\n\t\treturn Collection.insert(documentData, {\n\t\t\tfilter: false,\n\t\t\tautoConvert: false,\n\t\t\tremoveEmptyStrings: false,\n\t\t\tvalidate: false\n\t\t});\n\t} else {\n\t\treturn Collection.insert(documentData);\n\t}\n}\n\n\nMeteor.methods({\n\tMongol_update: function (collectionName, documentData, originalDocumentData) {\n\t\t// console.log(arguments)\n\t\tcheck(collectionName, String);\n\t\tcheck(documentData, Object);\n\t\tcheck(originalDocumentData, Object);\n\n\t\tvar Collection = ToyKit.collection.get(collectionName),\n\t\t\tdocumentID = documentData._id,\n\t\t\toriginalID = originalDocumentData._id;\n\n\t\tvar currentDbDoc = Collection.findOne({\n\t\t\t_id: documentID\n\t\t}, {\n\t\t\ttransform: null\n\t\t});\n\t\t// console.log(currentDbDoc)\n\t\tif (!currentDbDoc) {\n\t\t\treturn _insertdoc (collectionName, documentData)\n\t\t}\n\n\t\tdelete documentData._id;\n\t\tdelete originalDocumentData._id;\n\t\tdelete currentDbDoc._id;\n\n\t\tvar updatedDocumentData = Utilities.diffDocumentData(currentDbDoc, documentData, originalDocumentData);\n\t\tdelete updatedDocumentData._id;\n\t\t// console.log(updatedDocumentData)\n\t\t// Check for packages\n\n\t\tif (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && typeof Collection.simpleSchema === \"function\" && Collection._c2) {\n\t\t\tif (typeof Collection.rawCollection) {\n\t\t\t\tCollection.rawCollection().update({\n\t\t\t\t\t_id: documentID\n\t\t\t\t}, {\n\t\t\t\t\t$set: updatedDocumentData\n\t\t\t\t}, {\n\t\t\t\t\tfilter: false,\n\t\t\t\t\tautoConvert: false,\n\t\t\t\t\tremoveEmptyStrings: false,\n\t\t\t\t\tvalidate: false\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tCollection.update({\n\t\t\t\t\t_id: documentID\n\t\t\t\t}, {\n\t\t\t\t\t$set: updatedDocumentData\n\t\t\t\t}, {\n\t\t\t\t\tfilter: false,\n\t\t\t\t\tautoConvert: false,\n\t\t\t\t\tremoveEmptyStrings: false,\n\t\t\t\t\tvalidate: false\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t\t// Run the magic\n\t\tCollection.update({\n\t\t\t_id: documentID\n\t\t}, {\n\t\t\t$set: updatedDocumentData\n\t\t});\n\t},\n\tMongol_remove: function (collectionName, docId, skipTrashing) {\n\t\t// console.log(arguments)\n\t\tcheck(collectionName, String)\n\t\tcheck(docId, String)\n\t\tcheck(skipTrashing, Match.Any)\n\n\t\t// Get Original Document\n\t\tvar Collection = ToyKit.collection.get(collectionName)\n\t\t\n\t\t// // Move document to Trash Can\n\t\tif (!skipTrashing) {\n\t\t\tvar trash  = Collection.findOne(docId, {transform: null})\n\t\t\ttrash[\"Mongol_origin\"] = String(collectionName)\n\t\t\ttrash[\"Mongol_date\"] = new Date()\n\t\t\t_insertDoc(\"MeteorToys.Mongol\", trash)\n\t\t}\n\n\t\t// remove the document\n\t\treturn Collection.remove({_id: docId})\n\t},\n\tMongol_duplicate: function (collectionName, docId) {\n\t\tcheck(collectionName, String);\n\t\tcheck(docId, String);\n\t\t// console.log(docId)\n\n\t\tvar Collection = ToyKit.collection.get(collectionName);\n\t\tvar Document = Collection.findOne(docId, {transform: null});\n\n\t\tif (Document) {\n\t\t\tdelete Document._id;\n\t\t\treturn _insertDoc(collectionName, Document);\n\t\t}\n\t},\n\tMongol_insert: function(collectionName, documentData) {\n\t\tcheck(collectionName, String);\n\t\tcheck(documentData, Object);\n\n\t\treturn _insertDoc(collectionName, documentData);\n\t},\n\tMongol_getCollections: function () {\n\t\treturn ToyKit.collection.getList();\n\t},\n\tMongol_resetCollection: function(name) {\n\t\tcheck(name, Match.Any);\n\n\t\treturn Mongo.Collection.get(name).remove({});\n\t},\n\tMongol_resetAll: function () {\n\t\tvar collectionsList = ToyKit.collection.getList() || [];\n\n\t\treturn collectionsList.map(function(name) {\n\t\t\treturn {\n\t\t\t\tname: name,\n\t\t\t\tresult: ToyKit.collection.get(name).remove({})\n\t\t\t}\n\t\t});\n\t}\n});","Utilities = {}\n\nUtilities.diffDocumentData = function (dbDoc, newData, oldData) {\n\n  var finalData = {};\n\n  var dbDocFields = _.keys(dbDoc);\n  var newDataFields = _.keys(newData);\n  var oldDataFields = _.keys(oldData); // console.log(\"dbDocFields\",dbDocFields); console.log(\"newDataFields\",newDataFields); console.log(\"oldDataFields\",oldDataFields);\n\n  // First get the set of fields that we won't be saving because they were dynamically added on the client\n\n  var dynamicallyAddedFields = _.difference(oldDataFields, dbDocFields);\n\n  // Then get the fields that must retain their dbDoc field value, because they we'ren't published\n\n  var unpublishedFields = _.difference(dbDocFields, oldDataFields); // console.log(\"unpublishedFields\",unpublishedFields);\n\n  // iterate over all fields, old and new, and ascertain the field value that must be added to the final data object\n\n  var oldAndNewFields = _.union(dbDocFields, newDataFields);\n\n  _.each(oldAndNewFields, function(field) {\n\n    if (_.contains(dynamicallyAddedFields, field)) {\n  \n      // We don't want to add this field to the actual mongodb document\n      // console.log(\"'\" + field + \"' appears to be a dynamically added field. This field was not updated.\");\n      return;\n\n    }\n\n    if (_.contains(unpublishedFields, field)) {\n\n      // We don't want to overwrite the existing mondodb document value\n      if (newData[field]) {\n        // Give a message to user as to why that field wasn't updated\n        // console.log(\"'\" + field + \"' is an unpublished field. This field's value was not overwritten.\");\n      }\n      // Make sure the old value is retained\n      finalData[field] = dbDoc[field];\n      return;\n\n    }\n\n    if (!_.isUndefined(newData[field])) {\n        \n      finalData[field] = (_.isObject(newData[field]) && !_.isArray(newData[field]) && !_.isDate(newData[field])) ? Mongol.diffDocumentData(dbDoc[field] || {}, newData[field], oldData[field] || {}) : newData[field];\n      \n    }\n\n    // This will let unpublished fields into the database,\n    // so the user may be confused by the lack of an update in the client\n    // simply because the added field isn't published\n    // The following solves that problem, but doesn't allow new fields to be added at all:\n    // finalData[field] = oldData[field] && newData[field];\n    // We actually need to know the set of fields published by the publication that the client side doc came from\n    // but how do we get that?\n\n  });\n\n  return finalData;\n\n};\n\n// Test code for Mongol.diffDocumentData\n\n/*Meteor.startup(function() {\n\n  // Take a user document\n  var sampleDbDoc = { \"_id\" : \"exampleuser1\", \"createdAt\" : 1375253926213, \"defaultPrograms\" : { \"514d75dc97095578800\" : \"MYP\", \"515be068c708000000\" : \"PYP\" }, \"department_id\" : [  \"GMsv9YzaCuL6dFBYL\" ], \"emails\" : [  {  \"address\" : \"aaa@aaa.com\",  \"verified\" : true } ], \"myCourses\" : [  \"QqofEtQPgFb72\",  \"fvTxhAyfMxFbhzwK7\",  \"jcPtgwN6pTMQDEp\" ], \"organization_id\" : [  \"51f76bcbfb1e0d3100\" ], \"permContexts\" : [     {     \"department_id\" : \"GMsv9YzCuL6dFBYL\", \"perms\" : [     \"editRoles\",     \"editCourses\",     \"editUnits\",     \"editAssessments\",     \"editDepartments\" ] } ], \"roleContexts\" : [     {     \"organization_id\" : \"51f76bc23dfb1e0d3100\",     \"school_id\" : \"514d75d9562095578800\",     \"department_id\" : \"GMsv9YzaCuL6dFBYL\",     \"roles\" : [     \"iQD4BhnB8PFWwHCcg\" ] },     {     \"organization_id\" : \"2BjJbMyRLWa4iofQm\" } ], \"school_id\" : [  \"514d75dc97d95095578800\" ], \"services\" : { \"password\" : { \"bcrypt\" : \"$M4235dfre5.5ijyU3.ilpYZQFmtO\" }, \"resume\" : { \"loginTokens\" : [     {     \"when\" : \"2014-12-24T12:00:06.725Z\",     \"hashedToken\" : \"not/telling=\" },     {     \"when\" : \"2015-01-16T04:45:10.574Z\",     \"hashedToken\" : \"bigbadhashedtoken=\" },     {     \"when\" : \"2015-01-22T02:01:57.671Z\",     \"hashedToken\" : \"9HSC98hWA9OByHPA6LbBB8=\" } ] } }, \"superuser\" : [  \"51f76bb1e0d3100\",  \"2BjJbMyRiofQm\",  \"ZkeEcp72bAFQY\" ], \"transaction_id\" : \"shQ9fzcZYSgLLnptC\" };\n\n  // Simulate the oldData getting sent back from the client (the fields should be a subset of the db fields)\n  var sampleOldData = _.extend(_.clone(sampleDbDoc),{dynamicallyAddedField:true, secondDynamicallyAddedField: \"Dynamically added value\"}); // Simulate two dynamically added fields\n  delete sampleOldData.services; // Simulate an unpublished field\n\n  // Simulate the newData getting sent back from the client\n  // e.g. user adds a new field\n  var sampleNewData = _.extend(_.clone(sampleOldData),{brandNewField: true});\n  // brandNewField should be added\n  delete sampleNewData.createdAt; // This should be gone\n  sampleNewData.secondDynamicallyAddedField = \"Dynamically added value overwritten by user\"; // seconddynamicallyAddedField should be gone\n  sampleNewData.transaction_id = \"overwritten transaction id\"; // This field should be changed\n\n  // Run the test\n\n  console.log(Mongol.diffDocumentData(sampleDbDoc, sampleNewData, sampleOldData));\n\n});*/\n\nexport { Utilities }"]}}]