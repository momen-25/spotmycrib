{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/mdg:meteor-apm-agent/lib/hijack/db.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mdg:meteor-apm-agent/lib/hijack/db.js","filename":"/home/momen/projects/spotmycrib-master/packages/mdg:meteor-apm-agent/lib/hijack/db.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/mdg:meteor-apm-agent/lib/hijack/db.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mdg:meteor-apm-agent/lib/hijack/db.js"}},"code":"let MongoConnection, MongoCursor;\nmodule.link(\"./meteorx.js\", {\n  MongoConnection(v) {\n    MongoConnection = v;\n  },\n\n  MongoCursor(v) {\n    MongoCursor = v;\n  }\n\n}, 0);\n// This hijack is important to make sure, collections created before\n// we hijack dbOps, even gets tracked.\n//  Meteor does not simply expose MongoConnection object to the client\n//  It picks methods which are necessory and make a binded object and\n//  assigned to the Mongo.Collection\n//  so, even we updated prototype, we can't track those collections\n//  but, this will fix it.\nvar originalOpen = MongoInternals.RemoteCollectionDriver.prototype.open;\n\nMongoInternals.RemoteCollectionDriver.prototype.open = function open(name) {\n  var self = this;\n  var ret = originalOpen.call(self, name);\n\n  _.each(ret, function (fn, m) {\n    // make sure, it's in the actual mongo connection object\n    // meteorhacks:mongo-collection-utils package add some arbitary methods\n    // which does not exist in the mongo connection\n    if (self.mongo[m]) {\n      ret[m] = function () {\n        Array.prototype.unshift.call(arguments, name);\n        return OptimizedApply(self.mongo, self.mongo[m], arguments);\n      };\n    }\n  });\n\n  return ret;\n};\n\nhijackDBOps = function hijackDBOps() {\n  var mongoConnectionProto = MongoConnection.prototype; //findOne is handled by find - so no need to track it\n  //upsert is handles by update\n\n  ['find', 'update', 'remove', 'insert', '_ensureIndex', '_dropIndex'].forEach(function (func) {\n    var originalFunc = mongoConnectionProto[func];\n\n    mongoConnectionProto[func] = function (collName, selector, mod, options) {\n      var payload = {\n        coll: collName,\n        func: func\n      };\n\n      if (func == 'insert') {//add nothing more to the payload\n      } else if (func == '_ensureIndex' || func == '_dropIndex') {\n        //add index\n        payload.index = JSON.stringify(selector);\n      } else if (func == 'update' && options && options.upsert) {\n        payload.func = 'upsert';\n        payload.selector = JSON.stringify(selector);\n      } else {\n        //all the other functions have selectors\n        payload.selector = JSON.stringify(selector);\n      }\n\n      var kadiraInfo = Kadira._getInfo();\n\n      if (kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n      } //this cause V8 to avoid any performance optimizations, but this is must to use\n      //otherwise, if the error adds try catch block our logs get messy and didn't work\n      //see: issue #6\n\n\n      try {\n        var ret = originalFunc.apply(this, arguments); //handling functions which can be triggered with an asyncCallback\n\n        var endOptions = {};\n\n        if (HaveAsyncCallback(arguments)) {\n          endOptions.async = true;\n        }\n\n        if (func == 'update') {\n          // upsert only returns an object when called `upsert` directly\n          // otherwise it only act an update command\n          if (options && options.upsert && typeof ret == 'object') {\n            endOptions.updatedDocs = ret.numberAffected;\n            endOptions.insertedId = ret.insertedId;\n          } else {\n            endOptions.updatedDocs = ret;\n          }\n        } else if (func == 'remove') {\n          endOptions.removedDocs = ret;\n        }\n\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\n        }\n      } catch (ex) {\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {\n            err: ex.message\n          });\n        }\n\n        throw ex;\n      }\n\n      return ret;\n    };\n  });\n  var cursorProto = MongoCursor.prototype;\n  ['forEach', 'map', 'fetch', 'count', 'observeChanges', 'observe', 'rewind'].forEach(function (type) {\n    var originalFunc = cursorProto[type];\n\n    cursorProto[type] = function () {\n      var cursorDescription = this._cursorDescription;\n      var payload = Object.assign(Object.create(null), {\n        coll: cursorDescription.collectionName,\n        selector: JSON.stringify(cursorDescription.selector),\n        func: type,\n        cursor: true\n      });\n\n      if (cursorDescription.options) {\n        var cursorOptions = _.pick(cursorDescription.options, ['fields', 'sort', 'limit']);\n\n        for (var field in cursorOptions) {\n          var value = cursorOptions[field];\n\n          if (typeof value == 'object') {\n            value = JSON.stringify(value);\n          }\n\n          payload[field] = value;\n        }\n      }\n\n      ;\n\n      var kadiraInfo = Kadira._getInfo();\n\n      if (kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n      }\n\n      try {\n        var ret = originalFunc.apply(this, arguments);\n        var endData = {};\n\n        if (type == 'observeChanges' || type == 'observe') {\n          var observerDriver;\n          endData.oplog = false; // get data written by the multiplexer\n\n          endData.wasMultiplexerReady = ret._wasMultiplexerReady;\n          endData.queueLength = ret._queueLength;\n          endData.elapsedPollingTime = ret._elapsedPollingTime;\n\n          if (ret._multiplexer) {\n            // older meteor versions done not have an _multiplexer value\n            observerDriver = ret._multiplexer._observeDriver;\n\n            if (observerDriver) {\n              observerDriver = ret._multiplexer._observeDriver;\n              var observerDriverClass = observerDriver.constructor;\n              var usesOplog = typeof observerDriverClass.cursorSupported == 'function';\n              endData.oplog = usesOplog;\n              var size = 0;\n\n              ret._multiplexer._cache.docs.forEach(function () {\n                size++;\n              });\n\n              endData.noOfCachedDocs = size; // if multiplexerWasNotReady, we need to get the time spend for the polling\n\n              if (!ret._wasMultiplexerReady) {\n                endData.initialPollingTime = observerDriver._lastPollTime;\n              }\n            }\n          }\n\n          if (!endData.oplog) {\n            // let's try to find the reason\n            var reasonInfo = Kadira.checkWhyNoOplog(cursorDescription, observerDriver);\n            endData.noOplogCode = reasonInfo.code;\n            endData.noOplogReason = reasonInfo.reason;\n            endData.noOplogSolution = reasonInfo.solution;\n          }\n        } else if (type == 'fetch' || type == 'map') {\n          //for other cursor operation\n          endData.docsFetched = ret.length;\n\n          if (type == 'fetch') {\n            var coll = cursorDescription.collectionName;\n            var query = cursorDescription.selector;\n            var opts = cursorDescription.options;\n            var docSize = Kadira.docSzCache.getSize(coll, query, opts, ret) * ret.length;\n            endData.docSize = docSize;\n\n            if (kadiraInfo) {\n              if (kadiraInfo.trace.type === 'method') {\n                Kadira.models.methods.trackDocSize(kadiraInfo.trace.name, docSize);\n              } else if (kadiraInfo.trace.type === 'sub') {\n                Kadira.models.pubsub.trackDocSize(kadiraInfo.trace.name, \"cursorFetches\", docSize);\n              }\n            } else {\n              // Fetch with no kadira info are tracked as from a null method\n              Kadira.models.methods.trackDocSize(\"<not-a-method-or-a-pub>\", docSize);\n            } // TODO: Add doc size tracking to `map` as well.\n\n          }\n        }\n\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endData);\n        }\n\n        return ret;\n      } catch (ex) {\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {\n            err: ex.message\n          });\n        }\n\n        throw ex;\n      }\n    };\n  });\n};","map":{"version":3,"sources":["packages/mdg:meteor-apm-agent/lib/hijack/db.js"],"names":["MongoConnection","MongoCursor","module","link","v","originalOpen","MongoInternals","RemoteCollectionDriver","prototype","open","name","self","ret","call","_","each","fn","m","mongo","Array","unshift","arguments","OptimizedApply","hijackDBOps","mongoConnectionProto","forEach","func","originalFunc","collName","selector","mod","options","payload","coll","index","JSON","stringify","upsert","kadiraInfo","Kadira","_getInfo","eventId","tracer","event","trace","apply","endOptions","HaveAsyncCallback","async","updatedDocs","numberAffected","insertedId","removedDocs","eventEnd","ex","err","message","cursorProto","type","cursorDescription","_cursorDescription","Object","assign","create","collectionName","cursor","cursorOptions","pick","field","value","endData","observerDriver","oplog","wasMultiplexerReady","_wasMultiplexerReady","queueLength","_queueLength","elapsedPollingTime","_elapsedPollingTime","_multiplexer","_observeDriver","observerDriverClass","constructor","usesOplog","cursorSupported","size","_cache","docs","noOfCachedDocs","initialPollingTime","_lastPollTime","reasonInfo","checkWhyNoOplog","noOplogCode","code","noOplogReason","reason","noOplogSolution","solution","docsFetched","length","query","opts","docSize","docSzCache","getSize","models","methods","trackDocSize","pubsub"],"mappings":"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","sourcesContent":["import {\n  MongoConnection,\n  MongoCursor,\n} from \"./meteorx.js\";\n\n// This hijack is important to make sure, collections created before\n// we hijack dbOps, even gets tracked.\n//  Meteor does not simply expose MongoConnection object to the client\n//  It picks methods which are necessory and make a binded object and\n//  assigned to the Mongo.Collection\n//  so, even we updated prototype, we can't track those collections\n//  but, this will fix it.\nvar originalOpen = MongoInternals.RemoteCollectionDriver.prototype.open;\nMongoInternals.RemoteCollectionDriver.prototype.open = function open(name) {\n  var self = this;\n  var ret = originalOpen.call(self, name);\n\n  _.each(ret, function(fn, m) {\n    // make sure, it's in the actual mongo connection object\n    // meteorhacks:mongo-collection-utils package add some arbitary methods\n    // which does not exist in the mongo connection\n    if(self.mongo[m]) {\n      ret[m] = function() {\n        Array.prototype.unshift.call(arguments, name);\n        return OptimizedApply(self.mongo, self.mongo[m], arguments);\n      };\n    }\n  });\n\n  return ret;\n};\n\nhijackDBOps = function hijackDBOps() {\n  var mongoConnectionProto = MongoConnection.prototype;\n  //findOne is handled by find - so no need to track it\n  //upsert is handles by update\n  ['find', 'update', 'remove', 'insert', '_ensureIndex', '_dropIndex'].forEach(function(func) {\n    var originalFunc = mongoConnectionProto[func];\n    mongoConnectionProto[func] = function(collName, selector, mod, options) {\n      var payload = {\n        coll: collName,\n        func: func,\n      };\n\n      if(func == 'insert') {\n        //add nothing more to the payload\n      } else if(func == '_ensureIndex' || func == '_dropIndex') {\n        //add index\n        payload.index = JSON.stringify(selector);\n      } else if(func == 'update' && options && options.upsert) {\n        payload.func = 'upsert';\n        payload.selector = JSON.stringify(selector);\n      } else {\n        //all the other functions have selectors\n        payload.selector = JSON.stringify(selector);\n      }\n\n      var kadiraInfo = Kadira._getInfo();\n      if(kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n      }\n\n      //this cause V8 to avoid any performance optimizations, but this is must to use\n      //otherwise, if the error adds try catch block our logs get messy and didn't work\n      //see: issue #6\n      try{\n        var ret = originalFunc.apply(this, arguments);\n        //handling functions which can be triggered with an asyncCallback\n        var endOptions = {};\n\n        if(HaveAsyncCallback(arguments)) {\n          endOptions.async = true;\n        }\n\n        if(func == 'update') {\n          // upsert only returns an object when called `upsert` directly\n          // otherwise it only act an update command\n          if(options && options.upsert && typeof ret == 'object') {\n            endOptions.updatedDocs = ret.numberAffected;\n            endOptions.insertedId = ret.insertedId;\n          } else {\n            endOptions.updatedDocs = ret;\n          }\n        } else if(func == 'remove') {\n          endOptions.removedDocs = ret;\n        }\n\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\n        }\n      } catch(ex) {\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n        }\n        throw ex;\n      }\n\n      return ret;\n    };\n  });\n\n  var cursorProto = MongoCursor.prototype;\n  ['forEach', 'map', 'fetch', 'count', 'observeChanges', 'observe', 'rewind'].forEach(function(type) {\n    var originalFunc = cursorProto[type];\n    cursorProto[type] = function() {\n      var cursorDescription = this._cursorDescription;\n      var payload = Object.assign(Object.create(null), {\n        coll: cursorDescription.collectionName,\n        selector: JSON.stringify(cursorDescription.selector),\n        func: type,\n        cursor: true\n      });\n\n      if(cursorDescription.options) {\n        var cursorOptions = _.pick(cursorDescription.options, ['fields', 'sort', 'limit']);\n        for(var field in cursorOptions) {\n          var value = cursorOptions[field]\n          if(typeof value == 'object') {\n            value = JSON.stringify(value);\n          }\n          payload[field] = value;\n        }\n      };\n\n      var kadiraInfo = Kadira._getInfo();\n      if(kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n      }\n\n      try{\n        var ret = originalFunc.apply(this, arguments);\n\n        var endData = {};\n        if(type == 'observeChanges' || type == 'observe') {\n          var observerDriver;\n          endData.oplog = false;\n          // get data written by the multiplexer\n          endData.wasMultiplexerReady = ret._wasMultiplexerReady;\n          endData.queueLength = ret._queueLength;\n          endData.elapsedPollingTime = ret._elapsedPollingTime;\n\n          if(ret._multiplexer) {\n            // older meteor versions done not have an _multiplexer value\n            observerDriver = ret._multiplexer._observeDriver;\n            if(observerDriver) {\n              observerDriver = ret._multiplexer._observeDriver;\n              var observerDriverClass = observerDriver.constructor;\n              var usesOplog = typeof observerDriverClass.cursorSupported == 'function';\n              endData.oplog = usesOplog;\n              var size = 0;\n              ret._multiplexer._cache.docs.forEach(function() {size++});\n              endData.noOfCachedDocs = size;\n\n              // if multiplexerWasNotReady, we need to get the time spend for the polling\n              if(!ret._wasMultiplexerReady) {\n                endData.initialPollingTime = observerDriver._lastPollTime;\n              }\n            }\n          }\n\n          if(!endData.oplog) {\n            // let's try to find the reason\n            var reasonInfo = Kadira.checkWhyNoOplog(cursorDescription, observerDriver);\n            endData.noOplogCode = reasonInfo.code;\n            endData.noOplogReason = reasonInfo.reason;\n            endData.noOplogSolution = reasonInfo.solution;\n          }\n        } else if(type == 'fetch' || type == 'map'){\n          //for other cursor operation\n\n          endData.docsFetched = ret.length;\n\n          if(type == 'fetch') {\n            var coll = cursorDescription.collectionName;\n            var query = cursorDescription.selector;\n            var opts = cursorDescription.options;\n            var docSize = Kadira.docSzCache.getSize(coll, query, opts, ret) * ret.length;\n            endData.docSize = docSize;\n\n            if(kadiraInfo) {\n              if(kadiraInfo.trace.type === 'method') {\n                Kadira.models.methods.trackDocSize(kadiraInfo.trace.name, docSize);\n              } else if(kadiraInfo.trace.type === 'sub') {\n                Kadira.models.pubsub.trackDocSize(kadiraInfo.trace.name, \"cursorFetches\", docSize);\n              }\n            } else {\n              // Fetch with no kadira info are tracked as from a null method\n              Kadira.models.methods.trackDocSize(\"<not-a-method-or-a-pub>\", docSize);\n            }\n\n            // TODO: Add doc size tracking to `map` as well.\n          }\n        }\n\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endData);\n        }\n        return ret;\n      } catch(ex) {\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n        }\n        throw ex;\n      }\n    };\n  });\n};\n"]},"sourceType":"module","hash":"6b05804ff8ec3d719298b4051d43b8945d112742"}
