{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/jcbernack:reactive-aggregate/aggregate.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/jcbernack:reactive-aggregate/aggregate.js","filename":"/home/momen/projects/spotmycrib-master/packages/jcbernack:reactive-aggregate/aggregate.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/jcbernack:reactive-aggregate/aggregate.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/jcbernack:reactive-aggregate/aggregate.js"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nmodule.export({\n  ReactiveAggregate: () => ReactiveAggregate\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Mongo;\nmodule.link(\"meteor/mongo\", {\n  Mongo(v) {\n    Mongo = v;\n  }\n\n}, 1);\n\nconst defaultOptions = (_ref) => {\n  let {\n    collection,\n    options\n  } = _ref;\n  return _objectSpread({\n    observeSelector: {},\n    observeOptions: {},\n    delay: 250,\n    lookupCollections: {},\n    clientCollection: collection._name\n  }, options);\n};\n\nconst ReactiveAggregate = function (subscription, collection) {\n  let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // fill out default options\n  const {\n    observeSelector,\n    observeOptions,\n    delay,\n    lookupCollections,\n    clientCollection\n  } = defaultOptions({\n    collection,\n    options\n  }); // run, or re-run, the aggregation pipeline\n\n  const throttledUpdate = _.throttle(Meteor.bindEnvironment(() => {\n    // add and update documents on the client\n    collection.aggregate(safePipeline).forEach(doc => {\n      if (!subscription._ids[doc._id]) {\n        subscription.added(clientCollection, doc._id, doc);\n      } else {\n        subscription.changed(clientCollection, doc._id, doc);\n      }\n\n      subscription._ids[doc._id] = subscription._iteration;\n    }); // remove documents not in the result anymore\n\n    _.each(subscription._ids, (iteration, key) => {\n      if (iteration != subscription._iteration) {\n        delete subscription._ids[key];\n        subscription.removed(clientCollection, key);\n      }\n    });\n\n    subscription._iteration++;\n  }), delay);\n\n  const update = () => !initializing ? throttledUpdate() : null; // don't update the subscription until __after__ the initial hydrating of our collection\n\n\n  let initializing = true; // mutate the subscription to ensure it updates as we version it\n\n  subscription._ids = {};\n  subscription._iteration = 1; // create a list of collections to watch and make sure\n  // we create a sanitized \"strings-only\" version of our pipeline\n\n  const observerHandles = [createObserver(collection, {\n    observeSelector,\n    observeOptions\n  })]; // look for $lookup collections passed in as Mongo.Collection instances\n  // and create observers for them\n  // if any $lookup.from stages are passed in as strings they will be omitted\n  // from this process. the aggregation will still work, but those collections\n  // will not force an update to this query if changed.\n\n  const safePipeline = pipeline.map(stage => {\n    if (stage.$lookup && stage.$lookup.from instanceof Mongo.Collection) {\n      const collection = stage.$lookup.from;\n      observerHandles.push(createObserver(collection, lookupCollections[collection._name]));\n      return _objectSpread(_objectSpread({}, stage), {}, {\n        $lookup: _objectSpread(_objectSpread({}, stage.$lookup), {}, {\n          from: collection._name\n        })\n      });\n    }\n\n    return stage;\n  }); // observeChanges() will immediately fire an \"added\" event for each document in the query\n  // these are skipped using the initializing flag\n\n  initializing = false; // send an initial result set to the client\n\n  update(); // mark the subscription as ready\n\n  subscription.ready(); // stop observing the cursor when the client unsubscribes\n\n  subscription.onStop(() => observerHandles.map(handle => handle.stop()));\n  /**\n  * Create observer\n  * @param {Mongo.Collection|*} collection\n  * @returns {any|*|Meteor.LiveQueryHandle} Handle\n  */\n\n  function createObserver(collection) {\n    let queryOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      observeSelector,\n      observeOptions\n    } = queryOptions;\n    const selector = observeSelector || {};\n    const options = observeOptions || {};\n    const query = collection.find(selector, options);\n    return query.observeChanges({\n      added: update,\n      changed: update,\n      removed: update,\n      error: err => {\n        throw err;\n      }\n    });\n  }\n};","map":{"version":3,"sources":["packages/jcbernack:reactive-aggregate/aggregate.js"],"names":["_objectSpread","module","link","default","v","export","ReactiveAggregate","Meteor","Mongo","defaultOptions","collection","options","observeSelector","observeOptions","delay","lookupCollections","clientCollection","_name","subscription","pipeline","throttledUpdate","_","throttle","bindEnvironment","aggregate","safePipeline","forEach","doc","_ids","_id","added","changed","_iteration","each","iteration","key","removed","update","initializing","observerHandles","createObserver","map","stage","$lookup","from","Collection","push","ready","onStop","handle","stop","queryOptions","selector","query","find","observeChanges","error","err"],"mappings":"AAAA,IAAIA,aAAJ;;AAAkBC,MAAM,CAACC,IAAP,CAAY,sCAAZ,EAAmD;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACJ,IAAAA,aAAa,GAACI,CAAd;AAAgB;;AAA5B,CAAnD,EAAiF,CAAjF;AAAlBH,MAAM,CAACI,MAAP,CAAc;AAACC,EAAAA,iBAAiB,EAAC,MAAIA;AAAvB,CAAd;AAAyD,IAAIC,MAAJ;AAAWN,MAAM,CAACC,IAAP,CAAY,eAAZ,EAA4B;AAACK,EAAAA,MAAM,CAACH,CAAD,EAAG;AAACG,IAAAA,MAAM,GAACH,CAAP;AAAS;;AAApB,CAA5B,EAAkD,CAAlD;AAAqD,IAAII,KAAJ;AAAUP,MAAM,CAACC,IAAP,CAAY,cAAZ,EAA2B;AAACM,EAAAA,KAAK,CAACJ,CAAD,EAAG;AAACI,IAAAA,KAAK,GAACJ,CAAN;AAAQ;;AAAlB,CAA3B,EAA+C,CAA/C;;AAGnI,MAAMK,cAAc,GAAG;AAAA,MAAC;AACtBC,IAAAA,UADsB;AACVC,IAAAA;AADU,GAAD;AAAA;AAGrBC,IAAAA,eAAe,EAAE,EAHI;AAIrBC,IAAAA,cAAc,EAAE,EAJK;AAKrBC,IAAAA,KAAK,EAAE,GALc;AAMrBC,IAAAA,iBAAiB,EAAE,EANE;AAOrBC,IAAAA,gBAAgB,EAAEN,UAAU,CAACO;AAPR,KAQlBN,OARkB;AAAA,CAAvB;;AAWO,MAAML,iBAAiB,GAAG,UAAUY,YAAV,EAAwBR,UAAxB,EAAiE;AAAA,MAA7BS,QAA6B,uEAAlB,EAAkB;AAAA,MAAdR,OAAc,uEAAJ,EAAI;AAChG;AACA,QAAM;AACJC,IAAAA,eADI;AACaC,IAAAA,cADb;AAC6BC,IAAAA,KAD7B;AACoCC,IAAAA,iBADpC;AACuDC,IAAAA;AADvD,MAEFP,cAAc,CAAC;AACjBC,IAAAA,UADiB;AAEjBC,IAAAA;AAFiB,GAAD,CAFlB,CAFgG,CAShG;;AACA,QAAMS,eAAe,GAAGC,CAAC,CAACC,QAAF,CAAWf,MAAM,CAACgB,eAAP,CAAuB,MAAM;AAC9D;AACAb,IAAAA,UAAU,CAACc,SAAX,CAAqBC,YAArB,EAAmCC,OAAnC,CAA4CC,GAAD,IAAS;AAClD,UAAI,CAACT,YAAY,CAACU,IAAb,CAAkBD,GAAG,CAACE,GAAtB,CAAL,EAAiC;AAC/BX,QAAAA,YAAY,CAACY,KAAb,CAAmBd,gBAAnB,EAAqCW,GAAG,CAACE,GAAzC,EAA8CF,GAA9C;AACD,OAFD,MAEO;AACLT,QAAAA,YAAY,CAACa,OAAb,CAAqBf,gBAArB,EAAuCW,GAAG,CAACE,GAA3C,EAAgDF,GAAhD;AACD;;AACDT,MAAAA,YAAY,CAACU,IAAb,CAAkBD,GAAG,CAACE,GAAtB,IAA6BX,YAAY,CAACc,UAA1C;AACD,KAPD,EAF8D,CAU9D;;AACAX,IAAAA,CAAC,CAACY,IAAF,CAAOf,YAAY,CAACU,IAApB,EAA0B,CAACM,SAAD,EAAYC,GAAZ,KAAoB;AAC5C,UAAID,SAAS,IAAIhB,YAAY,CAACc,UAA9B,EAA0C;AACxC,eAAOd,YAAY,CAACU,IAAb,CAAkBO,GAAlB,CAAP;AACAjB,QAAAA,YAAY,CAACkB,OAAb,CAAqBpB,gBAArB,EAAuCmB,GAAvC;AACD;AACF,KALD;;AAMAjB,IAAAA,YAAY,CAACc,UAAb;AACD,GAlBkC,CAAX,EAkBpBlB,KAlBoB,CAAxB;;AAmBA,QAAMuB,MAAM,GAAG,MAAM,CAACC,YAAD,GAAgBlB,eAAe,EAA/B,GAAoC,IAAzD,CA7BgG,CA+BhG;;;AACA,MAAIkB,YAAY,GAAG,IAAnB,CAhCgG,CAiChG;;AACApB,EAAAA,YAAY,CAACU,IAAb,GAAoB,EAApB;AACAV,EAAAA,YAAY,CAACc,UAAb,GAA0B,CAA1B,CAnCgG,CAqChG;AACA;;AACA,QAAMO,eAAe,GAAG,CAACC,cAAc,CAAC9B,UAAD,EAAa;AAAEE,IAAAA,eAAF;AAAmBC,IAAAA;AAAnB,GAAb,CAAf,CAAxB,CAvCgG,CAwChG;AACA;AACA;AACA;AACA;;AACA,QAAMY,YAAY,GAAGN,QAAQ,CAACsB,GAAT,CAAcC,KAAD,IAAW;AAC3C,QAAIA,KAAK,CAACC,OAAN,IAAiBD,KAAK,CAACC,OAAN,CAAcC,IAAd,YAA8BpC,KAAK,CAACqC,UAAzD,EAAqE;AACnE,YAAMnC,UAAU,GAAGgC,KAAK,CAACC,OAAN,CAAcC,IAAjC;AACAL,MAAAA,eAAe,CAACO,IAAhB,CAAqBN,cAAc,CAAC9B,UAAD,EAAaK,iBAAiB,CAACL,UAAU,CAACO,KAAZ,CAA9B,CAAnC;AACA,6CACKyB,KADL;AAEEC,QAAAA,OAAO,kCACFD,KAAK,CAACC,OADJ;AAELC,UAAAA,IAAI,EAAElC,UAAU,CAACO;AAFZ;AAFT;AAOD;;AACD,WAAOyB,KAAP;AACD,GAboB,CAArB,CA7CgG,CA4DhG;AACA;;AACAJ,EAAAA,YAAY,GAAG,KAAf,CA9DgG,CA+DhG;;AACAD,EAAAA,MAAM,GAhE0F,CAiEhG;;AACAnB,EAAAA,YAAY,CAAC6B,KAAb,GAlEgG,CAmEhG;;AACA7B,EAAAA,YAAY,CAAC8B,MAAb,CAAoB,MAAMT,eAAe,CAACE,GAAhB,CAAqBQ,MAAD,IAAYA,MAAM,CAACC,IAAP,EAAhC,CAA1B;AAEA;AACF;AACA;AACA;AACA;;AACE,WAASV,cAAT,CAAwB9B,UAAxB,EAAuD;AAAA,QAAnByC,YAAmB,uEAAJ,EAAI;AACrD,UAAM;AAAEvC,MAAAA,eAAF;AAAmBC,MAAAA;AAAnB,QAAsCsC,YAA5C;AACA,UAAMC,QAAQ,GAAGxC,eAAe,IAAI,EAApC;AACA,UAAMD,OAAO,GAAGE,cAAc,IAAI,EAAlC;AACA,UAAMwC,KAAK,GAAG3C,UAAU,CAAC4C,IAAX,CAAgBF,QAAhB,EAA0BzC,OAA1B,CAAd;AACA,WAAO0C,KAAK,CAACE,cAAN,CAAqB;AAC1BzB,MAAAA,KAAK,EAAEO,MADmB;AAE1BN,MAAAA,OAAO,EAAEM,MAFiB;AAG1BD,MAAAA,OAAO,EAAEC,MAHiB;AAI1BmB,MAAAA,KAAK,EAAGC,GAAD,IAAS;AACd,cAAMA,GAAN;AACD;AANyB,KAArB,CAAP;AAQD;AACF,CAzFM","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Mongo } from 'meteor/mongo';\n\nconst defaultOptions = ({\n  collection, options\n}) => ({\n  observeSelector: {},\n  observeOptions: {},\n  delay: 250,\n  lookupCollections: {},\n  clientCollection: collection._name,\n  ...options\n});\n\nexport const ReactiveAggregate = function (subscription, collection, pipeline = [], options = {}) {\n  // fill out default options\n  const {\n    observeSelector, observeOptions, delay, lookupCollections, clientCollection\n  } = defaultOptions({\n    collection,\n    options\n  });\n\n  // run, or re-run, the aggregation pipeline\n  const throttledUpdate = _.throttle(Meteor.bindEnvironment(() => {\n    // add and update documents on the client\n    collection.aggregate(safePipeline).forEach((doc) => {\n      if (!subscription._ids[doc._id]) {\n        subscription.added(clientCollection, doc._id, doc);\n      } else {\n        subscription.changed(clientCollection, doc._id, doc);\n      }\n      subscription._ids[doc._id] = subscription._iteration;\n    });\n    // remove documents not in the result anymore\n    _.each(subscription._ids, (iteration, key) => {\n      if (iteration != subscription._iteration) {\n        delete subscription._ids[key];\n        subscription.removed(clientCollection, key);\n      }\n    });\n    subscription._iteration++;\n  }), delay);\n  const update = () => !initializing ? throttledUpdate() : null;\n\n  // don't update the subscription until __after__ the initial hydrating of our collection\n  let initializing = true;\n  // mutate the subscription to ensure it updates as we version it\n  subscription._ids = {};\n  subscription._iteration = 1;\n\n  // create a list of collections to watch and make sure\n  // we create a sanitized \"strings-only\" version of our pipeline\n  const observerHandles = [createObserver(collection, { observeSelector, observeOptions })];\n  // look for $lookup collections passed in as Mongo.Collection instances\n  // and create observers for them\n  // if any $lookup.from stages are passed in as strings they will be omitted\n  // from this process. the aggregation will still work, but those collections\n  // will not force an update to this query if changed.\n  const safePipeline = pipeline.map((stage) => {\n    if (stage.$lookup && stage.$lookup.from instanceof Mongo.Collection) {\n      const collection = stage.$lookup.from;\n      observerHandles.push(createObserver(collection, lookupCollections[collection._name]));\n      return {\n        ...stage,\n        $lookup: {\n          ...stage.$lookup,\n          from: collection._name\n        }\n      };\n    }\n    return stage;\n  });\n\n  // observeChanges() will immediately fire an \"added\" event for each document in the query\n  // these are skipped using the initializing flag\n  initializing = false;\n  // send an initial result set to the client\n  update();\n  // mark the subscription as ready\n  subscription.ready();\n  // stop observing the cursor when the client unsubscribes\n  subscription.onStop(() => observerHandles.map((handle) => handle.stop()));\n\n  /**\n\t * Create observer\n\t * @param {Mongo.Collection|*} collection\n\t * @returns {any|*|Meteor.LiveQueryHandle} Handle\n\t */\n  function createObserver(collection, queryOptions = {}) {\n    const { observeSelector, observeOptions } = queryOptions;\n    const selector = observeSelector || {};\n    const options = observeOptions || {};\n    const query = collection.find(selector, options);\n    return query.observeChanges({\n      added: update,\n      changed: update,\n      removed: update,\n      error: (err) => {\n        throw err;\n      }\n    });\n  }\n};\n"]},"sourceType":"module","hash":"3079482fec16c1ad64c265ba60caecaf6820e9d3"}
