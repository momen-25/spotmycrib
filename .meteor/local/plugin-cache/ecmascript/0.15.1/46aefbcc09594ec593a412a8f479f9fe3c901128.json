{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/mdg:meteor-apm-agent/lib/models/pubsub.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mdg:meteor-apm-agent/lib/models/pubsub.js","filename":"/home/momen/projects/spotmycrib-master/packages/mdg:meteor-apm-agent/lib/models/pubsub.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/mdg:meteor-apm-agent/lib/models/pubsub.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mdg:meteor-apm-agent/lib/models/pubsub.js"}},"code":"let size, each, get;\nmodule.link(\"../utils.js\", {\n  size(v) {\n    size = v;\n  },\n\n  each(v) {\n    each = v;\n  },\n\n  get(v) {\n    get = v;\n  }\n\n}, 0);\n\nvar logger = Npm.require('debug')('kadira:pubsub');\n\nPubsubModel = function () {\n  this.metricsByMinute = Object.create(null);\n  this.subscriptions = Object.create(null);\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60,\n    //process traces every minute\n    maxTotalPoints: 30,\n    //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n\n  });\n  this.tracerStore.start();\n};\n\nPubsubModel.prototype._trackSub = function (session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n\n  var publication = this._getPublicationName(msg.name);\n\n  var subscriptionId = msg.id;\n\n  var timestamp = Ntp._now();\n\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication: publication,\n    params: msg.params,\n    id: msg.id\n  }; //set session startedTime\n\n  session._startTime = session._startTime || timestamp;\n};\n\nObject.assign(PubsubModel.prototype, KadiraModel.prototype);\n\nPubsubModel.prototype._trackUnsub = function (session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n\n  var publication = this._getPublicationName(sub._name);\n\n  var subscriptionId = sub._subscriptionId;\n  var subscriptionState = this.subscriptions[subscriptionId];\n  var startTime = null; //sometime, we don't have these states\n\n  if (subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    //if this is null subscription, which is started automatically\n    //hence, we don't have a state\n    startTime = session._startTime;\n  } //in case, we can't get the startTime\n\n\n  if (startTime) {\n    var timestamp = Ntp._now();\n\n    var metrics = this._getMetrics(timestamp, publication); //track the count\n\n\n    if (sub._name != null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    } //use the current date to get the lifeTime of the subscription\n\n\n    metrics.lifeTime += timestamp - startTime; //this is place we can clean the subscriptionState if exists\n\n    delete this.subscriptions[subscriptionId];\n  }\n};\n\nPubsubModel.prototype._trackReady = function (session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId); //use the current time to track the response time\n\n  var publication = this._getPublicationName(sub._name);\n\n  var subscriptionId = sub._subscriptionId;\n\n  var timestamp = Ntp._now();\n\n  var metrics = this._getMetrics(timestamp, publication);\n\n  var subscriptionState = this.subscriptions[subscriptionId];\n\n  if (subscriptionState && !subscriptionState.readyTracked) {\n    metrics.resTime += timestamp - subscriptionState.startTime;\n    subscriptionState.readyTracked = true;\n  }\n\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._trackError = function (session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId); //use the current time to track the response time\n\n  var publication = this._getPublicationName(sub._name);\n\n  var subscriptionId = sub._subscriptionId;\n\n  var timestamp = Ntp._now();\n\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.errors++;\n\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._getMetrics = function (timestamp, publication) {\n  var dateId = this._getDateId(timestamp);\n\n  if (!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: Object.create(null)\n    };\n  }\n\n  if (!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      errors: 0,\n      observerLifetime: 0,\n      polledDocuments: 0,\n      oplogUpdatedDocuments: 0,\n      oplogInsertedDocuments: 0,\n      oplogDeletedDocuments: 0,\n      initiallyAddedDocuments: 0,\n      liveAddedDocuments: 0,\n      liveChangedDocuments: 0,\n      liveRemovedDocuments: 0,\n      polledDocSize: 0,\n      fetchedDocSize: 0,\n      initiallyFetchedDocSize: 0,\n      liveFetchedDocSize: 0,\n      initiallySentMsgSize: 0,\n      liveSentMsgSize: 0\n    };\n  }\n\n  return this.metricsByMinute[dateId].pubs[publication];\n};\n\nPubsubModel.prototype._getPublicationName = function (name) {\n  return name || \"null(autopublish)\";\n};\n\nPubsubModel.prototype._getSubscriptionInfo = function () {\n  var self = this;\n  var activeSubs = Object.create(null);\n  var activeDocs = Object.create(null);\n  var totalDocsSent = Object.create(null);\n  var totalDataSent = Object.create(null);\n  var totalObservers = Object.create(null);\n  var cachedObservers = Object.create(null);\n  each(Meteor.server.sessions, session => {\n    each(session._namedSubs, countSubData);\n    each(session._universalSubs, countSubData);\n  });\n  var avgObserverReuse = Object.create(null);\n\n  _.each(totalObservers, function (value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n\n  return {\n    activeSubs: activeSubs,\n    activeDocs: activeDocs,\n    avgObserverReuse: avgObserverReuse\n  };\n\n  function countSubData(sub) {\n    var publication = self._getPublicationName(sub._name);\n\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countObservers(sub, publication);\n  }\n\n  function countSubscriptions(sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n\n  function countDocuments(sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    each(sub._documents, document => {\n      activeDocs[publication] += size(document);\n    });\n  }\n\n  function countObservers(sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n};\n\nPubsubModel.prototype.buildPayload = function (buildDetailInfo) {\n  var metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = Object.create(null);\n  var payload = {\n    pubMetrics: []\n  };\n\n  var subscriptionData = this._getSubscriptionInfo();\n\n  var activeSubs = subscriptionData.activeSubs;\n  var activeDocs = subscriptionData.activeDocs;\n  var avgObserverReuse = subscriptionData.avgObserverReuse; //to the averaging\n\n  for (var dateId in metricsByMinute) {\n    var dateMetrics = metricsByMinute[dateId]; // We need to convert startTime into actual serverTime\n\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n\n    for (var publication in metricsByMinute[dateId].pubs) {\n      var singlePubMetrics = metricsByMinute[dateId].pubs[publication]; // We only calculate resTime for new subscriptions\n\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0; // We only track lifeTime in the unsubs\n\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0; // Count the average for observer lifetime\n\n      if (singlePubMetrics.deletedObservers > 0) {\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\n      } // If there are two ore more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n\n\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  } //collect traces and send them with the payload\n\n\n  payload.pubRequests = this.tracerStore.collectTraces();\n  return payload;\n};\n\nPubsubModel.prototype.incrementHandleCount = function (trace, isCached) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(trace.name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  var session = get(Meteor.server.sessions, trace.session);\n\n  if (session) {\n    var sub = get(session._namedSubs, trace.id);\n\n    if (sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  } // not sure, we need to do this? But I don't need to break the however\n\n\n  sub = sub || {\n    _totalObservers: 0,\n    _cachedObservers: 0\n  };\n  publication.totalObservers++;\n  sub._totalObservers++;\n\n  if (isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n};\n\nPubsubModel.prototype.trackCreatedObserver = function (info) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(info.name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  publication.createdObservers++;\n};\n\nPubsubModel.prototype.trackDeletedObserver = function (info) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(info.name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  publication.deletedObservers++;\n  publication.observerLifetime += new Date().getTime() - info.startTime;\n};\n\nPubsubModel.prototype.trackDocumentChanges = function (info, op) {\n  // It's possibel that info to be null\n  // Specially when getting changes at the very begining.\n  // This may be false, but nice to have a check\n  if (!info) {\n    return;\n  }\n\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(info.name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if (op.op === \"d\") {\n    publication.oplogDeletedDocuments++;\n  } else if (op.op === \"i\") {\n    publication.oplogInsertedDocuments++;\n  } else if (op.op === \"u\") {\n    publication.oplogUpdatedDocuments++;\n  }\n};\n\nPubsubModel.prototype.trackPolledDocuments = function (info, count) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(info.name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  publication.polledDocuments += count;\n};\n\nPubsubModel.prototype.trackLiveUpdates = function (info, type, count) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(info.name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if (type === \"_addPublished\") {\n    publication.liveAddedDocuments += count;\n  } else if (type === \"_removePublished\") {\n    publication.liveRemovedDocuments += count;\n  } else if (type === \"_changePublished\") {\n    publication.liveChangedDocuments += count;\n  } else if (type === \"_initialAdds\") {\n    publication.initiallyAddedDocuments += count;\n  } else {\n    throw new Error(\"Kadira: Unknown live update type\");\n  }\n};\n\nPubsubModel.prototype.trackDocSize = function (name, type, size) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if (type === \"polledFetches\") {\n    publication.polledDocSize += size;\n  } else if (type === \"liveFetches\") {\n    publication.liveFetchedDocSize += size;\n  } else if (type === \"cursorFetches\") {\n    publication.fetchedDocSize += size;\n  } else if (type === \"initialFetches\") {\n    publication.initiallyFetchedDocSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n};\n\nPubsubModel.prototype.trackMsgSize = function (name, type, size) {\n  var timestamp = Ntp._now();\n\n  var publicationName = this._getPublicationName(name);\n\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if (type === \"liveSent\") {\n    publication.liveSentMsgSize += size;\n  } else if (type === \"initialSent\") {\n    publication.initiallySentMsgSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n};","map":{"version":3,"sources":["packages/mdg:meteor-apm-agent/lib/models/pubsub.js"],"names":["size","each","get","module","link","v","logger","Npm","require","PubsubModel","metricsByMinute","Object","create","subscriptions","tracerStore","TracerStore","interval","maxTotalPoints","archiveEvery","start","prototype","_trackSub","session","msg","id","name","params","publication","_getPublicationName","subscriptionId","timestamp","Ntp","_now","metrics","_getMetrics","subs","startTime","_startTime","assign","KadiraModel","_trackUnsub","sub","_subscriptionId","_name","subscriptionState","unsubs","lifeTime","_trackReady","trace","readyTracked","resTime","addTrace","_trackError","errors","dateId","_getDateId","pubs","activeSubs","activeDocs","totalObservers","cachedObservers","createdObservers","deletedObservers","observerLifetime","polledDocuments","oplogUpdatedDocuments","oplogInsertedDocuments","oplogDeletedDocuments","initiallyAddedDocuments","liveAddedDocuments","liveChangedDocuments","liveRemovedDocuments","polledDocSize","fetchedDocSize","initiallyFetchedDocSize","liveFetchedDocSize","initiallySentMsgSize","liveSentMsgSize","_getSubscriptionInfo","self","totalDocsSent","totalDataSent","Meteor","server","sessions","_namedSubs","countSubData","_universalSubs","avgObserverReuse","_","value","countSubscriptions","countDocuments","countObservers","_documents","document","_totalObservers","_cachedObservers","buildPayload","buildDetailInfo","payload","pubMetrics","subscriptionData","dateMetrics","Kadira","syncedDate","syncTime","singlePubMetrics","push","pubRequests","collectTraces","incrementHandleCount","isCached","publicationName","trackCreatedObserver","info","trackDeletedObserver","Date","getTime","trackDocumentChanges","op","trackPolledDocuments","count","trackLiveUpdates","type","Error","trackDocSize","trackMsgSize"],"mappings":"AAAA,IAAIA,IAAJ,EAASC,IAAT,EAAcC,GAAd;AAAkBC,MAAM,CAACC,IAAP,CAAY,aAAZ,EAA0B;AAACJ,EAAAA,IAAI,CAACK,CAAD,EAAG;AAACL,IAAAA,IAAI,GAACK,CAAL;AAAO,GAAhB;;AAAiBJ,EAAAA,IAAI,CAACI,CAAD,EAAG;AAACJ,IAAAA,IAAI,GAACI,CAAL;AAAO,GAAhC;;AAAiCH,EAAAA,GAAG,CAACG,CAAD,EAAG;AAACH,IAAAA,GAAG,GAACG,CAAJ;AAAM;;AAA9C,CAA1B,EAA0E,CAA1E;;AAAlB,IAAIC,MAAM,GAAGC,GAAG,CAACC,OAAJ,CAAY,OAAZ,EAAqB,eAArB,CAAb;;AAIAC,WAAW,GAAG,YAAW;AACvB,OAAKC,eAAL,GAAuBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAvB;AACA,OAAKC,aAAL,GAAqBF,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB;AAEA,OAAKE,WAAL,GAAmB,IAAIC,WAAJ,CAAgB;AACjCC,IAAAA,QAAQ,EAAE,OAAO,EADgB;AACZ;AACrBC,IAAAA,cAAc,EAAE,EAFiB;AAEb;AACpBC,IAAAA,YAAY,EAAE,CAHmB,CAGjB;;AAHiB,GAAhB,CAAnB;AAMA,OAAKJ,WAAL,CAAiBK,KAAjB;AACD,CAXD;;AAaAV,WAAW,CAACW,SAAZ,CAAsBC,SAAtB,GAAkC,UAASC,OAAT,EAAkBC,GAAlB,EAAuB;AACvDjB,EAAAA,MAAM,CAAC,MAAD,EAASgB,OAAO,CAACE,EAAjB,EAAqBD,GAAG,CAACC,EAAzB,EAA6BD,GAAG,CAACE,IAAjC,EAAuCF,GAAG,CAACG,MAA3C,CAAN;;AACA,MAAIC,WAAW,GAAG,KAAKC,mBAAL,CAAyBL,GAAG,CAACE,IAA7B,CAAlB;;AACA,MAAII,cAAc,GAAGN,GAAG,CAACC,EAAzB;;AACA,MAAIM,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIC,OAAO,GAAG,KAAKC,WAAL,CAAiBJ,SAAjB,EAA4BH,WAA5B,CAAd;;AAEAM,EAAAA,OAAO,CAACE,IAAR;AACA,OAAKtB,aAAL,CAAmBU,GAAG,CAACC,EAAvB,IAA6B;AAC3B;AACA;AACA;AACAY,IAAAA,SAAS,EAAEN,SAJgB;AAK3BH,IAAAA,WAAW,EAAEA,WALc;AAM3BD,IAAAA,MAAM,EAAEH,GAAG,CAACG,MANe;AAO3BF,IAAAA,EAAE,EAAED,GAAG,CAACC;AAPmB,GAA7B,CARuD,CAkBvD;;AACAF,EAAAA,OAAO,CAACe,UAAR,GAAqBf,OAAO,CAACe,UAAR,IAAsBP,SAA3C;AACD,CApBD;;AAsBAnB,MAAM,CAAC2B,MAAP,CAAc7B,WAAW,CAACW,SAA1B,EAAqCmB,WAAW,CAACnB,SAAjD;;AAEAX,WAAW,CAACW,SAAZ,CAAsBoB,WAAtB,GAAoC,UAASlB,OAAT,EAAkBmB,GAAlB,EAAuB;AACzDnC,EAAAA,MAAM,CAAC,QAAD,EAAWgB,OAAO,CAACE,EAAnB,EAAuBiB,GAAG,CAACC,eAA3B,CAAN;;AACA,MAAIf,WAAW,GAAG,KAAKC,mBAAL,CAAyBa,GAAG,CAACE,KAA7B,CAAlB;;AACA,MAAId,cAAc,GAAGY,GAAG,CAACC,eAAzB;AACA,MAAIE,iBAAiB,GAAG,KAAK/B,aAAL,CAAmBgB,cAAnB,CAAxB;AAEA,MAAIO,SAAS,GAAG,IAAhB,CANyD,CAOzD;;AACA,MAAGQ,iBAAH,EAAsB;AACpBR,IAAAA,SAAS,GAAGQ,iBAAiB,CAACR,SAA9B;AACD,GAFD,MAEO;AACL;AACA;AACAA,IAAAA,SAAS,GAAGd,OAAO,CAACe,UAApB;AACD,GAdwD,CAgBzD;;;AACA,MAAGD,SAAH,EAAc;AACZ,QAAIN,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,QAAIC,OAAO,GAAG,KAAKC,WAAL,CAAiBJ,SAAjB,EAA4BH,WAA5B,CAAd,CAFY,CAGZ;;;AACA,QAAGc,GAAG,CAACE,KAAJ,IAAa,IAAhB,EAAsB;AACpB;AACA;AACAV,MAAAA,OAAO,CAACY,MAAR;AACD,KARW,CASZ;;;AACAZ,IAAAA,OAAO,CAACa,QAAR,IAAoBhB,SAAS,GAAGM,SAAhC,CAVY,CAWZ;;AACA,WAAO,KAAKvB,aAAL,CAAmBgB,cAAnB,CAAP;AACD;AACF,CA/BD;;AAiCApB,WAAW,CAACW,SAAZ,CAAsB2B,WAAtB,GAAoC,UAASzB,OAAT,EAAkBmB,GAAlB,EAAuBO,KAAvB,EAA8B;AAChE1C,EAAAA,MAAM,CAAC,QAAD,EAAWgB,OAAO,CAACE,EAAnB,EAAuBiB,GAAG,CAACC,eAA3B,CAAN,CADgE,CAEhE;;AACA,MAAIf,WAAW,GAAG,KAAKC,mBAAL,CAAyBa,GAAG,CAACE,KAA7B,CAAlB;;AACA,MAAId,cAAc,GAAGY,GAAG,CAACC,eAAzB;;AACA,MAAIZ,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIC,OAAO,GAAG,KAAKC,WAAL,CAAiBJ,SAAjB,EAA4BH,WAA5B,CAAd;;AAEA,MAAIiB,iBAAiB,GAAG,KAAK/B,aAAL,CAAmBgB,cAAnB,CAAxB;;AACA,MAAGe,iBAAiB,IAAI,CAACA,iBAAiB,CAACK,YAA3C,EAAyD;AACvDhB,IAAAA,OAAO,CAACiB,OAAR,IAAmBpB,SAAS,GAAGc,iBAAiB,CAACR,SAAjD;AACAQ,IAAAA,iBAAiB,CAACK,YAAlB,GAAiC,IAAjC;AACD;;AAED,MAAGD,KAAH,EAAU;AACR,SAAKlC,WAAL,CAAiBqC,QAAjB,CAA0BH,KAA1B;AACD;AACF,CAjBD;;AAmBAvC,WAAW,CAACW,SAAZ,CAAsBgC,WAAtB,GAAoC,UAAS9B,OAAT,EAAkBmB,GAAlB,EAAuBO,KAAvB,EAA8B;AAChE1C,EAAAA,MAAM,CAAC,QAAD,EAAWgB,OAAO,CAACE,EAAnB,EAAuBiB,GAAG,CAACC,eAA3B,CAAN,CADgE,CAEhE;;AACA,MAAIf,WAAW,GAAG,KAAKC,mBAAL,CAAyBa,GAAG,CAACE,KAA7B,CAAlB;;AACA,MAAId,cAAc,GAAGY,GAAG,CAACC,eAAzB;;AACA,MAAIZ,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIC,OAAO,GAAG,KAAKC,WAAL,CAAiBJ,SAAjB,EAA4BH,WAA5B,CAAd;;AAEAM,EAAAA,OAAO,CAACoB,MAAR;;AAEA,MAAGL,KAAH,EAAU;AACR,SAAKlC,WAAL,CAAiBqC,QAAjB,CAA0BH,KAA1B;AACD;AACF,CAbD;;AAeAvC,WAAW,CAACW,SAAZ,CAAsBc,WAAtB,GAAoC,UAASJ,SAAT,EAAoBH,WAApB,EAAiC;AACnE,MAAI2B,MAAM,GAAG,KAAKC,UAAL,CAAgBzB,SAAhB,CAAb;;AAEA,MAAG,CAAC,KAAKpB,eAAL,CAAqB4C,MAArB,CAAJ,EAAkC;AAChC,SAAK5C,eAAL,CAAqB4C,MAArB,IAA+B;AAC7B;AACAlB,MAAAA,SAAS,EAAEN,SAFkB;AAG7B0B,MAAAA,IAAI,EAAE7C,MAAM,CAACC,MAAP,CAAc,IAAd;AAHuB,KAA/B;AAKD;;AAED,MAAG,CAAC,KAAKF,eAAL,CAAqB4C,MAArB,EAA6BE,IAA7B,CAAkC7B,WAAlC,CAAJ,EAAoD;AAClD,SAAKjB,eAAL,CAAqB4C,MAArB,EAA6BE,IAA7B,CAAkC7B,WAAlC,IAAiD;AAC/CQ,MAAAA,IAAI,EAAE,CADyC;AAE/CU,MAAAA,MAAM,EAAE,CAFuC;AAG/CK,MAAAA,OAAO,EAAE,CAHsC;AAI/CO,MAAAA,UAAU,EAAE,CAJmC;AAK/CC,MAAAA,UAAU,EAAE,CALmC;AAM/CZ,MAAAA,QAAQ,EAAE,CANqC;AAO/Ca,MAAAA,cAAc,EAAE,CAP+B;AAQ/CC,MAAAA,eAAe,EAAE,CAR8B;AAS/CC,MAAAA,gBAAgB,EAAE,CAT6B;AAU/CC,MAAAA,gBAAgB,EAAE,CAV6B;AAW/CT,MAAAA,MAAM,EAAE,CAXuC;AAY/CU,MAAAA,gBAAgB,EAAE,CAZ6B;AAa/CC,MAAAA,eAAe,EAAE,CAb8B;AAc/CC,MAAAA,qBAAqB,EAAE,CAdwB;AAe/CC,MAAAA,sBAAsB,EAAE,CAfuB;AAgB/CC,MAAAA,qBAAqB,EAAE,CAhBwB;AAiB/CC,MAAAA,uBAAuB,EAAE,CAjBsB;AAkB/CC,MAAAA,kBAAkB,EAAE,CAlB2B;AAmB/CC,MAAAA,oBAAoB,EAAE,CAnByB;AAoB/CC,MAAAA,oBAAoB,EAAE,CApByB;AAqB/CC,MAAAA,aAAa,EAAE,CArBgC;AAsB/CC,MAAAA,cAAc,EAAE,CAtB+B;AAuB/CC,MAAAA,uBAAuB,EAAE,CAvBsB;AAwB/CC,MAAAA,kBAAkB,EAAE,CAxB2B;AAyB/CC,MAAAA,oBAAoB,EAAE,CAzByB;AA0B/CC,MAAAA,eAAe,EAAE;AA1B8B,KAAjD;AA4BD;;AAED,SAAO,KAAKnE,eAAL,CAAqB4C,MAArB,EAA6BE,IAA7B,CAAkC7B,WAAlC,CAAP;AACD,CA3CD;;AA6CAlB,WAAW,CAACW,SAAZ,CAAsBQ,mBAAtB,GAA4C,UAASH,IAAT,EAAe;AACzD,SAAOA,IAAI,IAAI,mBAAf;AACD,CAFD;;AAIAhB,WAAW,CAACW,SAAZ,CAAsB0D,oBAAtB,GAA6C,YAAW;AACtD,MAAIC,IAAI,GAAG,IAAX;AACA,MAAItB,UAAU,GAAG9C,MAAM,CAACC,MAAP,CAAc,IAAd,CAAjB;AACA,MAAI8C,UAAU,GAAG/C,MAAM,CAACC,MAAP,CAAc,IAAd,CAAjB;AACA,MAAIoE,aAAa,GAAGrE,MAAM,CAACC,MAAP,CAAc,IAAd,CAApB;AACA,MAAIqE,aAAa,GAAGtE,MAAM,CAACC,MAAP,CAAc,IAAd,CAApB;AACA,MAAI+C,cAAc,GAAGhD,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB;AACA,MAAIgD,eAAe,GAAGjD,MAAM,CAACC,MAAP,CAAc,IAAd,CAAtB;AAEAX,EAAAA,IAAI,CAACiF,MAAM,CAACC,MAAP,CAAcC,QAAf,EAAyB9D,OAAO,IAAI;AACtCrB,IAAAA,IAAI,CAACqB,OAAO,CAAC+D,UAAT,EAAqBC,YAArB,CAAJ;AACArF,IAAAA,IAAI,CAACqB,OAAO,CAACiE,cAAT,EAAyBD,YAAzB,CAAJ;AACD,GAHG,CAAJ;AAKA,MAAIE,gBAAgB,GAAG7E,MAAM,CAACC,MAAP,CAAc,IAAd,CAAvB;;AACA6E,EAAAA,CAAC,CAACxF,IAAF,CAAO0D,cAAP,EAAuB,UAAS+B,KAAT,EAAgB/D,WAAhB,EAA6B;AAClD6D,IAAAA,gBAAgB,CAAC7D,WAAD,CAAhB,GAAgCiC,eAAe,CAACjC,WAAD,CAAf,GAA+BgC,cAAc,CAAChC,WAAD,CAA7E;AACD,GAFD;;AAIA,SAAO;AACL8B,IAAAA,UAAU,EAAEA,UADP;AAELC,IAAAA,UAAU,EAAEA,UAFP;AAGL8B,IAAAA,gBAAgB,EAAEA;AAHb,GAAP;;AAMA,WAASF,YAAT,CAAuB7C,GAAvB,EAA4B;AAC1B,QAAId,WAAW,GAAGoD,IAAI,CAACnD,mBAAL,CAAyBa,GAAG,CAACE,KAA7B,CAAlB;;AACAgD,IAAAA,kBAAkB,CAAClD,GAAD,EAAMd,WAAN,CAAlB;AACAiE,IAAAA,cAAc,CAACnD,GAAD,EAAMd,WAAN,CAAd;AACAkE,IAAAA,cAAc,CAACpD,GAAD,EAAMd,WAAN,CAAd;AACD;;AAED,WAASgE,kBAAT,CAA6BlD,GAA7B,EAAkCd,WAAlC,EAA+C;AAC7C8B,IAAAA,UAAU,CAAC9B,WAAD,CAAV,GAA0B8B,UAAU,CAAC9B,WAAD,CAAV,IAA2B,CAArD;AACA8B,IAAAA,UAAU,CAAC9B,WAAD,CAAV;AACD;;AAED,WAASiE,cAAT,CAAyBnD,GAAzB,EAA8Bd,WAA9B,EAA2C;AACzC+B,IAAAA,UAAU,CAAC/B,WAAD,CAAV,GAA0B+B,UAAU,CAAC/B,WAAD,CAAV,IAA2B,CAArD;AACA1B,IAAAA,IAAI,CAACwC,GAAG,CAACqD,UAAL,EAAiBC,QAAQ,IAAI;AAC/BrC,MAAAA,UAAU,CAAC/B,WAAD,CAAV,IAA2B3B,IAAI,CAAC+F,QAAD,CAA/B;AACD,KAFG,CAAJ;AAGD;;AAED,WAASF,cAAT,CAAwBpD,GAAxB,EAA6Bd,WAA7B,EAA0C;AACxCgC,IAAAA,cAAc,CAAChC,WAAD,CAAd,GAA8BgC,cAAc,CAAChC,WAAD,CAAd,IAA+B,CAA7D;AACAiC,IAAAA,eAAe,CAACjC,WAAD,CAAf,GAA+BiC,eAAe,CAACjC,WAAD,CAAf,IAAgC,CAA/D;AAEAgC,IAAAA,cAAc,CAAChC,WAAD,CAAd,IAA+Bc,GAAG,CAACuD,eAAnC;AACApC,IAAAA,eAAe,CAACjC,WAAD,CAAf,IAAgCc,GAAG,CAACwD,gBAApC;AACD;AACF,CAnDD;;AAqDAxF,WAAW,CAACW,SAAZ,CAAsB8E,YAAtB,GAAqC,UAASC,eAAT,EAA0B;AAC7D,MAAIzF,eAAe,GAAG,KAAKA,eAA3B;AACA,OAAKA,eAAL,GAAuBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAvB;AAEA,MAAIwF,OAAO,GAAG;AACZC,IAAAA,UAAU,EAAE;AADA,GAAd;;AAIA,MAAIC,gBAAgB,GAAG,KAAKxB,oBAAL,EAAvB;;AACA,MAAIrB,UAAU,GAAG6C,gBAAgB,CAAC7C,UAAlC;AACA,MAAIC,UAAU,GAAG4C,gBAAgB,CAAC5C,UAAlC;AACA,MAAI8B,gBAAgB,GAAGc,gBAAgB,CAACd,gBAAxC,CAX6D,CAa7D;;AACA,OAAI,IAAIlC,MAAR,IAAkB5C,eAAlB,EAAmC;AACjC,QAAI6F,WAAW,GAAG7F,eAAe,CAAC4C,MAAD,CAAjC,CADiC,CAEjC;;AACAiD,IAAAA,WAAW,CAACnE,SAAZ,GAAwBoE,MAAM,CAACC,UAAP,CAAkBC,QAAlB,CAA2BH,WAAW,CAACnE,SAAvC,CAAxB;;AAEA,SAAI,IAAIT,WAAR,IAAuBjB,eAAe,CAAC4C,MAAD,CAAf,CAAwBE,IAA/C,EAAqD;AACnD,UAAImD,gBAAgB,GAAGjG,eAAe,CAAC4C,MAAD,CAAf,CAAwBE,IAAxB,CAA6B7B,WAA7B,CAAvB,CADmD,CAEnD;;AACAgF,MAAAA,gBAAgB,CAACzD,OAAjB,IAA4ByD,gBAAgB,CAACxE,IAA7C;AACAwE,MAAAA,gBAAgB,CAACzD,OAAjB,GAA2ByD,gBAAgB,CAACzD,OAAjB,IAA4B,CAAvD,CAJmD,CAKnD;;AACAyD,MAAAA,gBAAgB,CAAC7D,QAAjB,IAA6B6D,gBAAgB,CAAC9D,MAA9C;AACA8D,MAAAA,gBAAgB,CAAC7D,QAAjB,GAA4B6D,gBAAgB,CAAC7D,QAAjB,IAA6B,CAAzD,CAPmD,CASnD;;AACA,UAAG6D,gBAAgB,CAAC7C,gBAAjB,GAAoC,CAAvC,EAA0C;AACxC6C,QAAAA,gBAAgB,CAAC5C,gBAAjB,IAAqC4C,gBAAgB,CAAC7C,gBAAtD;AACD,OAZkD,CAcnD;AACA;;;AACA6C,MAAAA,gBAAgB,CAAClD,UAAjB,GAA8BA,UAAU,CAAC9B,WAAD,CAAV,IAA2B,CAAzD;AACAgF,MAAAA,gBAAgB,CAACjD,UAAjB,GAA8BA,UAAU,CAAC/B,WAAD,CAAV,IAA2B,CAAzD;AACAgF,MAAAA,gBAAgB,CAACnB,gBAAjB,GAAoCA,gBAAgB,CAAC7D,WAAD,CAAhB,IAAiC,CAArE;AACD;;AAEDyE,IAAAA,OAAO,CAACC,UAAR,CAAmBO,IAAnB,CAAwBlG,eAAe,CAAC4C,MAAD,CAAvC;AACD,GAzC4D,CA2C7D;;;AACA8C,EAAAA,OAAO,CAACS,WAAR,GAAsB,KAAK/F,WAAL,CAAiBgG,aAAjB,EAAtB;AAEA,SAAOV,OAAP;AACD,CA/CD;;AAiDA3F,WAAW,CAACW,SAAZ,CAAsB2F,oBAAtB,GAA6C,UAAS/D,KAAT,EAAgBgE,QAAhB,EAA0B;AACrE,MAAIlF,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBoB,KAAK,CAACvB,IAA/B,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AAEA,MAAI3F,OAAO,GAAGpB,GAAG,CAACgF,MAAM,CAACC,MAAP,CAAcC,QAAf,EAAyBpC,KAAK,CAAC1B,OAA/B,CAAjB;;AACA,MAAIA,OAAJ,EAAa;AACX,QAAImB,GAAG,GAAGvC,GAAG,CAACoB,OAAO,CAAC+D,UAAT,EAAqBrC,KAAK,CAACxB,EAA3B,CAAb;;AACA,QAAIiB,GAAJ,EAAS;AACPA,MAAAA,GAAG,CAACuD,eAAJ,GAAsBvD,GAAG,CAACuD,eAAJ,IAAuB,CAA7C;AACAvD,MAAAA,GAAG,CAACwD,gBAAJ,GAAuBxD,GAAG,CAACwD,gBAAJ,IAAwB,CAA/C;AACD;AACF,GAZoE,CAarE;;;AACAxD,EAAAA,GAAG,GAAGA,GAAG,IAAI;AAACuD,IAAAA,eAAe,EAAC,CAAjB;AAAqBC,IAAAA,gBAAgB,EAAE;AAAvC,GAAb;AAEAtE,EAAAA,WAAW,CAACgC,cAAZ;AACAlB,EAAAA,GAAG,CAACuD,eAAJ;;AACA,MAAGgB,QAAH,EAAa;AACXrF,IAAAA,WAAW,CAACiC,eAAZ;AACAnB,IAAAA,GAAG,CAACwD,gBAAJ;AACD;AACF,CAtBD;;AAwBAxF,WAAW,CAACW,SAAZ,CAAsB8F,oBAAtB,GAA6C,UAASC,IAAT,EAAe;AAC1D,MAAIrF,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBuF,IAAI,CAAC1F,IAA9B,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AACAtF,EAAAA,WAAW,CAACkC,gBAAZ;AACD,CALD;;AAOApD,WAAW,CAACW,SAAZ,CAAsBgG,oBAAtB,GAA6C,UAASD,IAAT,EAAe;AAC1D,MAAIrF,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBuF,IAAI,CAAC1F,IAA9B,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AACAtF,EAAAA,WAAW,CAACmC,gBAAZ;AACAnC,EAAAA,WAAW,CAACoC,gBAAZ,IAAiC,IAAIsD,IAAJ,EAAD,CAAaC,OAAb,KAAyBH,IAAI,CAAC/E,SAA9D;AACD,CAND;;AAQA3B,WAAW,CAACW,SAAZ,CAAsBmG,oBAAtB,GAA6C,UAASJ,IAAT,EAAeK,EAAf,EAAmB;AAC9D;AACA;AACA;AACA,MAAG,CAACL,IAAJ,EAAU;AACR;AACD;;AAED,MAAIrF,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBuF,IAAI,CAAC1F,IAA9B,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AACA,MAAGO,EAAE,CAACA,EAAH,KAAU,GAAb,EAAkB;AAChB7F,IAAAA,WAAW,CAACwC,qBAAZ;AACD,GAFD,MAEO,IAAGqD,EAAE,CAACA,EAAH,KAAU,GAAb,EAAkB;AACvB7F,IAAAA,WAAW,CAACuC,sBAAZ;AACD,GAFM,MAEA,IAAGsD,EAAE,CAACA,EAAH,KAAU,GAAb,EAAkB;AACvB7F,IAAAA,WAAW,CAACsC,qBAAZ;AACD;AACF,CAlBD;;AAoBAxD,WAAW,CAACW,SAAZ,CAAsBqG,oBAAtB,GAA6C,UAASN,IAAT,EAAeO,KAAf,EAAsB;AACjE,MAAI5F,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBuF,IAAI,CAAC1F,IAA9B,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AACAtF,EAAAA,WAAW,CAACqC,eAAZ,IAA+B0D,KAA/B;AACD,CALD;;AAOAjH,WAAW,CAACW,SAAZ,CAAsBuG,gBAAtB,GAAyC,UAASR,IAAT,EAAeS,IAAf,EAAqBF,KAArB,EAA4B;AACnE,MAAI5F,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBuF,IAAI,CAAC1F,IAA9B,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AAEA,MAAGW,IAAI,KAAK,eAAZ,EAA6B;AAC3BjG,IAAAA,WAAW,CAAC0C,kBAAZ,IAAkCqD,KAAlC;AACD,GAFD,MAEO,IAAGE,IAAI,KAAK,kBAAZ,EAAgC;AACrCjG,IAAAA,WAAW,CAAC4C,oBAAZ,IAAoCmD,KAApC;AACD,GAFM,MAEA,IAAGE,IAAI,KAAK,kBAAZ,EAAgC;AACrCjG,IAAAA,WAAW,CAAC2C,oBAAZ,IAAoCoD,KAApC;AACD,GAFM,MAEA,IAAGE,IAAI,KAAK,cAAZ,EAA4B;AACjCjG,IAAAA,WAAW,CAACyC,uBAAZ,IAAuCsD,KAAvC;AACD,GAFM,MAEA;AACL,UAAM,IAAIG,KAAJ,CAAU,kCAAV,CAAN;AACD;AACF,CAhBD;;AAkBApH,WAAW,CAACW,SAAZ,CAAsB0G,YAAtB,GAAqC,UAASrG,IAAT,EAAemG,IAAf,EAAqB5H,IAArB,EAA2B;AAC9D,MAAI8B,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBH,IAAzB,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AAEA,MAAGW,IAAI,KAAK,eAAZ,EAA6B;AAC3BjG,IAAAA,WAAW,CAAC6C,aAAZ,IAA6BxE,IAA7B;AACD,GAFD,MAEO,IAAG4H,IAAI,KAAK,aAAZ,EAA2B;AAChCjG,IAAAA,WAAW,CAACgD,kBAAZ,IAAkC3E,IAAlC;AACD,GAFM,MAEA,IAAG4H,IAAI,KAAK,eAAZ,EAA6B;AAClCjG,IAAAA,WAAW,CAAC8C,cAAZ,IAA8BzE,IAA9B;AACD,GAFM,MAEA,IAAG4H,IAAI,KAAK,gBAAZ,EAA8B;AACnCjG,IAAAA,WAAW,CAAC+C,uBAAZ,IAAuC1E,IAAvC;AACD,GAFM,MAEA;AACL,UAAM,IAAI6H,KAAJ,CAAU,mCAAV,CAAN;AACD;AACF,CAhBD;;AAkBApH,WAAW,CAACW,SAAZ,CAAsB2G,YAAtB,GAAqC,UAAStG,IAAT,EAAemG,IAAf,EAAqB5H,IAArB,EAA2B;AAC9D,MAAI8B,SAAS,GAAGC,GAAG,CAACC,IAAJ,EAAhB;;AACA,MAAIiF,eAAe,GAAG,KAAKrF,mBAAL,CAAyBH,IAAzB,CAAtB;;AACA,MAAIE,WAAW,GAAG,KAAKO,WAAL,CAAiBJ,SAAjB,EAA4BmF,eAA5B,CAAlB;;AAEA,MAAGW,IAAI,KAAK,UAAZ,EAAwB;AACtBjG,IAAAA,WAAW,CAACkD,eAAZ,IAA+B7E,IAA/B;AACD,GAFD,MAEO,IAAG4H,IAAI,KAAK,aAAZ,EAA2B;AAChCjG,IAAAA,WAAW,CAACiD,oBAAZ,IAAoC5E,IAApC;AACD,GAFM,MAEA;AACL,UAAM,IAAI6H,KAAJ,CAAU,mCAAV,CAAN;AACD;AACF,CAZD","sourcesContent":["var logger = Npm.require('debug')('kadira:pubsub');\n\nimport { size, each, get } from \"../utils.js\";\n\nPubsubModel = function() {\n  this.metricsByMinute = Object.create(null);\n  this.subscriptions = Object.create(null);\n\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60, //process traces every minute\n    maxTotalPoints: 30, //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n  });\n\n  this.tracerStore.start();\n}\n\nPubsubModel.prototype._trackSub = function(session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n  var publication = this._getPublicationName(msg.name);\n  var subscriptionId = msg.id;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication: publication,\n    params: msg.params,\n    id: msg.id\n  };\n\n  //set session startedTime\n  session._startTime = session._startTime || timestamp;\n};\n\nObject.assign(PubsubModel.prototype, KadiraModel.prototype);\n\nPubsubModel.prototype._trackUnsub = function(session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var subscriptionState = this.subscriptions[subscriptionId];\n\n  var startTime = null;\n  //sometime, we don't have these states\n  if(subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    //if this is null subscription, which is started automatically\n    //hence, we don't have a state\n    startTime = session._startTime;\n  }\n\n  //in case, we can't get the startTime\n  if(startTime) {\n    var timestamp = Ntp._now();\n    var metrics = this._getMetrics(timestamp, publication);\n    //track the count\n    if(sub._name != null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    }\n    //use the current date to get the lifeTime of the subscription\n    metrics.lifeTime += timestamp - startTime;\n    //this is place we can clean the subscriptionState if exists\n    delete this.subscriptions[subscriptionId];\n  }\n};\n\nPubsubModel.prototype._trackReady = function(session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  var subscriptionState = this.subscriptions[subscriptionId];\n  if(subscriptionState && !subscriptionState.readyTracked) {\n    metrics.resTime += timestamp - subscriptionState.startTime;\n    subscriptionState.readyTracked = true;\n  }\n\n  if(trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._trackError = function(session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.errors++;\n\n  if(trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._getMetrics = function(timestamp, publication) {\n  var dateId = this._getDateId(timestamp);\n\n  if(!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: Object.create(null)\n    };\n  }\n\n  if(!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      errors: 0,\n      observerLifetime: 0,\n      polledDocuments: 0,\n      oplogUpdatedDocuments: 0,\n      oplogInsertedDocuments: 0,\n      oplogDeletedDocuments: 0,\n      initiallyAddedDocuments: 0,\n      liveAddedDocuments: 0,\n      liveChangedDocuments: 0,\n      liveRemovedDocuments: 0,\n      polledDocSize: 0,\n      fetchedDocSize: 0,\n      initiallyFetchedDocSize: 0,\n      liveFetchedDocSize: 0,\n      initiallySentMsgSize: 0,\n      liveSentMsgSize: 0\n    };\n  }\n\n  return this.metricsByMinute[dateId].pubs[publication];\n};\n\nPubsubModel.prototype._getPublicationName = function(name) {\n  return name || \"null(autopublish)\";\n};\n\nPubsubModel.prototype._getSubscriptionInfo = function() {\n  var self = this;\n  var activeSubs = Object.create(null);\n  var activeDocs = Object.create(null);\n  var totalDocsSent = Object.create(null);\n  var totalDataSent = Object.create(null);\n  var totalObservers = Object.create(null);\n  var cachedObservers = Object.create(null);\n\n  each(Meteor.server.sessions, session => {\n    each(session._namedSubs, countSubData);\n    each(session._universalSubs, countSubData);\n  });\n\n  var avgObserverReuse = Object.create(null);\n  _.each(totalObservers, function(value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n\n  return {\n    activeSubs: activeSubs,\n    activeDocs: activeDocs,\n    avgObserverReuse: avgObserverReuse\n  };\n\n  function countSubData (sub) {\n    var publication = self._getPublicationName(sub._name);\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countObservers(sub, publication);\n  }\n\n  function countSubscriptions (sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n\n  function countDocuments (sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    each(sub._documents, document => {\n      activeDocs[publication] += size(document);\n    });\n  }\n\n  function countObservers(sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n}\n\nPubsubModel.prototype.buildPayload = function(buildDetailInfo) {\n  var metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = Object.create(null);\n\n  var payload = {\n    pubMetrics: []\n  };\n\n  var subscriptionData = this._getSubscriptionInfo();\n  var activeSubs = subscriptionData.activeSubs;\n  var activeDocs = subscriptionData.activeDocs;\n  var avgObserverReuse = subscriptionData.avgObserverReuse;\n\n  //to the averaging\n  for(var dateId in metricsByMinute) {\n    var dateMetrics = metricsByMinute[dateId];\n    // We need to convert startTime into actual serverTime\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n\n    for(var publication in metricsByMinute[dateId].pubs) {\n      var singlePubMetrics = metricsByMinute[dateId].pubs[publication];\n      // We only calculate resTime for new subscriptions\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\n      // We only track lifeTime in the unsubs\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\n\n      // Count the average for observer lifetime\n      if(singlePubMetrics.deletedObservers > 0) {\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\n      }\n\n      // If there are two ore more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  }\n\n  //collect traces and send them with the payload\n  payload.pubRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n\nPubsubModel.prototype.incrementHandleCount = function(trace, isCached) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(trace.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  var session = get(Meteor.server.sessions, trace.session);\n  if (session) {\n    var sub = get(session._namedSubs, trace.id);\n    if (sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  }\n  // not sure, we need to do this? But I don't need to break the however\n  sub = sub || {_totalObservers:0 , _cachedObservers: 0};\n\n  publication.totalObservers++;\n  sub._totalObservers++;\n  if(isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n}\n\nPubsubModel.prototype.trackCreatedObserver = function(info) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.createdObservers++;\n}\n\nPubsubModel.prototype.trackDeletedObserver = function(info) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.deletedObservers++;\n  publication.observerLifetime += (new Date()).getTime() - info.startTime;\n}\n\nPubsubModel.prototype.trackDocumentChanges = function(info, op) {\n  // It's possibel that info to be null\n  // Specially when getting changes at the very begining.\n  // This may be false, but nice to have a check\n  if(!info) {\n    return\n  }\n\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  if(op.op === \"d\") {\n    publication.oplogDeletedDocuments++;\n  } else if(op.op === \"i\") {\n    publication.oplogInsertedDocuments++;\n  } else if(op.op === \"u\") {\n    publication.oplogUpdatedDocuments++;\n  }\n}\n\nPubsubModel.prototype.trackPolledDocuments = function(info, count) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n  publication.polledDocuments += count;\n}\n\nPubsubModel.prototype.trackLiveUpdates = function(info, type, count) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(info.name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if(type === \"_addPublished\") {\n    publication.liveAddedDocuments += count;\n  } else if(type === \"_removePublished\") {\n    publication.liveRemovedDocuments += count;\n  } else if(type === \"_changePublished\") {\n    publication.liveChangedDocuments += count;\n  } else if(type === \"_initialAdds\") {\n    publication.initiallyAddedDocuments += count;\n  } else {\n    throw new Error(\"Kadira: Unknown live update type\");\n  }\n}\n\nPubsubModel.prototype.trackDocSize = function(name, type, size) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if(type === \"polledFetches\") {\n    publication.polledDocSize += size;\n  } else if(type === \"liveFetches\") {\n    publication.liveFetchedDocSize += size;\n  } else if(type === \"cursorFetches\") {\n    publication.fetchedDocSize += size;\n  } else if(type === \"initialFetches\") {\n    publication.initiallyFetchedDocSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n}\n\nPubsubModel.prototype.trackMsgSize = function(name, type, size) {\n  var timestamp = Ntp._now();\n  var publicationName = this._getPublicationName(name);\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  if(type === \"liveSent\") {\n    publication.liveSentMsgSize += size;\n  } else if(type === \"initialSent\") {\n    publication.initiallySentMsgSize += size;\n  } else {\n    throw new Error(\"Kadira: Unknown docs fetched type\");\n  }\n}\n"]},"sourceType":"module","hash":"46aefbcc09594ec593a412a8f479f9fe3c901128"}
