{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/hijack/wrap_webapp.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/hijack/wrap_webapp.js","filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/hijack/wrap_webapp.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/hijack/wrap_webapp.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/hijack/wrap_webapp.js"}},"code":"module.export({\n  checkHandlersInFiber: () => checkHandlersInFiber,\n  wrapWebApp: () => wrapWebApp\n});\nlet WebAppInternals, WebApp;\nmodule.link(\"meteor/webapp\", {\n  WebAppInternals(v) {\n    WebAppInternals = v;\n  },\n\n  WebApp(v) {\n    WebApp = v;\n  }\n\n}, 0);\nlet Fibers;\nmodule.link(\"fibers\", {\n  default(v) {\n    Fibers = v;\n  }\n\n}, 1);\n// Maximum content-length size\nMAX_BODY_SIZE = 8000; // Maximum characters for stringified body\n\nMAX_STRINGIFIED_BODY_SIZE = 4000;\nconst canWrapStaticHandler = !!WebAppInternals.staticFilesByArch; // This checks if running on a version of Meteor that\n// wraps connect handlers in a fiber.\n// This check is dependant on Meteor's implementation of `use`,\n// which wraps every handler in a new fiber.\n// This will need to be updated if Meteor starts reusing\n// fibers when they exist.\n\nfunction checkHandlersInFiber() {\n  const handlersLength = WebApp.rawConnectHandlers.stack.length;\n  let inFiber = false;\n  let outsideFiber = Fibers.current;\n  WebApp.rawConnectHandlers.use((_req, _res, next) => {\n    inFiber = Fibers.current && Fibers.current !== outsideFiber; // in case we didn't successfully remove this handler\n    // and it is a real request\n\n    next();\n  });\n\n  if (WebApp.rawConnectHandlers.stack[handlersLength]) {\n    let handler = WebApp.rawConnectHandlers.stack[handlersLength].handle; // remove the newly added handler\n    // We remove it immediately so there is no opportunity for\n    // other code to add handlers first if the current fiber is yielded\n    // while running the handler\n\n    while (WebApp.rawConnectHandlers.stack.length > handlersLength) {\n      WebApp.rawConnectHandlers.stack.pop();\n    }\n\n    handler({}, {}, () => {});\n  }\n\n  return inFiber;\n}\n\nconst InfoSymbol = Symbol();\n\nfunction wrapWebApp() {\n  return Promise.asyncApply(() => {\n    if (!checkHandlersInFiber() || !canWrapStaticHandler) {\n      return;\n    }\n\n    const parseUrl = require('parseurl');\n\n    WebAppInternals.registerBoilerplateDataCallback('__montiApmRouteName', function (request) {\n      // TODO: record in trace which arch is used\n      if (request[InfoSymbol]) {\n        request[InfoSymbol].isAppRoute = true;\n      } // Let WebApp know we didn't make changes\n      // so it can use a cache\n\n\n      return false;\n    }); // We want the request object returned by categorizeRequest to have\n    // __kadiraInfo\n\n    let origCategorizeRequest = WebApp.categorizeRequest;\n\n    WebApp.categorizeRequest = function (req) {\n      let result = origCategorizeRequest.apply(this, arguments);\n\n      if (result && req.__kadiraInfo) {\n        result[InfoSymbol] = req.__kadiraInfo;\n      }\n\n      return result;\n    }; // Adding the handler directly to the stack\n    // to force it to be the first one to run\n\n\n    WebApp.rawConnectHandlers.stack.unshift({\n      route: '',\n      handle: (req, res, next) => {\n        const name = parseUrl(req).pathname;\n        const trace = Kadira.tracer.start(\"\".concat(req.method, \"-\").concat(name), 'http');\n\n        const headers = Kadira.tracer._applyObjectFilters(req.headers);\n\n        Kadira.tracer.event(trace, 'start', {\n          url: req.url,\n          method: req.method,\n          headers: JSON.stringify(headers)\n        });\n        req.__kadiraInfo = {\n          trace\n        };\n        res.on('finish', () => {\n          if (req.__kadiraInfo.asyncEvent) {\n            Kadira.tracer.eventEnd(trace, req.__kadiraInfo.asyncEvent);\n          }\n\n          Kadira.tracer.endLastEvent(trace);\n\n          if (req.__kadiraInfo.isStatic) {\n            trace.name = \"\".concat(req.method, \"-<static file>\");\n          } else if (req.__kadiraInfo.suggestedRouteName) {\n            trace.name = \"\".concat(req.method, \"-\").concat(req.__kadiraInfo.suggestedRouteName);\n          } else if (req.__kadiraInfo.isAppRoute) {\n            trace.name = \"\".concat(req.method, \"-<app>\");\n          }\n\n          const isJson = req.headers['content-type'] === 'application/json';\n          const hasSmallBody = req.headers['content-length'] > 0 && req.headers['content-length'] < MAX_BODY_SIZE; // Check after all middleware have run to see if any of them\n          // set req.body\n          // Technically bodies can be used with any method, but since many load balancers and\n          // other software only support bodies for POST requests, we are\n          // not recording the body for other methods.\n\n          if (req.method === 'POST' && req.body && isJson && hasSmallBody) {\n            try {\n              let body = JSON.stringify(req.body); // Check the body size again in case it is much\n              // larger than what was in the content-length header\n\n              if (body.length < MAX_STRINGIFIED_BODY_SIZE) {\n                trace.events[0].data.body = body;\n              }\n            } catch (e) {// It is okay if this fails\n            }\n          } // TODO: record status code\n\n\n          Kadira.tracer.event(trace, 'complete');\n          let built = Kadira.tracer.buildTrace(trace);\n          Kadira.models.http.processRequest(built, req, res);\n        });\n        next();\n      }\n    });\n\n    function wrapHandler(handler) {\n      // connect identifies error handles by them accepting\n      // four arguments\n      let errorHandler = handler.length === 4;\n\n      function wrapper(req, res, next) {\n        let error;\n\n        if (errorHandler) {\n          error = req;\n          req = res;\n          res = next;\n          next = arguments[3];\n        }\n\n        const kadiraInfo = req.__kadiraInfo;\n\n        Kadira._setInfo(kadiraInfo);\n\n        let nextCalled = false; // TODO: track errors passed to next or thrown\n\n        function wrappedNext() {\n          if (kadiraInfo && kadiraInfo.asyncEvent) {\n            Kadira.tracer.eventEnd(req.__kadiraInfo.trace, req.__kadiraInfo.asyncEvent);\n            req.__kadiraInfo.asyncEvent = null;\n          }\n\n          nextCalled = true;\n          next(...arguments);\n        }\n\n        let potentialPromise;\n\n        if (errorHandler) {\n          potentialPromise = handler.call(this, error, req, res, wrappedNext);\n        } else {\n          potentialPromise = handler.call(this, req, res, wrappedNext);\n        }\n\n        if (potentialPromise && typeof potentialPromise.then === 'function') {\n          potentialPromise.then(() => {\n            // res.finished is depreciated in Node 13, but it is the only option\n            // for Node 12.9 and older.\n            if (kadiraInfo && !res.finished && !nextCalled) {\n              const lastEvent = Kadira.tracer.getLastEvent(kadiraInfo.trace);\n\n              if (lastEvent.endAt) {\n                // req is not done, and next has not been called\n                // create an async event that will end when either of those happens\n                kadiraInfo.asyncEvent = Kadira.tracer.event(kadiraInfo.trace, 'async');\n              }\n            }\n          });\n        }\n\n        return potentialPromise;\n      }\n\n      if (errorHandler) {\n        return function (error, req, res, next) {\n          return wrapper(error, req, res, next);\n        };\n      } else {\n        return function (req, res, next) {\n          return wrapper(req, res, next);\n        };\n      }\n    }\n\n    function wrapConnect(app, wrapStack) {\n      let oldUse = app.use;\n\n      if (wrapStack) {\n        // We need to set kadiraInfo on the Fiber the handler will run in.\n        // Meteor has already wrapped the handler to run it in a new Fiber\n        // by using Promise.asyncApply so we are not able to directly set it\n        // on that Fiber. \n        // Meteor's promise library copies properties from the current fiber to\n        // the new fiber, so we can wrap it in another Fiber with kadiraInfo set\n        // and Meteor will copy kadiraInfo to the new Fiber.\n        // It will only create the additional Fiber if it isn't already running in a Fiber\n        app.stack.forEach(entry => {\n          let wrappedHandler = wrapHandler(entry.handle);\n\n          if (entry.handle.length >= 4) {\n            entry.handle = function (error, req, res, next) {\n              return Promise.asyncApply(wrappedHandler, this, arguments, true);\n            };\n          } else {\n            entry.handle = function (req, res, next) {\n              return Promise.asyncApply(wrappedHandler, this, arguments, true);\n            };\n          }\n        });\n      }\n\n      app.use = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        args[args.length - 1] = wrapHandler(args[args.length - 1]);\n        return oldUse.apply(app, args);\n      };\n    }\n\n    wrapConnect(WebApp.rawConnectHandlers, false);\n    wrapConnect(WebAppInternals.meteorInternalHandlers, false); // The oauth package and other core packages might have already added their middleware,\n    // so we need to wrap the existing middleware\n\n    wrapConnect(WebApp.connectHandlers, true);\n    wrapConnect(WebApp.connectApp, false);\n    let oldStaticFilesMiddleware = WebAppInternals.staticFilesMiddleware;\n    const staticHandler = wrapHandler(oldStaticFilesMiddleware.bind(WebAppInternals, WebAppInternals.staticFilesByArch));\n\n    WebAppInternals.staticFilesMiddleware = function (_staticFiles, req, res, next) {\n      if (req.__kadiraInfo) {\n        req.__kadiraInfo.isStatic = true;\n      }\n\n      return staticHandler(req, res, function () {\n        // if the request is for a static file, the static handler will end the response\n        // instead of calling next\n        req.__kadiraInfo.isStatic = false;\n        return next.apply(this, arguments);\n      });\n    };\n  });\n}","map":{"version":3,"sources":["packages/montiapm:agent/lib/hijack/wrap_webapp.js"],"names":["module","export","checkHandlersInFiber","wrapWebApp","WebAppInternals","WebApp","link","v","Fibers","default","MAX_BODY_SIZE","MAX_STRINGIFIED_BODY_SIZE","canWrapStaticHandler","staticFilesByArch","handlersLength","rawConnectHandlers","stack","length","inFiber","outsideFiber","current","use","_req","_res","next","handler","handle","pop","InfoSymbol","Symbol","parseUrl","require","registerBoilerplateDataCallback","request","isAppRoute","origCategorizeRequest","categorizeRequest","req","result","apply","arguments","__kadiraInfo","unshift","route","res","name","pathname","trace","Kadira","tracer","start","method","headers","_applyObjectFilters","event","url","JSON","stringify","on","asyncEvent","eventEnd","endLastEvent","isStatic","suggestedRouteName","isJson","hasSmallBody","body","events","data","e","built","buildTrace","models","http","processRequest","wrapHandler","errorHandler","wrapper","error","kadiraInfo","_setInfo","nextCalled","wrappedNext","potentialPromise","call","then","finished","lastEvent","getLastEvent","endAt","wrapConnect","app","wrapStack","oldUse","forEach","entry","wrappedHandler","Promise","asyncApply","args","meteorInternalHandlers","connectHandlers","connectApp","oldStaticFilesMiddleware","staticFilesMiddleware","staticHandler","bind","_staticFiles"],"mappings":"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","sourcesContent":["import { WebAppInternals, WebApp } from 'meteor/webapp';\nimport Fibers from 'fibers';\n\n// Maximum content-length size\nMAX_BODY_SIZE = 8000\n// Maximum characters for stringified body\nMAX_STRINGIFIED_BODY_SIZE = 4000\n\nconst canWrapStaticHandler = !!WebAppInternals.staticFilesByArch\n\n// This checks if running on a version of Meteor that\n// wraps connect handlers in a fiber.\n// This check is dependant on Meteor's implementation of `use`,\n// which wraps every handler in a new fiber.\n// This will need to be updated if Meteor starts reusing\n// fibers when they exist.\nexport function checkHandlersInFiber () {\n  const handlersLength = WebApp.rawConnectHandlers.stack.length;\n  let inFiber = false;\n  let outsideFiber = Fibers.current;\n\n  WebApp.rawConnectHandlers.use((_req, _res, next) => {\n    inFiber = Fibers.current && Fibers.current !== outsideFiber;\n    \n    // in case we didn't successfully remove this handler\n    // and it is a real request\n    next();\n  });\n\n  if (WebApp.rawConnectHandlers.stack[handlersLength]) {\n    let handler = WebApp.rawConnectHandlers.stack[handlersLength].handle;\n\n    // remove the newly added handler\n    // We remove it immediately so there is no opportunity for\n    // other code to add handlers first if the current fiber is yielded\n    // while running the handler\n    while (WebApp.rawConnectHandlers.stack.length > handlersLength) {\n      WebApp.rawConnectHandlers.stack.pop();\n    }\n\n    handler({}, {}, () => {})\n  }\n\n  return inFiber;\n}\n\nconst InfoSymbol = Symbol()\n\nexport async function wrapWebApp() {\n  if (!checkHandlersInFiber() || !canWrapStaticHandler) {\n    return;\n  }\n\n  const parseUrl = require('parseurl');\n\n  WebAppInternals.registerBoilerplateDataCallback('__montiApmRouteName', function (request) {\n    // TODO: record in trace which arch is used\n\n    if (request[InfoSymbol]) {\n      request[InfoSymbol].isAppRoute = true\n    }\n\n    // Let WebApp know we didn't make changes\n    // so it can use a cache\n    return false\n  })\n\n  // We want the request object returned by categorizeRequest to have\n  // __kadiraInfo\n  let origCategorizeRequest = WebApp.categorizeRequest;\n  WebApp.categorizeRequest = function (req) {\n    let result = origCategorizeRequest.apply(this, arguments);\n\n    if (result && req.__kadiraInfo) {\n      result[InfoSymbol] = req.__kadiraInfo;\n    }\n\n    return result;\n  }\n\n  // Adding the handler directly to the stack\n  // to force it to be the first one to run\n  WebApp.rawConnectHandlers.stack.unshift({\n    route: '',\n    handle: (req, res, next) => {\n    const name = parseUrl(req).pathname;\n    const trace = Kadira.tracer.start(`${req.method}-${name}`, 'http');\n\n    const headers = Kadira.tracer._applyObjectFilters(req.headers);\n    Kadira.tracer.event(trace, 'start', {\n      url: req.url,\n      method: req.method,\n      headers: JSON.stringify(headers),\n    });\n    req.__kadiraInfo = { trace };\n\n    res.on('finish', () => {\n      if (req.__kadiraInfo.asyncEvent) {\n        Kadira.tracer.eventEnd(trace, req.__kadiraInfo.asyncEvent);\n      }\n\n      Kadira.tracer.endLastEvent(trace);\n\n      if (req.__kadiraInfo.isStatic) {\n        trace.name = `${req.method}-<static file>`\n      } else if (req.__kadiraInfo.suggestedRouteName) {\n        trace.name = `${req.method}-${req.__kadiraInfo.suggestedRouteName}`\n      } else if (req.__kadiraInfo.isAppRoute) {\n        trace.name = `${req.method}-<app>`\n      }\n\n      const isJson = req.headers['content-type'] === 'application/json';\n      const hasSmallBody = req.headers['content-length'] > 0 && req.headers['content-length'] < MAX_BODY_SIZE\n\n      // Check after all middleware have run to see if any of them\n      // set req.body\n      // Technically bodies can be used with any method, but since many load balancers and\n      // other software only support bodies for POST requests, we are\n      // not recording the body for other methods.\n      if (req.method === 'POST' && req.body && isJson && hasSmallBody) {\n        try {\n          let body = JSON.stringify(req.body);\n\n          // Check the body size again in case it is much\n          // larger than what was in the content-length header\n          if (body.length < MAX_STRINGIFIED_BODY_SIZE) {\n            trace.events[0].data.body = body;\n          }\n        } catch (e) {\n          // It is okay if this fails\n        }\n      }\n\n      // TODO: record status code\n      Kadira.tracer.event(trace, 'complete');\n      let built = Kadira.tracer.buildTrace(trace);\n      Kadira.models.http.processRequest(built, req, res);\n    });\n\n    next();\n  }\n});\n\n\n  function wrapHandler(handler) {\n    // connect identifies error handles by them accepting\n    // four arguments\n    let errorHandler = handler.length === 4;\n\n    function wrapper(req, res, next) {\n      let error;\n      if (errorHandler) {\n        error = req;\n        req = res;\n        res = next;\n        next = arguments[3]\n      }\n\n      const kadiraInfo = req.__kadiraInfo;\n      Kadira._setInfo(kadiraInfo);\n\n      let nextCalled = false;\n      // TODO: track errors passed to next or thrown\n      function wrappedNext(...args) {\n        if (kadiraInfo && kadiraInfo.asyncEvent) {\n          Kadira.tracer.eventEnd(req.__kadiraInfo.trace, req.__kadiraInfo.asyncEvent);\n          req.__kadiraInfo.asyncEvent = null;\n        }\n\n        nextCalled = true;\n        next(...args)\n      }\n\n      let potentialPromise\n\n      if (errorHandler) {\n        potentialPromise = handler.call(this, error, req, res, wrappedNext);\n      } else {\n        potentialPromise = handler.call(this, req, res, wrappedNext);\n      }\n\n      if (potentialPromise && typeof potentialPromise.then === 'function') {\n        potentialPromise.then(() => {\n          // res.finished is depreciated in Node 13, but it is the only option\n          // for Node 12.9 and older.\n          if (kadiraInfo && !res.finished && !nextCalled) {\n            const lastEvent = Kadira.tracer.getLastEvent(kadiraInfo.trace)\n            if (lastEvent.endAt) {\n              // req is not done, and next has not been called\n              // create an async event that will end when either of those happens\n              kadiraInfo.asyncEvent = Kadira.tracer.event(kadiraInfo.trace, 'async');\n            }\n          }\n        });\n      }\n\n      return potentialPromise;\n    }\n\n    if (errorHandler) {\n      return function (error, req, res, next) {\n        return wrapper(error, req, res, next);\n      }\n    } else {\n      return function (req, res, next) {\n        return wrapper(req, res, next);\n      }\n    }\n  }\n\n  function wrapConnect(app, wrapStack) {\n    let oldUse = app.use;\n    if (wrapStack) {\n      // We need to set kadiraInfo on the Fiber the handler will run in.\n      // Meteor has already wrapped the handler to run it in a new Fiber\n      // by using Promise.asyncApply so we are not able to directly set it\n      // on that Fiber. \n      // Meteor's promise library copies properties from the current fiber to\n      // the new fiber, so we can wrap it in another Fiber with kadiraInfo set\n      // and Meteor will copy kadiraInfo to the new Fiber.\n      // It will only create the additional Fiber if it isn't already running in a Fiber\n      app.stack.forEach(entry => {\n        let wrappedHandler = wrapHandler(entry.handle)\n        if (entry.handle.length >= 4) {\n          entry.handle = function (error, req, res, next) {\n            return Promise.asyncApply(\n              wrappedHandler,\n              this,\n              arguments,\n              true\n            );\n          };\n        } else {\n          entry.handle = function (req, res, next) {\n            return Promise.asyncApply(\n              wrappedHandler,\n              this,\n              arguments,\n              true\n            )\n          }\n        }\n      });\n    }\n    app.use = function (...args) {\n      args[args.length - 1] = wrapHandler(args[args.length - 1])\n      return oldUse.apply(app, args);\n    }\n  }\n\n  wrapConnect(WebApp.rawConnectHandlers, false);\n  wrapConnect(WebAppInternals.meteorInternalHandlers, false);\n\n  // The oauth package and other core packages might have already added their middleware,\n  // so we need to wrap the existing middleware\n  wrapConnect(WebApp.connectHandlers, true);\n\n  wrapConnect(WebApp.connectApp, false);\n\n  let oldStaticFilesMiddleware = WebAppInternals.staticFilesMiddleware;\n  const staticHandler = wrapHandler(oldStaticFilesMiddleware.bind(WebAppInternals, WebAppInternals.staticFilesByArch));\n  WebAppInternals.staticFilesMiddleware = function (_staticFiles, req, res, next) {\n    if (req.__kadiraInfo) {\n      req.__kadiraInfo.isStatic = true;\n    }\n\n    return staticHandler(req, res, function () {\n      // if the request is for a static file, the static handler will end the response\n      // instead of calling next\n      req.__kadiraInfo.isStatic = false;\n      return next.apply(this, arguments);\n    });\n  };\n}\n"]},"sourceType":"module","hash":"7932e98a3f938518137c400e53a7e7c3f0854da7"}
