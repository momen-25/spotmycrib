{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/ongoworks:security/lib/server/Security.Rule.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/ongoworks:security/lib/server/Security.Rule.js","filename":"/home/momen/projects/spotmycrib-master/packages/ongoworks:security/lib/server/Security.Rule.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/ongoworks:security/lib/server/Security.Rule.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ongoworks:security/lib/server/Security.Rule.js"}},"code":"Security.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections]; // Keep list keyed by collection name\n\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) && // CollectionFS has underlying collection on `files` property\n      !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      } // CollectionFS has underlying collection on `files` property\n\n\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n\n      return true;\n    });\n\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier) {\n    for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n      args[_key - 5] = arguments[_key];\n    }\n\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier); // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc); // If transform is a function, apply that\n\n\n      let transform = restriction.definition.transform;\n\n      if (transform !== null) {\n        transform = transform || collection._transform;\n\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n\n};\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        const userId = args.shift(); // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n\n        if (t === 'update') args = [args[0], args[2]];\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = []; // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // record the field we are trying to change\n\n      if (!_.contains(fields, field)) fields.push(field);\n    });\n  });\n\n  return fields;\n}","map":{"version":3,"sources":["packages/ongoworks:security/lib/server/Security.Rule.js"],"names":["Security","Rule","constructor","types","_","isArray","_types","_restrictions","collections","each","collection","Mongo","Collection","files","Error","errorMessages","collectionsArg","collectionName","getCollectionName","rulesByCollection","push","_collections","combinedFetch","fetch","every","restriction","definition","union","arg","hasOwnProperty","allowInClientCode","noCollectionOrType","ensureSecureDeny","allow","type","userId","doc","modifier","args","fields","computeChangedFieldsFromModifier","loopDoc","clone","transform","_transform","addedRandomId","_id","Random","id","ensureDefaultAllow","t","ensureCreated","shift","can","for","check","params","keys","field","indexOf","substring","contains"],"mappings":"AAAAA,QAAQ,CAACC,IAAT,GAAgB,MAAM;AACpBC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,QAAI,CAACC,CAAC,CAACC,OAAF,CAAUF,KAAV,CAAL,EAAuBA,KAAK,GAAG,CAACA,KAAD,CAAR;AACvB,SAAKG,MAAL,GAAcH,KAAd;AACA,SAAKI,aAAL,GAAqB,EAArB;AACD;;AAEDC,EAAAA,WAAW,CAACA,WAAD,EAAc;AACvB;AACA;AACA,QAAI,CAACJ,CAAC,CAACC,OAAF,CAAUG,WAAV,CAAL,EAA6BA,WAAW,GAAG,CAACA,WAAD,CAAd,CAHN,CAKvB;;AACAJ,IAAAA,CAAC,CAACK,IAAF,CAAOD,WAAP,EAAoBE,UAAU,IAAI;AAChC,UAAI,EAAEA,UAAU,YAAYC,KAAK,CAACC,UAA9B,KACA;AACF,QAAEF,UAAU,CAACG,KAAX,YAA4BF,KAAK,CAACC,UAApC,CAFF,EAEmD;AACjD,cAAM,IAAIE,KAAJ,CAAUd,QAAQ,CAACe,aAAT,CAAuBC,cAAjC,CAAN;AACD,OAL+B,CAMhC;;;AACA,YAAMC,cAAc,GAAGC,iBAAiB,CAACR,UAAD,CAAxC;AACAS,MAAAA,iBAAiB,CAACF,cAAD,CAAjB,GAAoCE,iBAAiB,CAACF,cAAD,CAAjB,IAAqC,EAAzE;AACAE,MAAAA,iBAAiB,CAACF,cAAD,CAAjB,CAAkCG,IAAlC,CAAuC,IAAvC;AACD,KAVD;;AAYA,SAAKC,YAAL,GAAoBb,WAApB;AAEA,WAAO,IAAP;AACD;;AAEDc,EAAAA,aAAa,GAAG;AACd;AACA;AACA,QAAIC,KAAK,GAAG,EAAZ;;AACAnB,IAAAA,CAAC,CAACoB,KAAF,CAAQ,KAAKjB,aAAb,EAA4BkB,WAAW,IAAI;AACzC,UAAIrB,CAAC,CAACC,OAAF,CAAUoB,WAAW,CAACC,UAAZ,CAAuBH,KAAjC,CAAJ,EAA6C;AAC3CA,QAAAA,KAAK,GAAGnB,CAAC,CAACuB,KAAF,CAAQJ,KAAR,EAAeE,WAAW,CAACC,UAAZ,CAAuBH,KAAtC,CAAR;AACD,OAFD,MAEO,IAAI,OAAOE,WAAW,CAACC,UAAZ,CAAuBH,KAA9B,KAAwC,UAA5C,EAAwD;AAC7DA,QAAAA,KAAK,GAAGnB,CAAC,CAACuB,KAAF,CAAQJ,KAAR,EAAeE,WAAW,CAACC,UAAZ,CAAuBH,KAAvB,CAA6BE,WAAW,CAACG,GAAzC,CAAf,CAAR;AACD,OAFM,MAEA,IAAI,CAACH,WAAW,CAACC,UAAZ,CAAuBG,cAAvB,CAAsC,OAAtC,CAAL,EAAqD;AAC1D;AACAN,QAAAA,KAAK,GAAG,IAAR;AACA,eAAO,KAAP,CAH0D,CAG5C;AACf;;AACD,aAAO,IAAP;AACD,KAXD;;AAYA,WAAOA,KAAP;AACD;;AAEDO,EAAAA,iBAAiB,GAAG;AAClB,QAAI,CAAC,KAAKT,YAAN,IAAsB,CAAC,KAAKf,MAAhC,EAAwC,MAAM,IAAIQ,KAAJ,CAAUd,QAAQ,CAACe,aAAT,CAAuBgB,kBAAjC,CAAN;AACxCC,IAAAA,gBAAgB,CAAC,KAAKX,YAAN,EAAoB,KAAKf,MAAzB,CAAhB;AACD;;AAED2B,EAAAA,KAAK,CAACC,IAAD,EAAOxB,UAAP,EAAmByB,MAAnB,EAA2BC,GAA3B,EAAgCC,QAAhC,EAAmD;AAAA,sCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACtD,QAAIC,MAAJ;AACA,QAAIL,IAAI,KAAK,QAAb,EAAuBK,MAAM,GAAGC,gCAAgC,CAACH,QAAD,CAAzC,CAF+B,CAItD;AACA;;AACA,WAAOjC,CAAC,CAACoB,KAAF,CAAQ,KAAKjB,aAAb,EAA4BkB,WAAW,IAAI;AAChD;AACA;AACA,UAAIgB,OAAO,GAAGrC,CAAC,CAACsC,KAAF,CAAQN,GAAR,CAAd,CAHgD,CAKhD;;;AACA,UAAIO,SAAS,GAAGlB,WAAW,CAACC,UAAZ,CAAuBiB,SAAvC;;AACA,UAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBA,QAAAA,SAAS,GAAGA,SAAS,IAAIjC,UAAU,CAACkC,UAApC;;AACA,YAAI,OAAOD,SAAP,KAAqB,UAAzB,EAAqC;AACnC,cAAIE,aAAa,GAAG,KAApB;;AACA,cAAIX,IAAI,KAAK,QAAT,IAAqB,CAACO,OAAO,CAACK,GAAlC,EAAuC;AACrC;AACA;AACA;AACAL,YAAAA,OAAO,CAACK,GAAR,GAAcC,MAAM,CAACC,EAAP,EAAd;AACAH,YAAAA,aAAa,GAAG,IAAhB;AACD;;AACDJ,UAAAA,OAAO,GAAGE,SAAS,CAACF,OAAD,CAAnB;AACA,cAAII,aAAJ,EAAmB,OAAOJ,OAAO,CAACK,GAAf;AACpB;AACF;;AAED,aAAOrB,WAAW,CAACC,UAAZ,CAAuBO,KAAvB,CAA6BC,IAA7B,EAAmCT,WAAW,CAACG,GAA/C,EAAoDO,MAApD,EAA4DM,OAA5D,EAAqEF,MAArE,EAA6EF,QAA7E,EAAuF,GAAGC,IAA1F,CAAP;AACD,KAxBM,CAAP;AAyBD;;AArFmB,CAAtB;;AAwFA,SAASN,gBAAT,CAA0BxB,WAA1B,EAAuCL,KAAvC,EAA8C;AAC5C;AACA;AACA;AACA;AACA8C,EAAAA,kBAAkB,CAACzC,WAAD,EAAcL,KAAd,CAAlB;;AAEAC,EAAAA,CAAC,CAACK,IAAF,CAAON,KAAP,EAAc+C,CAAC,IAAI;AACjB9C,IAAAA,CAAC,CAACK,IAAF,CAAOD,WAAP,EAAoBE,UAAU,IAAI;AAChCyC,MAAAA,aAAa,CAAC,MAAD,EAAS,CAACzC,UAAD,CAAT,EAAuB,CAACwC,CAAD,CAAvB,EAA4B,IAA5B,EAAkC,YAAmB;AAAA,2CAANZ,IAAM;AAANA,UAAAA,IAAM;AAAA;;AAChE,cAAMH,MAAM,GAAGG,IAAI,CAACc,KAAL,EAAf,CADgE,CAGhE;AACA;;AACA,YAAIF,CAAC,KAAK,QAAV,EAAoBZ,IAAI,GAAG,CAACA,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAP;AAEpB,eAAO,CAACtC,QAAQ,CAACqD,GAAT,CAAalB,MAAb,EAAqBe,CAArB,EAAwB,GAAGZ,IAA3B,EAAiCgB,GAAjC,CAAqC5C,UAArC,EAAiD6C,KAAjD,EAAR;AACD,OARY,CAAb;AASD,KAVD;AAWD,GAZD;AAaD;;AAED,SAASf,gCAAT,CAA0CH,QAA1C,EAAoD;AAClD,MAAIE,MAAM,GAAG,EAAb,CADkD,CAElD;AACA;;AACAnC,EAAAA,CAAC,CAACK,IAAF,CAAO4B,QAAP,EAAiB,UAAUmB,MAAV,EAAkB;AACjCpD,IAAAA,CAAC,CAACK,IAAF,CAAOL,CAAC,CAACqD,IAAF,CAAOD,MAAP,CAAP,EAAuB,UAAUE,KAAV,EAAiB;AACtC;AACA;AACA,UAAIA,KAAK,CAACC,OAAN,CAAc,GAAd,MAAuB,CAAC,CAA5B,EACED,KAAK,GAAGA,KAAK,CAACE,SAAN,CAAgB,CAAhB,EAAmBF,KAAK,CAACC,OAAN,CAAc,GAAd,CAAnB,CAAR,CAJoC,CAMtC;;AACA,UAAI,CAACvD,CAAC,CAACyD,QAAF,CAAWtB,MAAX,EAAmBmB,KAAnB,CAAL,EACEnB,MAAM,CAACnB,IAAP,CAAYsC,KAAZ;AACH,KATD;AAUD,GAXD;;AAYA,SAAOnB,MAAP;AACD","sourcesContent":["Security.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections];\n\n    // Keep list keyed by collection name\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) &&\n          // CollectionFS has underlying collection on `files` property\n        !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      }\n      // CollectionFS has underlying collection on `files` property\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n      return true;\n    });\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier, ...args) {\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier);\n\n    // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc);\n\n      // If transform is a function, apply that\n      let transform = restriction.definition.transform;\n      if (transform !== null) {\n        transform = transform || collection._transform;\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n}\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function (...args) {\n        const userId = args.shift();\n\n        // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n        if (t === 'update') args = [args[0], args[2]];\n\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = [];\n  // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n  return fields;\n}\n"]},"sourceType":"module","hash":"3a6dae0b8c2d9f05bb433731976ba5c3fa91dcb1"}
