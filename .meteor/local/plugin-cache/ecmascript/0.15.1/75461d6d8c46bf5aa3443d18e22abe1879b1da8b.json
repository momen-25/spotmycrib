{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/msavin:mongol/server/utilities.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/msavin:mongol/server/utilities.js","filename":"/home/momen/projects/spotmycrib-master/packages/msavin:mongol/server/utilities.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/msavin:mongol/server/utilities.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/msavin:mongol/server/utilities.js"}},"code":"module.export({\n  Utilities: () => Utilities\n});\nmodule.runSetters(Utilities = {});\n\nUtilities.diffDocumentData = function (dbDoc, newData, oldData) {\n  var finalData = {};\n\n  var dbDocFields = _.keys(dbDoc);\n\n  var newDataFields = _.keys(newData);\n\n  var oldDataFields = _.keys(oldData); // console.log(\"dbDocFields\",dbDocFields); console.log(\"newDataFields\",newDataFields); console.log(\"oldDataFields\",oldDataFields);\n  // First get the set of fields that we won't be saving because they were dynamically added on the client\n\n\n  var dynamicallyAddedFields = _.difference(oldDataFields, dbDocFields); // Then get the fields that must retain their dbDoc field value, because they we'ren't published\n\n\n  var unpublishedFields = _.difference(dbDocFields, oldDataFields); // console.log(\"unpublishedFields\",unpublishedFields);\n  // iterate over all fields, old and new, and ascertain the field value that must be added to the final data object\n\n\n  var oldAndNewFields = _.union(dbDocFields, newDataFields);\n\n  _.each(oldAndNewFields, function (field) {\n    if (_.contains(dynamicallyAddedFields, field)) {\n      // We don't want to add this field to the actual mongodb document\n      // console.log(\"'\" + field + \"' appears to be a dynamically added field. This field was not updated.\");\n      return;\n    }\n\n    if (_.contains(unpublishedFields, field)) {\n      // We don't want to overwrite the existing mondodb document value\n      if (newData[field]) {// Give a message to user as to why that field wasn't updated\n        // console.log(\"'\" + field + \"' is an unpublished field. This field's value was not overwritten.\");\n      } // Make sure the old value is retained\n\n\n      finalData[field] = dbDoc[field];\n      return;\n    }\n\n    if (!_.isUndefined(newData[field])) {\n      finalData[field] = _.isObject(newData[field]) && !_.isArray(newData[field]) && !_.isDate(newData[field]) ? Mongol.diffDocumentData(dbDoc[field] || {}, newData[field], oldData[field] || {}) : newData[field];\n    } // This will let unpublished fields into the database,\n    // so the user may be confused by the lack of an update in the client\n    // simply because the added field isn't published\n    // The following solves that problem, but doesn't allow new fields to be added at all:\n    // finalData[field] = oldData[field] && newData[field];\n    // We actually need to know the set of fields published by the publication that the client side doc came from\n    // but how do we get that?\n\n  });\n\n  return finalData;\n}; // Test code for Mongol.diffDocumentData\n\n/*Meteor.startup(function() {\n\n  // Take a user document\n  var sampleDbDoc = { \"_id\" : \"exampleuser1\", \"createdAt\" : 1375253926213, \"defaultPrograms\" : { \"514d75dc97095578800\" : \"MYP\", \"515be068c708000000\" : \"PYP\" }, \"department_id\" : [  \"GMsv9YzaCuL6dFBYL\" ], \"emails\" : [  {  \"address\" : \"aaa@aaa.com\",  \"verified\" : true } ], \"myCourses\" : [  \"QqofEtQPgFb72\",  \"fvTxhAyfMxFbhzwK7\",  \"jcPtgwN6pTMQDEp\" ], \"organization_id\" : [  \"51f76bcbfb1e0d3100\" ], \"permContexts\" : [     {     \"department_id\" : \"GMsv9YzCuL6dFBYL\", \"perms\" : [     \"editRoles\",     \"editCourses\",     \"editUnits\",     \"editAssessments\",     \"editDepartments\" ] } ], \"roleContexts\" : [     {     \"organization_id\" : \"51f76bc23dfb1e0d3100\",     \"school_id\" : \"514d75d9562095578800\",     \"department_id\" : \"GMsv9YzaCuL6dFBYL\",     \"roles\" : [     \"iQD4BhnB8PFWwHCcg\" ] },     {     \"organization_id\" : \"2BjJbMyRLWa4iofQm\" } ], \"school_id\" : [  \"514d75dc97d95095578800\" ], \"services\" : { \"password\" : { \"bcrypt\" : \"$M4235dfre5.5ijyU3.ilpYZQFmtO\" }, \"resume\" : { \"loginTokens\" : [     {     \"when\" : \"2014-12-24T12:00:06.725Z\",     \"hashedToken\" : \"not/telling=\" },     {     \"when\" : \"2015-01-16T04:45:10.574Z\",     \"hashedToken\" : \"bigbadhashedtoken=\" },     {     \"when\" : \"2015-01-22T02:01:57.671Z\",     \"hashedToken\" : \"9HSC98hWA9OByHPA6LbBB8=\" } ] } }, \"superuser\" : [  \"51f76bb1e0d3100\",  \"2BjJbMyRiofQm\",  \"ZkeEcp72bAFQY\" ], \"transaction_id\" : \"shQ9fzcZYSgLLnptC\" };\n\n  // Simulate the oldData getting sent back from the client (the fields should be a subset of the db fields)\n  var sampleOldData = _.extend(_.clone(sampleDbDoc),{dynamicallyAddedField:true, secondDynamicallyAddedField: \"Dynamically added value\"}); // Simulate two dynamically added fields\n  delete sampleOldData.services; // Simulate an unpublished field\n\n  // Simulate the newData getting sent back from the client\n  // e.g. user adds a new field\n  var sampleNewData = _.extend(_.clone(sampleOldData),{brandNewField: true});\n  // brandNewField should be added\n  delete sampleNewData.createdAt; // This should be gone\n  sampleNewData.secondDynamicallyAddedField = \"Dynamically added value overwritten by user\"; // seconddynamicallyAddedField should be gone\n  sampleNewData.transaction_id = \"overwritten transaction id\"; // This field should be changed\n\n  // Run the test\n\n  console.log(Mongol.diffDocumentData(sampleDbDoc, sampleNewData, sampleOldData));\n\n});*/","map":{"version":3,"sources":["packages/msavin:mongol/server/utilities.js"],"names":["module","export","Utilities","diffDocumentData","dbDoc","newData","oldData","finalData","dbDocFields","_","keys","newDataFields","oldDataFields","dynamicallyAddedFields","difference","unpublishedFields","oldAndNewFields","union","each","field","contains","isUndefined","isObject","isArray","isDate","Mongol"],"mappings":"AAAAA,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,SAAS,EAAC,MAAIA;AAAf,CAAd;AAAA,kBAAAA,SAAS,GAAG,EAAZ;;AAEAA,SAAS,CAACC,gBAAV,GAA6B,UAAUC,KAAV,EAAiBC,OAAjB,EAA0BC,OAA1B,EAAmC;AAE9D,MAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAIC,WAAW,GAAGC,CAAC,CAACC,IAAF,CAAON,KAAP,CAAlB;;AACA,MAAIO,aAAa,GAAGF,CAAC,CAACC,IAAF,CAAOL,OAAP,CAApB;;AACA,MAAIO,aAAa,GAAGH,CAAC,CAACC,IAAF,CAAOJ,OAAP,CAApB,CAN8D,CAMzB;AAErC;;;AAEA,MAAIO,sBAAsB,GAAGJ,CAAC,CAACK,UAAF,CAAaF,aAAb,EAA4BJ,WAA5B,CAA7B,CAV8D,CAY9D;;;AAEA,MAAIO,iBAAiB,GAAGN,CAAC,CAACK,UAAF,CAAaN,WAAb,EAA0BI,aAA1B,CAAxB,CAd8D,CAcI;AAElE;;;AAEA,MAAII,eAAe,GAAGP,CAAC,CAACQ,KAAF,CAAQT,WAAR,EAAqBG,aAArB,CAAtB;;AAEAF,EAAAA,CAAC,CAACS,IAAF,CAAOF,eAAP,EAAwB,UAASG,KAAT,EAAgB;AAEtC,QAAIV,CAAC,CAACW,QAAF,CAAWP,sBAAX,EAAmCM,KAAnC,CAAJ,EAA+C;AAE7C;AACA;AACA;AAED;;AAED,QAAIV,CAAC,CAACW,QAAF,CAAWL,iBAAX,EAA8BI,KAA9B,CAAJ,EAA0C;AAExC;AACA,UAAId,OAAO,CAACc,KAAD,CAAX,EAAoB,CAClB;AACA;AACD,OANuC,CAOxC;;;AACAZ,MAAAA,SAAS,CAACY,KAAD,CAAT,GAAmBf,KAAK,CAACe,KAAD,CAAxB;AACA;AAED;;AAED,QAAI,CAACV,CAAC,CAACY,WAAF,CAAchB,OAAO,CAACc,KAAD,CAArB,CAAL,EAAoC;AAElCZ,MAAAA,SAAS,CAACY,KAAD,CAAT,GAAoBV,CAAC,CAACa,QAAF,CAAWjB,OAAO,CAACc,KAAD,CAAlB,KAA8B,CAACV,CAAC,CAACc,OAAF,CAAUlB,OAAO,CAACc,KAAD,CAAjB,CAA/B,IAA4D,CAACV,CAAC,CAACe,MAAF,CAASnB,OAAO,CAACc,KAAD,CAAhB,CAA9D,GAA0FM,MAAM,CAACtB,gBAAP,CAAwBC,KAAK,CAACe,KAAD,CAAL,IAAgB,EAAxC,EAA4Cd,OAAO,CAACc,KAAD,CAAnD,EAA4Db,OAAO,CAACa,KAAD,CAAP,IAAkB,EAA9E,CAA1F,GAA8Kd,OAAO,CAACc,KAAD,CAAxM;AAED,KA3BqC,CA6BtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAED,GArCD;;AAuCA,SAAOZ,SAAP;AAED,CA7DD,C,CA+DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["Utilities = {}\n\nUtilities.diffDocumentData = function (dbDoc, newData, oldData) {\n\n  var finalData = {};\n\n  var dbDocFields = _.keys(dbDoc);\n  var newDataFields = _.keys(newData);\n  var oldDataFields = _.keys(oldData); // console.log(\"dbDocFields\",dbDocFields); console.log(\"newDataFields\",newDataFields); console.log(\"oldDataFields\",oldDataFields);\n\n  // First get the set of fields that we won't be saving because they were dynamically added on the client\n\n  var dynamicallyAddedFields = _.difference(oldDataFields, dbDocFields);\n\n  // Then get the fields that must retain their dbDoc field value, because they we'ren't published\n\n  var unpublishedFields = _.difference(dbDocFields, oldDataFields); // console.log(\"unpublishedFields\",unpublishedFields);\n\n  // iterate over all fields, old and new, and ascertain the field value that must be added to the final data object\n\n  var oldAndNewFields = _.union(dbDocFields, newDataFields);\n\n  _.each(oldAndNewFields, function(field) {\n\n    if (_.contains(dynamicallyAddedFields, field)) {\n  \n      // We don't want to add this field to the actual mongodb document\n      // console.log(\"'\" + field + \"' appears to be a dynamically added field. This field was not updated.\");\n      return;\n\n    }\n\n    if (_.contains(unpublishedFields, field)) {\n\n      // We don't want to overwrite the existing mondodb document value\n      if (newData[field]) {\n        // Give a message to user as to why that field wasn't updated\n        // console.log(\"'\" + field + \"' is an unpublished field. This field's value was not overwritten.\");\n      }\n      // Make sure the old value is retained\n      finalData[field] = dbDoc[field];\n      return;\n\n    }\n\n    if (!_.isUndefined(newData[field])) {\n        \n      finalData[field] = (_.isObject(newData[field]) && !_.isArray(newData[field]) && !_.isDate(newData[field])) ? Mongol.diffDocumentData(dbDoc[field] || {}, newData[field], oldData[field] || {}) : newData[field];\n      \n    }\n\n    // This will let unpublished fields into the database,\n    // so the user may be confused by the lack of an update in the client\n    // simply because the added field isn't published\n    // The following solves that problem, but doesn't allow new fields to be added at all:\n    // finalData[field] = oldData[field] && newData[field];\n    // We actually need to know the set of fields published by the publication that the client side doc came from\n    // but how do we get that?\n\n  });\n\n  return finalData;\n\n};\n\n// Test code for Mongol.diffDocumentData\n\n/*Meteor.startup(function() {\n\n  // Take a user document\n  var sampleDbDoc = { \"_id\" : \"exampleuser1\", \"createdAt\" : 1375253926213, \"defaultPrograms\" : { \"514d75dc97095578800\" : \"MYP\", \"515be068c708000000\" : \"PYP\" }, \"department_id\" : [  \"GMsv9YzaCuL6dFBYL\" ], \"emails\" : [  {  \"address\" : \"aaa@aaa.com\",  \"verified\" : true } ], \"myCourses\" : [  \"QqofEtQPgFb72\",  \"fvTxhAyfMxFbhzwK7\",  \"jcPtgwN6pTMQDEp\" ], \"organization_id\" : [  \"51f76bcbfb1e0d3100\" ], \"permContexts\" : [     {     \"department_id\" : \"GMsv9YzCuL6dFBYL\", \"perms\" : [     \"editRoles\",     \"editCourses\",     \"editUnits\",     \"editAssessments\",     \"editDepartments\" ] } ], \"roleContexts\" : [     {     \"organization_id\" : \"51f76bc23dfb1e0d3100\",     \"school_id\" : \"514d75d9562095578800\",     \"department_id\" : \"GMsv9YzaCuL6dFBYL\",     \"roles\" : [     \"iQD4BhnB8PFWwHCcg\" ] },     {     \"organization_id\" : \"2BjJbMyRLWa4iofQm\" } ], \"school_id\" : [  \"514d75dc97d95095578800\" ], \"services\" : { \"password\" : { \"bcrypt\" : \"$M4235dfre5.5ijyU3.ilpYZQFmtO\" }, \"resume\" : { \"loginTokens\" : [     {     \"when\" : \"2014-12-24T12:00:06.725Z\",     \"hashedToken\" : \"not/telling=\" },     {     \"when\" : \"2015-01-16T04:45:10.574Z\",     \"hashedToken\" : \"bigbadhashedtoken=\" },     {     \"when\" : \"2015-01-22T02:01:57.671Z\",     \"hashedToken\" : \"9HSC98hWA9OByHPA6LbBB8=\" } ] } }, \"superuser\" : [  \"51f76bb1e0d3100\",  \"2BjJbMyRiofQm\",  \"ZkeEcp72bAFQY\" ], \"transaction_id\" : \"shQ9fzcZYSgLLnptC\" };\n\n  // Simulate the oldData getting sent back from the client (the fields should be a subset of the db fields)\n  var sampleOldData = _.extend(_.clone(sampleDbDoc),{dynamicallyAddedField:true, secondDynamicallyAddedField: \"Dynamically added value\"}); // Simulate two dynamically added fields\n  delete sampleOldData.services; // Simulate an unpublished field\n\n  // Simulate the newData getting sent back from the client\n  // e.g. user adds a new field\n  var sampleNewData = _.extend(_.clone(sampleOldData),{brandNewField: true});\n  // brandNewField should be added\n  delete sampleNewData.createdAt; // This should be gone\n  sampleNewData.secondDynamicallyAddedField = \"Dynamically added value overwritten by user\"; // seconddynamicallyAddedField should be gone\n  sampleNewData.transaction_id = \"overwritten transaction id\"; // This field should be changed\n\n  // Run the test\n\n  console.log(Mongol.diffDocumentData(sampleDbDoc, sampleNewData, sampleOldData));\n\n});*/\n\nexport { Utilities }"]},"sourceType":"module","hash":"75461d6d8c46bf5aa3443d18e22abe1879b1da8b"}
