{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/models/methods.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/models/methods.js","filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/models/methods.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/models/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/models/methods.js"}},"code":"const {\n  DDSketch\n} = require('monti-apm-sketches-js');\n\nvar METHOD_METRICS_FIELDS = ['wait', 'db', 'http', 'email', 'async', 'compute', 'total'];\n\nMethodsModel = function (metricsThreshold) {\n  this.methodMetricsByMinute = Object.create(null);\n  this.errorMap = Object.create(null);\n  this._metricsThreshold = _.extend({\n    \"wait\": 100,\n    \"db\": 100,\n    \"http\": 1000,\n    \"email\": 100,\n    \"async\": 100,\n    \"compute\": 100,\n    \"total\": 200\n  }, metricsThreshold || Object.create(null)); //store max time elapsed methods for each method, event(metrics-field)\n\n  this.maxEventTimesForMethods = Object.create(null);\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60,\n    //process traces every minute\n    maxTotalPoints: 30,\n    //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n\n  });\n  this.tracerStore.start();\n};\n\n_.extend(MethodsModel.prototype, KadiraModel.prototype);\n\nMethodsModel.prototype._getMetrics = function (timestamp, method) {\n  var dateId = this._getDateId(timestamp);\n\n  if (!this.methodMetricsByMinute[dateId]) {\n    this.methodMetricsByMinute[dateId] = {\n      methods: Object.create(null)\n    };\n  }\n\n  var methods = this.methodMetricsByMinute[dateId].methods; //initialize method\n\n  if (!methods[method]) {\n    methods[method] = {\n      count: 0,\n      errors: 0,\n      fetchedDocSize: 0,\n      sentMsgSize: 0,\n      histogram: new DDSketch({\n        alpha: 0.02\n      })\n    };\n    METHOD_METRICS_FIELDS.forEach(function (field) {\n      methods[method][field] = 0;\n    });\n  }\n\n  return this.methodMetricsByMinute[dateId].methods[method];\n};\n\nMethodsModel.prototype.setStartTime = function (timestamp) {\n  this.metricsByMinute[dateId].startTime = timestamp;\n};\n\nMethodsModel.prototype.processMethod = function (methodTrace) {\n  var dateId = this._getDateId(methodTrace.at); //append metrics to previous values\n\n\n  this._appendMetrics(dateId, methodTrace);\n\n  if (methodTrace.errored) {\n    this.methodMetricsByMinute[dateId].methods[methodTrace.name].errors++;\n  }\n\n  this.tracerStore.addTrace(methodTrace);\n};\n\nMethodsModel.prototype._appendMetrics = function (id, methodTrace) {\n  var methodMetrics = this._getMetrics(id, methodTrace.name); // startTime needs to be converted into serverTime before sending\n\n\n  if (!this.methodMetricsByMinute[id].startTime) {\n    this.methodMetricsByMinute[id].startTime = methodTrace.at;\n  } //merge\n\n\n  METHOD_METRICS_FIELDS.forEach(function (field) {\n    var value = methodTrace.metrics[field];\n\n    if (value > 0) {\n      methodMetrics[field] += value;\n    }\n  });\n  methodMetrics.count++;\n  methodMetrics.histogram.add(methodTrace.metrics.total);\n  this.methodMetricsByMinute[id].endTime = methodTrace.metrics.at;\n};\n\nMethodsModel.prototype.trackDocSize = function (method, size) {\n  var timestamp = Ntp._now();\n\n  var dateId = this._getDateId(timestamp);\n\n  var methodMetrics = this._getMetrics(dateId, method);\n\n  methodMetrics.fetchedDocSize += size;\n};\n\nMethodsModel.prototype.trackMsgSize = function (method, size) {\n  var timestamp = Ntp._now();\n\n  var dateId = this._getDateId(timestamp);\n\n  var methodMetrics = this._getMetrics(dateId, method);\n\n  methodMetrics.sentMsgSize += size;\n};\n/*\n  There are two types of data\n\n  1. methodMetrics - metrics about the methods (for every 10 secs)\n  2. methodRequests - raw method request. normally max, min for every 1 min and errors always\n*/\n\n\nMethodsModel.prototype.buildPayload = function (buildDetailedInfo) {\n  var payload = {\n    methodMetrics: [],\n    methodRequests: []\n  }; //handling metrics\n\n  var methodMetricsByMinute = this.methodMetricsByMinute;\n  this.methodMetricsByMinute = Object.create(null); //create final paylod for methodMetrics\n\n  for (var key in methodMetricsByMinute) {\n    var methodMetrics = methodMetricsByMinute[key]; // converting startTime into the actual serverTime\n\n    var startTime = methodMetrics.startTime;\n    methodMetrics.startTime = Kadira.syncedDate.syncTime(startTime);\n\n    for (var methodName in methodMetrics.methods) {\n      METHOD_METRICS_FIELDS.forEach(function (field) {\n        methodMetrics.methods[methodName][field] /= methodMetrics.methods[methodName].count;\n      });\n    }\n\n    payload.methodMetrics.push(methodMetricsByMinute[key]);\n  } //collect traces and send them with the payload\n\n\n  payload.methodRequests = this.tracerStore.collectTraces();\n  return payload;\n};","map":{"version":3,"sources":["packages/montiapm:agent/lib/models/methods.js"],"names":["DDSketch","require","METHOD_METRICS_FIELDS","MethodsModel","metricsThreshold","methodMetricsByMinute","Object","create","errorMap","_metricsThreshold","_","extend","maxEventTimesForMethods","tracerStore","TracerStore","interval","maxTotalPoints","archiveEvery","start","prototype","KadiraModel","_getMetrics","timestamp","method","dateId","_getDateId","methods","count","errors","fetchedDocSize","sentMsgSize","histogram","alpha","forEach","field","setStartTime","metricsByMinute","startTime","processMethod","methodTrace","at","_appendMetrics","errored","name","addTrace","id","methodMetrics","value","metrics","add","total","endTime","trackDocSize","size","Ntp","_now","trackMsgSize","buildPayload","buildDetailedInfo","payload","methodRequests","key","Kadira","syncedDate","syncTime","methodName","push","collectTraces"],"mappings":"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","sourcesContent":["const { DDSketch } = require('monti-apm-sketches-js');\n\nvar METHOD_METRICS_FIELDS = ['wait', 'db', 'http', 'email', 'async', 'compute', 'total'];\n\nMethodsModel = function (metricsThreshold) {\n  this.methodMetricsByMinute = Object.create(null);\n  this.errorMap = Object.create(null);\n\n  this._metricsThreshold = _.extend({\n    \"wait\": 100,\n    \"db\": 100,\n    \"http\": 1000,\n    \"email\": 100,\n    \"async\": 100,\n    \"compute\": 100,\n    \"total\": 200\n  }, metricsThreshold || Object.create(null));\n\n  //store max time elapsed methods for each method, event(metrics-field)\n  this.maxEventTimesForMethods = Object.create(null);\n\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60, //process traces every minute\n    maxTotalPoints: 30, //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n  });\n\n  this.tracerStore.start();\n};\n\n_.extend(MethodsModel.prototype, KadiraModel.prototype);\n\nMethodsModel.prototype._getMetrics = function(timestamp, method) {\n  var dateId = this._getDateId(timestamp);\n\n  if(!this.methodMetricsByMinute[dateId]) {\n    this.methodMetricsByMinute[dateId] = {\n      methods: Object.create(null),\n    };\n  }\n\n  var methods = this.methodMetricsByMinute[dateId].methods;\n\n  //initialize method\n  if(!methods[method]) {\n    methods[method] = {\n      count: 0,\n      errors: 0,\n      fetchedDocSize: 0,\n      sentMsgSize: 0,\n      histogram: new DDSketch({\n        alpha: 0.02\n      })\n    };\n\n    METHOD_METRICS_FIELDS.forEach(function(field) {\n      methods[method][field] = 0;\n    });\n  }\n\n  return this.methodMetricsByMinute[dateId].methods[method];\n};\n\nMethodsModel.prototype.setStartTime = function(timestamp) {\n  this.metricsByMinute[dateId].startTime = timestamp;\n}\n\nMethodsModel.prototype.processMethod = function(methodTrace) {\n  var dateId = this._getDateId(methodTrace.at);\n\n  //append metrics to previous values\n  this._appendMetrics(dateId, methodTrace);\n  if(methodTrace.errored) {\n    this.methodMetricsByMinute[dateId].methods[methodTrace.name].errors ++\n  }\n\n  this.tracerStore.addTrace(methodTrace);\n};\n\nMethodsModel.prototype._appendMetrics = function(id, methodTrace) {\n  var methodMetrics = this._getMetrics(id, methodTrace.name)\n\n  // startTime needs to be converted into serverTime before sending\n  if(!this.methodMetricsByMinute[id].startTime){\n    this.methodMetricsByMinute[id].startTime = methodTrace.at;\n  }\n\n  //merge\n  METHOD_METRICS_FIELDS.forEach(function(field) {\n    var value = methodTrace.metrics[field];\n    if(value > 0) {\n      methodMetrics[field] += value;\n    }\n  });\n\n  methodMetrics.count++;\n  methodMetrics.histogram.add(methodTrace.metrics.total);\n  this.methodMetricsByMinute[id].endTime = methodTrace.metrics.at;\n};\n\nMethodsModel.prototype.trackDocSize = function(method, size) {\n  var timestamp = Ntp._now();\n  var dateId = this._getDateId(timestamp);\n\n  var methodMetrics = this._getMetrics(dateId, method);\n  methodMetrics.fetchedDocSize += size;\n}\n\nMethodsModel.prototype.trackMsgSize = function(method, size) {\n  var timestamp = Ntp._now();\n  var dateId = this._getDateId(timestamp);\n\n  var methodMetrics = this._getMetrics(dateId, method);\n  methodMetrics.sentMsgSize += size;\n}\n\n/*\n  There are two types of data\n\n  1. methodMetrics - metrics about the methods (for every 10 secs)\n  2. methodRequests - raw method request. normally max, min for every 1 min and errors always\n*/\nMethodsModel.prototype.buildPayload = function(buildDetailedInfo) {\n  var payload = {\n    methodMetrics: [],\n    methodRequests: []\n  };\n\n  //handling metrics\n  var methodMetricsByMinute = this.methodMetricsByMinute;\n  this.methodMetricsByMinute = Object.create(null);\n\n  //create final paylod for methodMetrics\n  for(var key in methodMetricsByMinute) {\n    var methodMetrics = methodMetricsByMinute[key];\n    // converting startTime into the actual serverTime\n    var startTime = methodMetrics.startTime;\n    methodMetrics.startTime = Kadira.syncedDate.syncTime(startTime);\n\n    for(var methodName in methodMetrics.methods) {\n      METHOD_METRICS_FIELDS.forEach(function(field) {\n        methodMetrics.methods[methodName][field] /=\n          methodMetrics.methods[methodName].count;\n      });\n    }\n\n    payload.methodMetrics.push(methodMetricsByMinute[key]);\n  }\n\n  //collect traces and send them with the payload\n  payload.methodRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n"]},"sourceType":"module","hash":"ee8ceef790c5b0f885b07abf5c16e4eed7ae7d3d"}
