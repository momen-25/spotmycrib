{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/hijack/db.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/hijack/db.js","filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/hijack/db.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/hijack/db.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/hijack/db.js"}},"code":"// This hijack is important to make sure, collections created before\n// we hijack dbOps, even gets tracked.\n//  Meteor does not simply expose MongoConnection object to the client\n//  It picks methods which are necessory and make a binded object and\n//  assigned to the Mongo.Collection\n//  so, even we updated prototype, we can't track those collections\n//  but, this will fix it.\nvar originalOpen = MongoInternals.RemoteCollectionDriver.prototype.open;\n\nMongoInternals.RemoteCollectionDriver.prototype.open = function open(name) {\n  var self = this;\n  var ret = originalOpen.call(self, name);\n\n  _.each(ret, function (fn, m) {\n    // make sure, it's in the actual mongo connection object\n    // meteorhacks:mongo-collection-utils package add some arbitary methods\n    // which does not exist in the mongo connection\n    if (self.mongo[m]) {\n      ret[m] = function () {\n        Array.prototype.unshift.call(arguments, name);\n        return OptimizedApply(self.mongo, self.mongo[m], arguments);\n      };\n    }\n  });\n\n  return ret;\n}; // TODO: this should be added to Meteorx\n\n\nfunction getSyncronousCursor() {\n  const MongoColl = typeof Mongo !== \"undefined\" ? Mongo.Collection : Meteor.Collection;\n  const coll = new MongoColl(\"__dummy_coll_\" + Random.id()); // we need to wait until the db is connected with meteor. findOne does that\n\n  coll.findOne();\n  const cursor = coll.find();\n  cursor.fetch();\n  return cursor._synchronousCursor.constructor;\n}\n\nhijackDBOps = function hijackDBOps() {\n  var mongoConnectionProto = MeteorX.MongoConnection.prototype; //findOne is handled by find - so no need to track it\n  //upsert is handles by update\n\n  ['find', 'update', 'remove', 'insert', '_ensureIndex', '_dropIndex'].forEach(function (func) {\n    var originalFunc = mongoConnectionProto[func];\n\n    mongoConnectionProto[func] = function (collName, selector, mod, options) {\n      var payload = {\n        coll: collName,\n        func: func\n      };\n\n      if (func == 'insert') {//add nothing more to the payload\n      } else if (func == '_ensureIndex' || func == '_dropIndex') {\n        //add index\n        payload.index = JSON.stringify(selector);\n      } else if (func == 'update' && options && options.upsert) {\n        payload.func = 'upsert';\n        payload.selector = JSON.stringify(selector);\n      } else {\n        //all the other functions have selectors\n        payload.selector = JSON.stringify(selector);\n      }\n\n      var kadiraInfo = Kadira._getInfo();\n\n      if (kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n      } //this cause V8 to avoid any performance optimizations, but this is must to use\n      //otherwise, if the error adds try catch block our logs get messy and didn't work\n      //see: issue #6\n\n\n      try {\n        var ret = originalFunc.apply(this, arguments); //handling functions which can be triggered with an asyncCallback\n\n        var endOptions = {};\n\n        if (HaveAsyncCallback(arguments)) {\n          endOptions.async = true;\n        }\n\n        if (func == 'update') {\n          // upsert only returns an object when called `upsert` directly\n          // otherwise it only act an update command\n          if (options && options.upsert && typeof ret == 'object') {\n            endOptions.updatedDocs = ret.numberAffected;\n            endOptions.insertedId = ret.insertedId;\n          } else {\n            endOptions.updatedDocs = ret;\n          }\n        } else if (func == 'remove') {\n          endOptions.removedDocs = ret;\n        }\n\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\n        }\n      } catch (ex) {\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {\n            err: ex.message\n          });\n        }\n\n        throw ex;\n      }\n\n      return ret;\n    };\n  });\n  var cursorProto = MeteorX.MongoCursor.prototype;\n  ['forEach', 'map', 'fetch', 'count', 'observeChanges', 'observe'].forEach(function (type) {\n    var originalFunc = cursorProto[type];\n\n    cursorProto[type] = function () {\n      var cursorDescription = this._cursorDescription;\n      var payload = Object.assign(Object.create(null), {\n        coll: cursorDescription.collectionName,\n        selector: JSON.stringify(cursorDescription.selector),\n        func: type,\n        cursor: true\n      });\n\n      if (cursorDescription.options) {\n        var cursorOptions = _.pick(cursorDescription.options, ['fields', 'sort', 'limit']);\n\n        for (var field in cursorOptions) {\n          var value = cursorOptions[field];\n\n          if (typeof value == 'object') {\n            value = JSON.stringify(value);\n          }\n\n          payload[field] = value;\n        }\n      }\n\n      var kadiraInfo = Kadira._getInfo();\n\n      var previousTrackNextObject;\n\n      if (kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n        previousTrackNextObject = kadiraInfo.trackNextObject;\n\n        if (type === 'forEach' || type === 'map') {\n          kadiraInfo.trackNextObject = true;\n        }\n      }\n\n      try {\n        var ret = originalFunc.apply(this, arguments);\n        var endData = {};\n\n        if (type == 'observeChanges' || type == 'observe') {\n          var observerDriver;\n          endData.oplog = false; // get data written by the multiplexer\n\n          endData.wasMultiplexerReady = ret._wasMultiplexerReady;\n          endData.queueLength = ret._queueLength;\n          endData.elapsedPollingTime = ret._elapsedPollingTime;\n\n          if (ret._multiplexer) {\n            // older meteor versions done not have an _multiplexer value\n            observerDriver = ret._multiplexer._observeDriver;\n\n            if (observerDriver) {\n              observerDriver = ret._multiplexer._observeDriver;\n              var observerDriverClass = observerDriver.constructor;\n              var usesOplog = typeof observerDriverClass.cursorSupported == 'function';\n              endData.oplog = usesOplog;\n              var size = 0;\n\n              ret._multiplexer._cache.docs.forEach(function () {\n                size++;\n              });\n\n              endData.noOfCachedDocs = size; // if multiplexerWasNotReady, we need to get the time spend for the polling\n\n              if (!ret._wasMultiplexerReady) {\n                endData.initialPollingTime = observerDriver._lastPollTime;\n              }\n            }\n          }\n\n          if (!endData.oplog) {\n            // let's try to find the reason\n            var reasonInfo = Kadira.checkWhyNoOplog(cursorDescription, observerDriver);\n            endData.noOplogCode = reasonInfo.code;\n            endData.noOplogReason = reasonInfo.reason;\n            endData.noOplogSolution = reasonInfo.solution;\n          }\n        } else if (type == 'fetch' || type == 'map') {\n          //for other cursor operation\n          endData.docsFetched = ret.length;\n\n          if (type == 'fetch') {\n            var coll = cursorDescription.collectionName;\n            var query = cursorDescription.selector;\n            var opts = cursorDescription.options;\n            var docSize = Kadira.docSzCache.getSize(coll, query, opts, ret) * ret.length;\n            endData.docSize = docSize;\n\n            if (kadiraInfo) {\n              if (kadiraInfo.trace.type === 'method') {\n                Kadira.models.methods.trackDocSize(kadiraInfo.trace.name, docSize);\n              } else if (kadiraInfo.trace.type === 'sub') {\n                Kadira.models.pubsub.trackDocSize(kadiraInfo.trace.name, \"cursorFetches\", docSize);\n              }\n\n              kadiraInfo.trackNextObject = previousTrackNextObject;\n            } else {\n              // Fetch with no kadira info are tracked as from a null method\n              Kadira.models.methods.trackDocSize(\"<not-a-method-or-a-pub>\", docSize);\n            } // TODO: Add doc size tracking to `map` as well.\n\n          }\n        }\n\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endData);\n        }\n\n        return ret;\n      } catch (ex) {\n        if (eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {\n            err: ex.message\n          });\n        }\n\n        throw ex;\n      }\n    };\n  });\n  const SyncronousCursor = getSyncronousCursor();\n  var origNextObject = SyncronousCursor.prototype._nextObject;\n\n  SyncronousCursor.prototype._nextObject = function () {\n    var kadiraInfo = Kadira._getInfo();\n\n    var shouldTrack = kadiraInfo && kadiraInfo.trackNextObject;\n\n    if (shouldTrack) {\n      var event = Kadira.tracer.event(kadiraInfo.trace, 'db', {\n        func: '_nextObject',\n        coll: this._cursorDescription.collectionName\n      });\n    }\n\n    var result = origNextObject.call(this);\n\n    if (shouldTrack) {\n      Kadira.tracer.eventEnd(kadiraInfo.trace, event);\n    }\n\n    return result;\n  };\n};","map":{"version":3,"sources":["packages/montiapm:agent/lib/hijack/db.js"],"names":["originalOpen","MongoInternals","RemoteCollectionDriver","prototype","open","name","self","ret","call","_","each","fn","m","mongo","Array","unshift","arguments","OptimizedApply","getSyncronousCursor","MongoColl","Mongo","Collection","Meteor","coll","Random","id","findOne","cursor","find","fetch","_synchronousCursor","constructor","hijackDBOps","mongoConnectionProto","MeteorX","MongoConnection","forEach","func","originalFunc","collName","selector","mod","options","payload","index","JSON","stringify","upsert","kadiraInfo","Kadira","_getInfo","eventId","tracer","event","trace","apply","endOptions","HaveAsyncCallback","async","updatedDocs","numberAffected","insertedId","removedDocs","eventEnd","ex","err","message","cursorProto","MongoCursor","type","cursorDescription","_cursorDescription","Object","assign","create","collectionName","cursorOptions","pick","field","value","previousTrackNextObject","trackNextObject","endData","observerDriver","oplog","wasMultiplexerReady","_wasMultiplexerReady","queueLength","_queueLength","elapsedPollingTime","_elapsedPollingTime","_multiplexer","_observeDriver","observerDriverClass","usesOplog","cursorSupported","size","_cache","docs","noOfCachedDocs","initialPollingTime","_lastPollTime","reasonInfo","checkWhyNoOplog","noOplogCode","code","noOplogReason","reason","noOplogSolution","solution","docsFetched","length","query","opts","docSize","docSzCache","getSize","models","methods","trackDocSize","pubsub","SyncronousCursor","origNextObject","_nextObject","shouldTrack","result"],"mappings":"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","sourcesContent":["// This hijack is important to make sure, collections created before\n// we hijack dbOps, even gets tracked.\n//  Meteor does not simply expose MongoConnection object to the client\n//  It picks methods which are necessory and make a binded object and\n//  assigned to the Mongo.Collection\n//  so, even we updated prototype, we can't track those collections\n//  but, this will fix it.\nvar originalOpen = MongoInternals.RemoteCollectionDriver.prototype.open;\nMongoInternals.RemoteCollectionDriver.prototype.open = function open(name) {\n  var self = this;\n  var ret = originalOpen.call(self, name);\n\n  _.each(ret, function(fn, m) {\n    // make sure, it's in the actual mongo connection object\n    // meteorhacks:mongo-collection-utils package add some arbitary methods\n    // which does not exist in the mongo connection\n    if(self.mongo[m]) {\n      ret[m] = function() {\n        Array.prototype.unshift.call(arguments, name);\n        return OptimizedApply(self.mongo, self.mongo[m], arguments);\n      };\n    }\n  });\n\n  return ret;\n};\n\n// TODO: this should be added to Meteorx\nfunction getSyncronousCursor() {\n  const MongoColl = typeof Mongo !== \"undefined\" ? Mongo.Collection : Meteor.Collection;\n  const coll = new MongoColl(\"__dummy_coll_\" + Random.id());\n  // we need to wait until the db is connected with meteor. findOne does that\n  coll.findOne();\n  \n  const cursor = coll.find();\n  cursor.fetch();\n  return cursor._synchronousCursor.constructor\n}\n\nhijackDBOps = function hijackDBOps() {\n  var mongoConnectionProto = MeteorX.MongoConnection.prototype;\n  //findOne is handled by find - so no need to track it\n  //upsert is handles by update\n  ['find', 'update', 'remove', 'insert', '_ensureIndex', '_dropIndex'].forEach(function(func) {\n    var originalFunc = mongoConnectionProto[func];\n    mongoConnectionProto[func] = function(collName, selector, mod, options) {\n      var payload = {\n        coll: collName,\n        func: func,\n      };\n\n      if(func == 'insert') {\n        //add nothing more to the payload\n      } else if(func == '_ensureIndex' || func == '_dropIndex') {\n        //add index\n        payload.index = JSON.stringify(selector);\n      } else if(func == 'update' && options && options.upsert) {\n        payload.func = 'upsert';\n        payload.selector = JSON.stringify(selector);\n      } else {\n        //all the other functions have selectors\n        payload.selector = JSON.stringify(selector);\n      }\n\n      var kadiraInfo = Kadira._getInfo();\n      if(kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n      }\n\n      //this cause V8 to avoid any performance optimizations, but this is must to use\n      //otherwise, if the error adds try catch block our logs get messy and didn't work\n      //see: issue #6\n      try{\n        var ret = originalFunc.apply(this, arguments);\n        //handling functions which can be triggered with an asyncCallback\n        var endOptions = {};\n\n        if(HaveAsyncCallback(arguments)) {\n          endOptions.async = true;\n        }\n\n        if(func == 'update') {\n          // upsert only returns an object when called `upsert` directly\n          // otherwise it only act an update command\n          if(options && options.upsert && typeof ret == 'object') {\n            endOptions.updatedDocs = ret.numberAffected;\n            endOptions.insertedId = ret.insertedId;\n          } else {\n            endOptions.updatedDocs = ret;\n          }\n        } else if(func == 'remove') {\n          endOptions.removedDocs = ret;\n        }\n\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\n        }\n      } catch(ex) {\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n        }\n        throw ex;\n      }\n\n      return ret;\n    };\n  });\n\n  var cursorProto = MeteorX.MongoCursor.prototype;\n  ['forEach', 'map', 'fetch', 'count', 'observeChanges', 'observe'].forEach(function(type) {\n    var originalFunc = cursorProto[type];\n    cursorProto[type] = function() {\n      var cursorDescription = this._cursorDescription;\n      var payload = Object.assign(Object.create(null), {\n        coll: cursorDescription.collectionName,\n        selector: JSON.stringify(cursorDescription.selector),\n        func: type,\n        cursor: true\n      });\n\n      if(cursorDescription.options) {\n        var cursorOptions = _.pick(cursorDescription.options, ['fields', 'sort', 'limit']);\n        for(var field in cursorOptions) {\n          var value = cursorOptions[field]\n          if(typeof value == 'object') {\n            value = JSON.stringify(value);\n          }\n          payload[field] = value;\n        }\n      }\n\n      var kadiraInfo = Kadira._getInfo();\n      var previousTrackNextObject;\n      if(kadiraInfo) {\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n\n        previousTrackNextObject = kadiraInfo.trackNextObject\n        if (type === 'forEach' || type === 'map') {\n          kadiraInfo.trackNextObject = true;\n        }\n      }\n\n      try{\n        var ret = originalFunc.apply(this, arguments);\n\n        var endData = {};\n        if(type == 'observeChanges' || type == 'observe') {\n          var observerDriver;\n          endData.oplog = false;\n          // get data written by the multiplexer\n          endData.wasMultiplexerReady = ret._wasMultiplexerReady;\n          endData.queueLength = ret._queueLength;\n          endData.elapsedPollingTime = ret._elapsedPollingTime;\n\n          if(ret._multiplexer) {\n            // older meteor versions done not have an _multiplexer value\n            observerDriver = ret._multiplexer._observeDriver;\n            if(observerDriver) {\n              observerDriver = ret._multiplexer._observeDriver;\n              var observerDriverClass = observerDriver.constructor;\n              var usesOplog = typeof observerDriverClass.cursorSupported == 'function';\n              endData.oplog = usesOplog;\n              var size = 0;\n              ret._multiplexer._cache.docs.forEach(function() {size++});\n              endData.noOfCachedDocs = size;\n\n              // if multiplexerWasNotReady, we need to get the time spend for the polling\n              if(!ret._wasMultiplexerReady) {\n                endData.initialPollingTime = observerDriver._lastPollTime;\n              }\n            }\n          }\n\n          if(!endData.oplog) {\n            // let's try to find the reason\n            var reasonInfo = Kadira.checkWhyNoOplog(cursorDescription, observerDriver);\n            endData.noOplogCode = reasonInfo.code;\n            endData.noOplogReason = reasonInfo.reason;\n            endData.noOplogSolution = reasonInfo.solution;\n          }\n        } else if(type == 'fetch' || type == 'map'){\n          //for other cursor operation\n\n          endData.docsFetched = ret.length;\n\n          if(type == 'fetch') {\n            var coll = cursorDescription.collectionName;\n            var query = cursorDescription.selector;\n            var opts = cursorDescription.options;\n            var docSize = Kadira.docSzCache.getSize(coll, query, opts, ret) * ret.length;\n            endData.docSize = docSize;\n\n            if(kadiraInfo) {\n              if(kadiraInfo.trace.type === 'method') {\n                Kadira.models.methods.trackDocSize(kadiraInfo.trace.name, docSize);\n              } else if(kadiraInfo.trace.type === 'sub') {\n                Kadira.models.pubsub.trackDocSize(kadiraInfo.trace.name, \"cursorFetches\", docSize);\n              }\n\n              kadiraInfo.trackNextObject = previousTrackNextObject\n            } else {\n              // Fetch with no kadira info are tracked as from a null method\n              Kadira.models.methods.trackDocSize(\"<not-a-method-or-a-pub>\", docSize);\n            }\n\n            // TODO: Add doc size tracking to `map` as well.\n          }\n        }\n\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endData);\n        }\n        return ret;\n      } catch(ex) {\n        if(eventId) {\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n        }\n        throw ex;\n      }\n    };\n  });\n\n  const SyncronousCursor = getSyncronousCursor();\n  var origNextObject = SyncronousCursor.prototype._nextObject\n  SyncronousCursor.prototype._nextObject = function () {\n    var kadiraInfo = Kadira._getInfo();\n    var shouldTrack = kadiraInfo && kadiraInfo.trackNextObject;\n    if(shouldTrack ) {\n      var event = Kadira.tracer.event(kadiraInfo.trace, 'db', {\n        func: '_nextObject',\n        coll: this._cursorDescription.collectionName\n      });\n    }\n\n    var result = origNextObject.call(this);\n\n    if (shouldTrack) {\n      Kadira.tracer.eventEnd(kadiraInfo.trace, event);\n    }\n    return result;\n  }\n};\n"]},"sourceType":"module","hash":"c14be5ac1cc61f773143ff9220bed072da3d1a73"}
