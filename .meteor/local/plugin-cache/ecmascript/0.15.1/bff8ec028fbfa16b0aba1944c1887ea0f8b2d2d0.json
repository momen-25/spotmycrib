{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/tracer/tracer.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/tracer/tracer.js","filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/tracer/tracer.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/momen/projects/spotmycrib-master","root":"/home/momen/projects/spotmycrib-master","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.13.10","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/momen/projects/spotmycrib-master/packages/montiapm:agent/lib/tracer/tracer.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/tracer/tracer.js"}},"code":"var eventLogger = Npm.require('debug')('kadira:tracer');\n\nvar REPETITIVE_EVENTS = {\n  'db': true,\n  'http': true,\n  'email': true,\n  'wait': true,\n  'async': true,\n  'custom': true,\n  'fs': true\n};\nvar TRACE_TYPES = ['sub', 'method', 'http'];\nvar MAX_TRACE_EVENTS = 1500;\n\nTracer = function Tracer() {\n  this._filters = [];\n  this._filterFields = ['password'];\n  this.maxArrayItemsToFilter = 20;\n}; //In the future, we might wan't to track inner fiber events too.\n//Then we can't serialize the object with methods\n//That's why we use this method of returning the data\n\n\nTracer.prototype.start = function (name, type) {\n  let {\n    sessionId,\n    msgId,\n    userId\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // for backward compatibility\n  if (typeof name === 'object' && typeof type === 'object') {\n    let session = name;\n    let msg = type;\n    sessionId = session.id;\n    msgId = msg.id;\n    userId = session.userId;\n\n    if (msg.msg == 'method') {\n      type = 'method';\n      name = msg.method;\n    } else if (msg.msg == 'sub') {\n      type = 'sub';\n      name = msg.name;\n    } else {\n      return null;\n    }\n  }\n\n  if (TRACE_TYPES.indexOf(type) === -1) {\n    console.warn(\"Monti APM: unknown trace type \\\"\".concat(type, \"\\\"\"));\n    return null;\n  }\n\n  var traceInfo = {\n    _id: \"\".concat(sessionId, \"::\").concat(msgId || DefaultUniqueId.get()),\n    type,\n    name,\n    session: sessionId,\n    id: msgId,\n    events: [],\n    userId\n  };\n  return traceInfo;\n};\n\nTracer.prototype.event = function (traceInfo, type, data, metaData) {\n  // do not allow to proceed, if already completed or errored\n  var lastEvent = this.getLastEvent(traceInfo);\n\n  if ( // trace completed but has not been processed\n  lastEvent && ['complete', 'error'].indexOf(lastEvent.type) >= 0 || // trace completed and processed.\n  traceInfo.isEventsProcessed) {\n    return false;\n  }\n\n  var event = {\n    type,\n    at: Ntp._now(),\n    endAt: null,\n    nested: []\n  }; // special handling for events that are not repetitive\n\n  if (!REPETITIVE_EVENTS[type]) {\n    event.endAt = event.at;\n  }\n\n  if (data) {\n    var info = _.pick(traceInfo, 'type', 'name');\n\n    event.data = this._applyFilters(type, data, info, \"start\");\n  }\n\n  if (metaData && metaData.name) {\n    event.name = metaData.name;\n  }\n\n  if (Kadira.options.eventStackTrace) {\n    event.stack = CreateUserStack();\n  }\n\n  eventLogger(\"%s %s\", type, traceInfo._id);\n\n  if (lastEvent && !lastEvent.endAt) {\n    if (!lastEvent.nested) {\n      console.error('Monti: invalid trace. Please share the trace below at');\n      console.error('Monti: https://github.com/monti-apm/monti-apm-agent/issues/14');\n      console.dir(traceInfo, {\n        depth: 10\n      });\n    }\n\n    var lastNested = lastEvent.nested[lastEvent.nested.length - 1]; // Only nest one level\n\n    if (!lastNested || lastNested.endAt) {\n      lastEvent.nested.push(event);\n      return event;\n    }\n\n    return false;\n  }\n\n  traceInfo.events.push(event);\n  return event;\n};\n\nTracer.prototype.eventEnd = function (traceInfo, event, data) {\n  if (event.endAt) {\n    // Event already ended or is not a repititive event\n    return false;\n  }\n\n  event.endAt = Ntp._now();\n\n  if (data) {\n    var info = _.pick(traceInfo, 'type', 'name');\n\n    event.data = Object.assign(event.data || {}, this._applyFilters(\"\".concat(event.type, \"end\"), data, info, 'end'));\n  }\n\n  eventLogger(\"%s %s\", event.type + 'end', traceInfo._id);\n  return true;\n};\n\nTracer.prototype.getLastEvent = function (traceInfo) {\n  return traceInfo.events[traceInfo.events.length - 1];\n};\n\nTracer.prototype.endLastEvent = function (traceInfo) {\n  var lastEvent = this.getLastEvent(traceInfo);\n\n  if (!lastEvent.endAt) {\n    this.eventEnd(traceInfo, lastEvent);\n    lastEvent.forcedEnd = true;\n    return true;\n  }\n\n  return false;\n}; // Most of the time, all of the nested events are async\n// which is not helpful. This returns true if\n// there are nested events other than async.\n\n\nTracer.prototype._hasUsefulNested = function (event) {\n  return !event.nested.every(event => {\n    return event.type === 'async';\n  });\n};\n\nTracer.prototype.buildEvent = function (event) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let trace = arguments.length > 2 ? arguments[2] : undefined;\n  var elapsedTimeForEvent = event.endAt - event.at;\n  var builtEvent = [event.type];\n  var nested = [];\n  builtEvent.push(elapsedTimeForEvent);\n  builtEvent.push(event.data || {});\n\n  if (event.nested.length && this._hasUsefulNested(event)) {\n    let prevEnd = event.at;\n\n    for (let i = 0; i < event.nested.length; i++) {\n      var nestedEvent = event.nested[i];\n\n      if (!nestedEvent.endAt) {\n        this.eventEnd(trace, nestedEvent);\n        nestedEvent.forcedEnd = true;\n      }\n\n      var computeTime = nestedEvent.at - prevEnd;\n\n      if (computeTime > 0) {\n        nested.push(['compute', computeTime]);\n      }\n\n      nested.push(this.buildEvent(nestedEvent, depth + 1, trace));\n      prevEnd = nestedEvent.endAt;\n    }\n  }\n\n  if (nested.length || event.stack || event.forcedEnd || event.name) {\n    builtEvent.push({\n      stack: event.stack,\n      nested: nested.length ? nested : undefined,\n      forcedEnd: event.forcedEnd,\n      name: event.name\n    });\n  }\n\n  return builtEvent;\n};\n\nTracer.prototype.buildTrace = function (traceInfo) {\n  var firstEvent = traceInfo.events[0];\n  var lastEvent = traceInfo.events[traceInfo.events.length - 1];\n  var processedEvents = [];\n\n  if (firstEvent.type !== 'start') {\n    console.warn('Monti APM: trace has not started yet');\n    return null;\n  } else if (lastEvent.type !== 'complete' && lastEvent.type !== 'error') {\n    //trace is not completed or errored yet\n    console.warn('Monti APM: trace has not completed or errored yet');\n    return null;\n  } else {\n    //build the metrics\n    traceInfo.errored = lastEvent.type === 'error';\n    traceInfo.at = firstEvent.at;\n    var metrics = {\n      total: lastEvent.at - firstEvent.at\n    };\n    var totalNonCompute = 0;\n    firstEvent = ['start', 0];\n\n    if (traceInfo.events[0].data) {\n      firstEvent.push(traceInfo.events[0].data);\n    }\n\n    processedEvents.push(firstEvent);\n\n    for (var lc = 1; lc < traceInfo.events.length - 1; lc += 1) {\n      var prevEvent = traceInfo.events[lc - 1];\n      var event = traceInfo.events[lc];\n\n      if (!event.endAt) {\n        console.error('Monti APM: no end event for type: ', event.type);\n        return null;\n      }\n\n      var computeTime = event.at - prevEvent.endAt;\n\n      if (computeTime > 0) {\n        processedEvents.push(['compute', computeTime]);\n      }\n\n      var builtEvent = this.buildEvent(event, 0, traceInfo);\n      processedEvents.push(builtEvent);\n      metrics[event.type] = metrics[event.type] || 0;\n      metrics[event.type] += builtEvent[1];\n      totalNonCompute += builtEvent[1];\n    }\n  }\n\n  computeTime = lastEvent.at - traceInfo.events[traceInfo.events.length - 2].endAt;\n  if (computeTime > 0) processedEvents.push(['compute', computeTime]);\n  var lastEventData = [lastEvent.type, 0];\n  if (lastEvent.data) lastEventData.push(lastEvent.data);\n  processedEvents.push(lastEventData);\n\n  if (processedEvents.length > MAX_TRACE_EVENTS) {\n    const removeCount = processedEvents.length - MAX_TRACE_EVENTS;\n    processedEvents.splice(MAX_TRACE_EVENTS, removeCount);\n  }\n\n  metrics.compute = metrics.total - totalNonCompute;\n  traceInfo.metrics = metrics;\n  traceInfo.events = processedEvents;\n  traceInfo.isEventsProcessed = true;\n  return traceInfo;\n};\n\nTracer.prototype.addFilter = function (filterFn) {\n  this._filters.push(filterFn);\n};\n\nTracer.prototype.redactField = function (field) {\n  this._filterFields.push(field);\n};\n\nTracer.prototype._applyFilters = function (eventType, data, info) {\n  this._filters.forEach(function (filterFn) {\n    data = filterFn(eventType, _.clone(data), info);\n  });\n\n  return data;\n};\n\nTracer.prototype._applyObjectFilters = function (toFilter) {\n  const filterObject = obj => {\n    let cloned;\n\n    this._filterFields.forEach(function (field) {\n      if (field in obj) {\n        cloned = cloned || Object.assign({}, obj);\n        cloned[field] = 'Monti: redacted';\n      }\n    });\n\n    return cloned;\n  };\n\n  if (Array.isArray(toFilter)) {\n    let cloned; // There could be thousands or more items in the array, and this usually runs\n    // before the data is validated. For performance reasons we limit how\n    // many to check\n\n    let length = Math.min(toFilter.length, this.maxArrayItemsToFilter);\n\n    for (let i = 0; i < length; i++) {\n      if (typeof toFilter[i] === 'object' && toFilter[i] !== null) {\n        let result = filterObject(toFilter[i]);\n\n        if (result) {\n          cloned = cloned || [...toFilter];\n          cloned[i] = result;\n        }\n      }\n    }\n\n    return cloned || toFilter;\n  }\n\n  return filterObject(toFilter) || toFilter;\n};\n\nKadira.tracer = new Tracer(); // need to expose Tracer to provide default set of filters\n\nKadira.Tracer = Tracer;","map":{"version":3,"sources":["packages/montiapm:agent/lib/tracer/tracer.js"],"names":["eventLogger","Npm","require","REPETITIVE_EVENTS","TRACE_TYPES","MAX_TRACE_EVENTS","Tracer","_filters","_filterFields","maxArrayItemsToFilter","prototype","start","name","type","sessionId","msgId","userId","session","msg","id","method","indexOf","console","warn","traceInfo","_id","DefaultUniqueId","get","events","event","data","metaData","lastEvent","getLastEvent","isEventsProcessed","at","Ntp","_now","endAt","nested","info","_","pick","_applyFilters","Kadira","options","eventStackTrace","stack","CreateUserStack","error","dir","depth","lastNested","length","push","eventEnd","Object","assign","endLastEvent","forcedEnd","_hasUsefulNested","every","buildEvent","trace","elapsedTimeForEvent","builtEvent","prevEnd","i","nestedEvent","computeTime","undefined","buildTrace","firstEvent","processedEvents","errored","metrics","total","totalNonCompute","lc","prevEvent","lastEventData","removeCount","splice","compute","addFilter","filterFn","redactField","field","eventType","forEach","clone","_applyObjectFilters","toFilter","filterObject","obj","cloned","Array","isArray","Math","min","result","tracer"],"mappings":"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","sourcesContent":["var eventLogger = Npm.require('debug')('kadira:tracer');\nvar REPETITIVE_EVENTS = {'db': true, 'http': true, 'email': true, 'wait': true, 'async': true, 'custom': true, 'fs': true};\nvar TRACE_TYPES = ['sub', 'method', 'http'];\nvar MAX_TRACE_EVENTS = 1500;\n\nTracer = function Tracer() {\n  this._filters = [];\n  this._filterFields = ['password'];\n  this.maxArrayItemsToFilter = 20;\n};\n\n//In the future, we might wan't to track inner fiber events too.\n//Then we can't serialize the object with methods\n//That's why we use this method of returning the data\nTracer.prototype.start = function (name, type, {\n  sessionId,\n  msgId,\n  userId\n} = {}) {\n\n  // for backward compatibility\n  if (typeof name === 'object' && typeof type === 'object') {\n    let session = name;\n    let msg = type;\n    sessionId = session.id;\n    msgId = msg.id;\n    userId = session.userId;\n\n    if(msg.msg == 'method') {\n      type = 'method';\n      name = msg.method;\n    } else if(msg.msg == 'sub') {\n      type = 'sub';\n      name = msg.name;\n    } else {\n      return null;\n    }\n  }\n\n  if (TRACE_TYPES.indexOf(type) === -1) {\n    console.warn(`Monti APM: unknown trace type \"${type}\"`);\n    return null;\n  }\n\n\n  var traceInfo = {\n    _id: `${sessionId}::${msgId || DefaultUniqueId.get()}`,\n    type,\n    name,\n    session: sessionId,\n    id: msgId,\n    events: [],\n    userId,\n  };\n\n  return traceInfo;\n};\n\nTracer.prototype.event = function (traceInfo, type, data, metaData) {\n  // do not allow to proceed, if already completed or errored\n  var lastEvent = this.getLastEvent(traceInfo);\n\n  if(\n    // trace completed but has not been processed\n    lastEvent &&\n    ['complete', 'error'].indexOf(lastEvent.type) >= 0 ||\n    // trace completed and processed.\n    traceInfo.isEventsProcessed\n    ) {\n    return false;\n  }\n\n  var event = {\n    type,\n    at: Ntp._now(),\n    endAt: null,\n    nested: [],\n  };\n\n  // special handling for events that are not repetitive\n  if (!REPETITIVE_EVENTS[type]) {\n    event.endAt = event.at;\n  }\n\n  if(data) {\n    var info = _.pick(traceInfo, 'type', 'name')\n    event.data = this._applyFilters(type, data, info, \"start\");\n  }\n\n  if (metaData && metaData.name) {\n    event.name = metaData.name\n  }\n\n  if (Kadira.options.eventStackTrace) {\n    event.stack = CreateUserStack()\n  }\n  \n  eventLogger(\"%s %s\", type, traceInfo._id);\n\n  if (lastEvent && !lastEvent.endAt) {\n    if (!lastEvent.nested) {\n      console.error('Monti: invalid trace. Please share the trace below at');\n      console.error('Monti: https://github.com/monti-apm/monti-apm-agent/issues/14');\n      console.dir(traceInfo, { depth: 10 });\n    }\n    var lastNested = lastEvent.nested[lastEvent.nested.length - 1];\n\n    // Only nest one level\n    if (!lastNested || lastNested.endAt) {\n      lastEvent.nested.push(event);\n      return event;\n    }\n\n    return false;\n  }\n  \n  traceInfo.events.push(event);\n\n  return event;\n};\n\nTracer.prototype.eventEnd = function(traceInfo, event, data) {\n  if (event.endAt) {\n    // Event already ended or is not a repititive event\n    return false;\n  }\n\n  event.endAt = Ntp._now();\n\n  if(data) {\n    var info = _.pick(traceInfo, 'type', 'name')\n    event.data = Object.assign(\n      event.data || {},\n      this._applyFilters(`${event.type}end`, data, info, 'end')\n    );\n  }\n  eventLogger(\"%s %s\", event.type + 'end', traceInfo._id);\n\n  return true;\n};\n\nTracer.prototype.getLastEvent = function(traceInfo) {\n  return traceInfo.events[traceInfo.events.length -1]\n};\n\nTracer.prototype.endLastEvent = function(traceInfo) {\n  var lastEvent = this.getLastEvent(traceInfo);\n\n  if (!lastEvent.endAt) {\n    this.eventEnd(traceInfo, lastEvent);\n    lastEvent.forcedEnd = true;\n    return true;\n  }\n  return false;\n};\n\n// Most of the time, all of the nested events are async\n// which is not helpful. This returns true if\n// there are nested events other than async.\nTracer.prototype._hasUsefulNested = function (event) {\n  return !event.nested.every(event => {\n    return event.type === 'async';\n  });\n}\n\nTracer.prototype.buildEvent = function(event, depth = 0, trace) {\n  var elapsedTimeForEvent = event.endAt - event.at;\n  var builtEvent = [event.type];\n  var nested = [];\n\n  builtEvent.push(elapsedTimeForEvent);\n  builtEvent.push(event.data || {});\n  \n  if (event.nested.length && this._hasUsefulNested(event)) {\n    let prevEnd = event.at;\n    for(let i = 0; i < event.nested.length; i++) {\n      var nestedEvent = event.nested[i];\n      if (!nestedEvent.endAt) {\n        this.eventEnd(trace, nestedEvent);\n        nestedEvent.forcedEnd = true;\n      }\n\n      var computeTime = nestedEvent.at - prevEnd;\n      if (computeTime > 0) {\n        nested.push(['compute', computeTime]);\n      }\n\n      nested.push(this.buildEvent(nestedEvent, depth + 1, trace));\n      prevEnd = nestedEvent.endAt;\n    }\n  }\n\n\n  if (\n    nested.length ||\n    event.stack ||\n    event.forcedEnd ||\n    event.name\n  ) {\n    builtEvent.push({\n      stack: event.stack,\n      nested: nested.length ? nested : undefined,\n      forcedEnd: event.forcedEnd,\n      name: event.name\n    });\n  }\n\n  return builtEvent;\n}\n\nTracer.prototype.buildTrace = function (traceInfo) {\n  var firstEvent = traceInfo.events[0];\n  var lastEvent = traceInfo.events[traceInfo.events.length - 1];\n  var processedEvents = [];\n\n  if (firstEvent.type !== 'start') {\n    console.warn('Monti APM: trace has not started yet');\n    return null;\n  } else if (lastEvent.type !== 'complete' && lastEvent.type !== 'error') {\n    //trace is not completed or errored yet\n    console.warn('Monti APM: trace has not completed or errored yet');\n    return null;\n  } else {\n    //build the metrics\n    traceInfo.errored = lastEvent.type === 'error';\n    traceInfo.at = firstEvent.at;\n\n    var metrics = {\n      total: lastEvent.at - firstEvent.at,\n    };\n\n    var totalNonCompute = 0;\n\n    firstEvent = ['start', 0];\n    if (traceInfo.events[0].data) {\n      firstEvent.push(traceInfo.events[0].data);\n    }\n    processedEvents.push(firstEvent);\n\n    for (var lc = 1; lc < traceInfo.events.length - 1; lc += 1) {\n      var prevEvent = traceInfo.events[lc - 1];\n      var event = traceInfo.events[lc];\n\n      if (!event.endAt) {\n        console.error('Monti APM: no end event for type: ', event.type);\n        return null;\n      }\n\n      var computeTime = event.at - prevEvent.endAt;\n      if (computeTime > 0) {\n        processedEvents.push(['compute', computeTime]);\n      }\n      var builtEvent = this.buildEvent(event, 0, traceInfo);\n      processedEvents.push(builtEvent);\n\n      metrics[event.type] = metrics[event.type] || 0;\n      metrics[event.type] += builtEvent[1];\n      totalNonCompute += builtEvent[1];\n    }\n  }\n\n  computeTime = lastEvent.at - traceInfo.events[traceInfo.events.length - 2].endAt;\n  if(computeTime > 0) processedEvents.push(['compute', computeTime]);\n\n  var lastEventData = [lastEvent.type, 0];\n  if(lastEvent.data) lastEventData.push(lastEvent.data);\n  processedEvents.push(lastEventData);\n\n  if (processedEvents.length > MAX_TRACE_EVENTS) {\n    const removeCount = processedEvents.length - MAX_TRACE_EVENTS\n    processedEvents.splice(MAX_TRACE_EVENTS, removeCount);\n  }\n\n  metrics.compute = metrics.total - totalNonCompute;\n  traceInfo.metrics = metrics;\n  traceInfo.events = processedEvents;\n  traceInfo.isEventsProcessed = true;\n  return traceInfo;\n};\n\nTracer.prototype.addFilter = function(filterFn) {\n  this._filters.push(filterFn);\n};\n\nTracer.prototype.redactField = function (field) {\n  this._filterFields.push(field);\n};\n\nTracer.prototype._applyFilters = function(eventType, data, info) {\n  this._filters.forEach(function(filterFn) {\n    data = filterFn(eventType, _.clone(data), info);\n  });\n\n  return data;\n};\n\nTracer.prototype._applyObjectFilters = function (toFilter) {\n  const filterObject = (obj) => {\n    let cloned;\n    this._filterFields.forEach(function (field) {\n      if (field in obj) {\n        cloned = cloned || Object.assign({}, obj);\n        cloned[field] = 'Monti: redacted';\n      }\n    });\n\n    return cloned;\n  }\n\n  if (Array.isArray(toFilter)) {\n    let cloned;\n    // There could be thousands or more items in the array, and this usually runs\n    // before the data is validated. For performance reasons we limit how\n    // many to check\n    let length = Math.min(toFilter.length, this.maxArrayItemsToFilter);\n    for (let i = 0; i < length; i++) {\n      if (typeof toFilter[i] === 'object' && toFilter[i] !== null) {\n        let result = filterObject(toFilter[i]);\n        if (result) {\n          cloned = cloned || [...toFilter];\n          cloned[i] = result;\n        }\n      }\n    }\n\n    return cloned || toFilter;\n  }\n\n  return filterObject(toFilter) || toFilter;\n}\n\nKadira.tracer = new Tracer();\n// need to expose Tracer to provide default set of filters\nKadira.Tracer = Tracer;\n"]},"sourceType":"module","hash":"bff8ec028fbfa16b0aba1944c1887ea0f8b2d2d0"}
