{"version":3,"sources":["meteor://ðŸ’»app/packages/jcbernack:reactive-aggregate/mongo-collection-aggregate.js","meteor://ðŸ’»app/packages/jcbernack:reactive-aggregate/aggregate.js"],"names":["Meteor","module","link","v","Mongo","Collection","prototype","aggregate","pipeline","options","collection","rawCollection","wrapAsync","bind","_objectSpread","default","export","ReactiveAggregate","defaultOptions","observeSelector","observeOptions","delay","lookupCollections","clientCollection","_name","subscription","throttledUpdate","_","throttle","bindEnvironment","safePipeline","forEach","doc","_ids","_id","added","changed","_iteration","each","iteration","key","removed","update","initializing","observerHandles","createObserver","map","stage","$lookup","from","push","ready","onStop","handle","stop","queryOptions","selector","query","find","observeChanges","error","err"],"mappings":"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","file":"/packages/jcbernack_reactive-aggregate.js","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Mongo } from 'meteor/mongo';\n\nMongo.Collection.prototype.aggregate = function(pipeline, options) {\n  const collection = this.rawCollection();\n  return Meteor.wrapAsync(collection.aggregate.bind(collection))(pipeline, options);\n}\n","import { Meteor } from 'meteor/meteor';\nimport { Mongo } from 'meteor/mongo';\n\nconst defaultOptions = ({\n  collection, options\n}) => ({\n  observeSelector: {},\n  observeOptions: {},\n  delay: 250,\n  lookupCollections: {},\n  clientCollection: collection._name,\n  ...options\n});\n\nexport const ReactiveAggregate = function (subscription, collection, pipeline = [], options = {}) {\n  // fill out default options\n  const {\n    observeSelector, observeOptions, delay, lookupCollections, clientCollection\n  } = defaultOptions({\n    collection,\n    options\n  });\n\n  // run, or re-run, the aggregation pipeline\n  const throttledUpdate = _.throttle(Meteor.bindEnvironment(() => {\n    // add and update documents on the client\n    collection.aggregate(safePipeline).forEach((doc) => {\n      if (!subscription._ids[doc._id]) {\n        subscription.added(clientCollection, doc._id, doc);\n      } else {\n        subscription.changed(clientCollection, doc._id, doc);\n      }\n      subscription._ids[doc._id] = subscription._iteration;\n    });\n    // remove documents not in the result anymore\n    _.each(subscription._ids, (iteration, key) => {\n      if (iteration != subscription._iteration) {\n        delete subscription._ids[key];\n        subscription.removed(clientCollection, key);\n      }\n    });\n    subscription._iteration++;\n  }), delay);\n  const update = () => !initializing ? throttledUpdate() : null;\n\n  // don't update the subscription until __after__ the initial hydrating of our collection\n  let initializing = true;\n  // mutate the subscription to ensure it updates as we version it\n  subscription._ids = {};\n  subscription._iteration = 1;\n\n  // create a list of collections to watch and make sure\n  // we create a sanitized \"strings-only\" version of our pipeline\n  const observerHandles = [createObserver(collection, { observeSelector, observeOptions })];\n  // look for $lookup collections passed in as Mongo.Collection instances\n  // and create observers for them\n  // if any $lookup.from stages are passed in as strings they will be omitted\n  // from this process. the aggregation will still work, but those collections\n  // will not force an update to this query if changed.\n  const safePipeline = pipeline.map((stage) => {\n    if (stage.$lookup && stage.$lookup.from instanceof Mongo.Collection) {\n      const collection = stage.$lookup.from;\n      observerHandles.push(createObserver(collection, lookupCollections[collection._name]));\n      return {\n        ...stage,\n        $lookup: {\n          ...stage.$lookup,\n          from: collection._name\n        }\n      };\n    }\n    return stage;\n  });\n\n  // observeChanges() will immediately fire an \"added\" event for each document in the query\n  // these are skipped using the initializing flag\n  initializing = false;\n  // send an initial result set to the client\n  update();\n  // mark the subscription as ready\n  subscription.ready();\n  // stop observing the cursor when the client unsubscribes\n  subscription.onStop(() => observerHandles.map((handle) => handle.stop()));\n\n  /**\n\t * Create observer\n\t * @param {Mongo.Collection|*} collection\n\t * @returns {any|*|Meteor.LiveQueryHandle} Handle\n\t */\n  function createObserver(collection, queryOptions = {}) {\n    const { observeSelector, observeOptions } = queryOptions;\n    const selector = observeSelector || {};\n    const options = observeOptions || {};\n    const query = collection.find(selector, options);\n    return query.observeChanges({\n      added: update,\n      changed: update,\n      removed: update,\n      error: (err) => {\n        throw err;\n      }\n    });\n  }\n};\n"]}